---
description: >-
  Author: @Rittika1234|
  https://leetcode.com/problems/find-peak-element/
---

# 0162 - Find Peak Element (Medium)

## Problem Link

https://leetcode.com/problems/find-peak-element/

## Problem Statement

A peak element is an element that is strictly greater than its neighbors.

Given a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.

You may imagine that `nums[-1] = nums[n] = -∞`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.


**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
```

**Example 2:**

```
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.
```

**Constraints:**

* 1 <= nums.length <= 1000
* -231 <= nums[i] <= 231 - 1
* nums[i] != nums[i + 1] for all valid i.

## Approach 1: 

*This is a brute force approach. We traverse each element and check whether it is greater than or equal to its neighbours.

*If we find one, we return it.

*Else we move on.

**Time complexity: O(n)**

Space complexity: $O(1)$


<Tabs>
<TabItem value="java" label="Java">
<SolutionAuthor name="@Rittika1234"/>

```java
import java.util.*;

public class Solution {

  public static void main(String[] args) {
    int[] arr = {3, 5, 4, 1, 1};
    int n = arr.length;

    System.out.println("Peak Element is " + peakEleBruteForce(arr, n));
  }

  public static int peakEleBruteForce(int[] arr, int n) {

    if (arr[0] >= arr[1])
      return arr[0];

    for (int i = 1; i < n - 1; i++)
      if (arr[i] >= arr[i - 1] && arr[i] >= arr[i + 1])
        return arr[i];

    return arr[n - 1];
  }

}
```

</TabItem>
</Tabs>


## Approach 2: 

*So we are going to use binary search. As usual we find a middle element and if it is a peak, then we are done.

*If not we follow a greater element. That is we shrink the binary search to one half. To be precise, if the left element is a greater one, we then do binary search only on the left half.

*Else(the right element must be a greater one), we search on the right half.

*Ultimately, we’ll end up with one of the peaks.

**Time complexity: O(log(n))**

Space complexity:  $O(1)$


<Tabs>
<TabItem value="java" label="Java">
<SolutionAuthor name="@Rittika1234"/>

```java
class Solution {
    public int findPeakElement(int[] arr) {
          int start=0;
          int end=arr.length-1;
          while(start<end) {
    	  int mid= start+(end-start)/2;
    	  if(arr[mid]>arr[mid+1]) {
    		  end=mid;
    	  }else {
    		  start=mid+1;
    	  }
      }
      return start;
    }
}
```

</TabItem>
</Tabs>
