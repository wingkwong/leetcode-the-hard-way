---
description: >-
  Author: @Rittika1234|
  https://leetcode.com/problems/find-peak-element/
---

# 0162 - Find Peak Element (Medium)

## Problem Link

https://leetcode.com/problems/find-peak-element/

## Problem Statement

A peak element is an element that is strictly greater than its neighbors.

Given a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.

You may imagine that `nums[-1] = nums[n] = -âˆž`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.


**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
```

**Example 2:**

```
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.
```

**Constraints:**

* 1 <= nums.length <= 1000
* -231 <= nums[i] <= 231 - 1
* nums[i] != nums[i + 1] for all valid i.

## Approach 1: Brute Force

This is a brute force approach. We traverse each element and check whether it is greater than to max value.If we find one, than we initialize this value to max, return max value.

Time complexity: $O(n)$
Space complexity: $O(1)$


<Tabs>
<TabItem value="java" label="Java">
<SolutionAuthor name="@Rittika1234"/>

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int max=nums[0];
        int n=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]>max){
                max=nums[i];
                n=i;
            }
        }
        return n;
    }
}
```

</TabItem>
</Tabs>


## Approach 2: Binary Search

Create two variables, start and end, initialize start = 0 and end= arr.length-1
Recursively perform the below steps till start < end
Check if the mid value or index mid = start + (end - start) / 2
Check if arr[mid] is greater than or less than to  its arr[mid+1]
if arr[mid]is greater than to its arr[mid+1], then end= mid update the value,
if less than, then start = mid+1  update the value, otherwise return start.

Time complexity: $O(log(n))$
Space complexity:  $O(1)$


<Tabs>
<TabItem value="java" label="Java">
<SolutionAuthor name="@Rittika1234"/>

```java
class Solution {
    public int findPeakElement(int[] arr) {

        int start = 0;
        int end = arr.length - 1;

        while (start < end) {
            int mid = start + (end - start) / 2;
            if (arr[mid] > arr[mid+1]) {
                
                end = mid;
            } else {
                
                start = mid + 1; 
            }
        }
      
        return start; 
    }
}
```

</TabItem>
</Tabs>