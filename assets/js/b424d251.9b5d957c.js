"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[68187],{46755:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"1400-1499/pseudo-palindromic-paths-in-a-binary-tree-medium","title":"1457 - Pseudo-Palindromic Paths in a Binary Tree (Medium)","description":"Author: @wkw | https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/","source":"@site/solutions/1400-1499/1457-pseudo-palindromic-paths-in-a-binary-tree-medium.md","sourceDirName":"1400-1499","slug":"/1400-1499/pseudo-palindromic-paths-in-a-binary-tree-medium","permalink":"/solutions/1400-1499/pseudo-palindromic-paths-in-a-binary-tree-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1400-1499/1457-pseudo-palindromic-paths-in-a-binary-tree-medium.md","tags":[{"inline":true,"label":"Bit Manipulation","permalink":"/solutions/tags/bit-manipulation"},{"inline":true,"label":"Tree","permalink":"/solutions/tags/tree"},{"inline":true,"label":"Depth-First Search","permalink":"/solutions/tags/depth-first-search"},{"inline":true,"label":"Breadth-First Search","permalink":"/solutions/tags/breadth-first-search"},{"inline":true,"label":"Binary Tree","permalink":"/solutions/tags/binary-tree"}],"version":"current","sidebarPosition":1457,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/","tags":["Bit Manipulation","Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},"sidebar":"tutorialSidebar","previous":{"title":"1448 - Count Good Nodes in Binary Tree (Medium)","permalink":"/solutions/1400-1499/count-good-nodes-in-binary-tree-medium"},"next":{"title":"1460 - Make Two Arrays Equal by Reversing Subarrays (Easy)","permalink":"/solutions/1400-1499/make-two-arrays-equal-by-reversing-subarrays-easy"}}');var i=t(86070),o=t(40629);const a={description:"Author: @wkw | https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/",tags:["Bit Manipulation","Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},s="1457 - Pseudo-Palindromic Paths in a Binary Tree (Medium)",d={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Preorder Traversal + Bit Manipulation",id:"approach-1-preorder-traversal--bit-manipulation",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{SolutionAuthor:t,TabItem:r,Tabs:a}=n;return t||c("SolutionAuthor",!0),r||c("TabItem",!0),a||c("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"1457---pseudo-palindromic-paths-in-a-binary-tree-medium",children:"1457 - Pseudo-Palindromic Paths in a Binary Tree (Medium)"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/",children:"https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(n.p,{children:["Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be ",(0,i.jsx)(n.strong,{children:"pseudo-palindromic"})," if at least one permutation of the node values in the path is a palindrome."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Return the number of ",(0,i.jsx)(n.strong,{children:"pseudo-palindromic"})," paths going from the root node to leaf nodes."]})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: root = [2,3,1,3,1,null,1]\nOutput: 2\nExplanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: root = [2,1,1,1,3,null,null,null,null,null,1]\nOutput: 1\nExplanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: root = [9]\nOutput: 1\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The number of nodes in the tree is in the range ",(0,i.jsx)(n.code,{children:"[1, 105]"}),"."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= Node.val <= 9"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"approach-1-preorder-traversal--bit-manipulation",children:"Approach 1: Preorder Traversal + Bit Manipulation"}),"\n",(0,i.jsxs)(a,{children:[(0,i.jsxs)(r,{value:"cpp",label:"C++",children:[(0,i.jsx)(t,{name:"@wkw"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n// Time Complexity: O(N) where N is the number of nodes\n// Space Complexity: O(H) where H is the tree height\nclass Solution {\npublic:\n    int ans = 0;\n\n    // the idea is that there is at most one digit with odd frequency in pseudo-palindromic path\n    // e.g. [2, 3, 3] - digit 2 has odd frequency\n    // e.g. [9] - digit 9 has odd frequency\n    // so that the digit with odd frequency can be put in the middle, e.g. 323, 9, etc\n    int pseudoPalindromicPaths (TreeNode* root) {\n        preorder(root, 0);\n        return ans;\n    }\n\n    // if you don't know preorder traversal, try 144. Binary Tree Preorder Traversal first\n    // Problem Link: https://leetcode.com/problems/binary-tree-preorder-traversal/\n    // Explanation Link: https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/2549333/LeetCode-The-Hard-Way-DFS-or-Pre-Order-or-Explained-Line-By-Line\n    void preorder(TreeNode* node, int cnt) {\n        // preorder traversal step 1: if node is null, then return\n        if (node == NULL) return;\n        // preorder traversal step 2: do something with node value here\n\n        // first let's understand what (x << y) means\n        // (x << y): shifting `x` `y` bits to the left\n        // e.g. 1 << 0 = 1 (shift 0 bit - stay as it is)\n        // e.g. 1 << 1 = 0b10 (shift 1 bit - becomes 2)\n        // e.g. 1 << 2 = 0b100 (shift 2 bits to the left - becomes 4)\n        // you may find that (1 << n) is actually just power of 2. i.e. 2 ^ n\n\n        // second let's understand three properties of XOR\n        // 1. XOR is self-inverse which means x ^ x = 0 (number XOR number evaluates to 0)\n        // 2. 0 is identity element which means x ^ 0 = x (number XOR 0 remains unchanged)\n        // 3. XOR is commutative, which means x ^ y = y ^ x (order doesn't matter)\n\n        // we can use (1 << i) to set the appearance of digit i\n        // but how to count the odd frequency?\n        // we can use above XOR properties to achieve the following\n        // if the i-bit is set, then digit i has an odd frequency\n        // how? remember XOR property #1, #2, and #3?\n        // if a digit appears even number of times, the bit at the end will be 0. (x ^ x = 0)\n        // if a digit appears odd number of times, the bit at the will be 1. (x ^ x ^ x = (x ^ x) ^ x = 0 ^ x = x)\n        cnt ^= (1 << node->val);\n        // do something at the leaf\n        if (!node->left && !node->right) {\n            // if i-bit is set in `cnt`, that means digit `i` has an odd frequency\n            // therefore, the number of 1 in `cnt` = the number of digits with an odd frequency\n            // however, we only want at most one digit that has an odd frequency\n            // we can use a bit trick (n & (n - 1)) to remove the rightmost set bit.\n            // e.g.\n            // n     n     n - 1  n & (n - 1)\n            // --   ----   ----   -------\n            //  0   0000   0111    0000\n            //  1   0001   0000    0000\n            //  2   0010   0001    0000\n            //  3   0011   0010    0010\n            //  4   0100   0011    0000\n            //  5   0101   0100    0100\n            //  6   0110   0101    0100\n            //  7   0111   0110    0110\n            //  8   1000   0111    0000\n            //  9   1001   1000    1000\n            // 10   1010   1001    1000\n            // 11   1011   1010    1010\n            // 12   1100   1011    1000\n            // 13   1101   1100    1100\n            // 14   1110   1101    1100\n            // 15   1111   1110    1110\n\n            // if the result is 0, that means we have at most one digit that has an odd frequncy\n            // hence, add one to ans\n            ans += (cnt & (cnt - 1)) == 0;\n        }\n        // preorder traversal step 3: traverse the left node\n        preorder(node->left, cnt);\n        // preorder traversal step 4: traverse the right node\n        preorder(node->right, cnt);\n    }\n};\n"})})]}),(0,i.jsxs)(r,{value:"py",label:"Python",children:[(0,i.jsx)(t,{name:"@wkw"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"class Solution:\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:\n        if not root: return 0\n        cnt ^= 1 << (root.val - 1)\n        if root.left is None and root.right is None:\n            return 1 if cnt & (cnt - 1) == 0 else 0\n        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)\n"})})]}),(0,i.jsxs)(r,{value:"go",label:"Go",children:[(0,i.jsx)(t,{name:"@wkw"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc numberOfOnes(n int) int{\n   res := 0\n   for n > 0 {\n      res += n & 1\n      n >>= 1\n   }\n   return res\n}\n\nfunc preorder(root *TreeNode, cnt int) int {\n    if root == nil { return 0 }\n    cnt ^= (1 << root.Val)\n    if root.Left == nil && root.Right == nil && numberOfOnes(cnt) <= 1  { return 1 }\n    return preorder(root.Left, cnt) + preorder(root.Right, cnt)\n}\n\nfunc pseudoPalindromicPaths (root *TreeNode) int {\n    return preorder(root, 0)\n}\n"})})]})]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}function c(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},40629:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var r=t(30758);const i={},o=r.createContext(i);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);