"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[47163],{34699:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"1400-1499/count-good-nodes-in-binary-tree-medium","title":"1448 - Count Good Nodes in Binary Tree (Medium)","description":"Author: @wkw | https://leetcode.com/problems/count-good-nodes-in-binary-tree/","source":"@site/solutions/1400-1499/1448-count-good-nodes-in-binary-tree-medium.md","sourceDirName":"1400-1499","slug":"/1400-1499/count-good-nodes-in-binary-tree-medium","permalink":"/solutions/1400-1499/count-good-nodes-in-binary-tree-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1400-1499/1448-count-good-nodes-in-binary-tree-medium.md","tags":[{"inline":true,"label":"Tree","permalink":"/solutions/tags/tree"},{"inline":true,"label":"Depth-First Search","permalink":"/solutions/tags/depth-first-search"},{"inline":true,"label":"Breadth-First Search","permalink":"/solutions/tags/breadth-first-search"},{"inline":true,"label":"Binary Tree","permalink":"/solutions/tags/binary-tree"}],"version":"current","sidebarPosition":1448,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/count-good-nodes-in-binary-tree/","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},"sidebar":"tutorialSidebar","previous":{"title":"1443 - Minimum Time to Collect All Apples in a Tree (Medium)","permalink":"/solutions/1400-1499/minimum-time-to-collect-all-apples-in-a-tree"},"next":{"title":"1457 - Pseudo-Palindromic Paths in a Binary Tree (Medium)","permalink":"/solutions/1400-1499/pseudo-palindromic-paths-in-a-binary-tree-medium"}}');var r=t(86070),i=t(68906);const a={description:"Author: @wkw | https://leetcode.com/problems/count-good-nodes-in-binary-tree/",tags:["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},s="1448 - Count Good Nodes in Binary Tree (Medium)",l={},d=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS",id:"approach-1-dfs",level:2}];function h(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{SolutionAuthor:t,TabItem:o,Tabs:a}=n;return t||u("SolutionAuthor",!0),o||u("TabItem",!0),a||u("Tabs",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"1448---count-good-nodes-in-binary-tree-medium",children:"1448 - Count Good Nodes in Binary Tree (Medium)"})}),"\n",(0,r.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,r.jsxs)(n.p,{children:["Given a binary tree ",(0,r.jsx)(n.code,{children:"root"}),", a node ",(0,r.jsx)(n.em,{children:"X"})," in the tree is named\xa0",(0,r.jsx)(n.strong,{children:"good"})," if in the path from root to ",(0,r.jsx)(n.em,{children:"X"})," there are no nodes with a value ",(0,r.jsx)(n.em,{children:"greater than"})," X."]}),"\n",(0,r.jsxs)(n.p,{children:["Return the number of ",(0,r.jsx)(n.strong,{children:"good"})," nodes in the binary tree."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: root = [3,1,4,3,null,1,5]\nOutput: 4\nExplanation: Nodes in blue are good.\nRoot Node (3) is always a good node.\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\nNode 5 -> (3,4,5) is the maximum value in the path\nNode 3 -> (3,1,3) is the maximum value in the path.\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Input: root = [3,3,null,4,2]\nOutput: 3\nExplanation: Node 2 -> (3, 3, 2) is not good, because "3" is higher than it.\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: root = [1]\nOutput: 1\nExplanation: Root is considered as good.\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The number of nodes in the binary tree is in the range\xa0",(0,r.jsx)(n.code,{children:"[1, 10^5]"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Each node's value is between ",(0,r.jsx)(n.code,{children:"[-10^4, 10^4]"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"approach-1-dfs",children:"Approach 1: DFS"}),"\n",(0,r.jsxs)(a,{children:[(0,r.jsxs)(o,{value:"cpp",label:"C++",children:[(0,r.jsx)(t,{name:"@wkw"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Time complexity: O(N) as we visit every node only once.\n// Space complexity: O(H) where H is the height of the tree.\n// In the worst case, H would be N given that the tree only has one path.\nclass Solution {\npublic:\n    // the idea is to record the max value from the root to the node\n    // we can first initialise mx as INT_MIN\n    int goodNodes(TreeNode* root, int mx = INT_MIN) {\n        // if the root is null, we return 0\n        if (!root) return 0;\n        // then we can break it into 3 parts\n        // the first part is the current node\n        // if the current node value is greater than the maximum value so far\n        // that means the current node is a good node\n        // hence we add 1, else add 0\n        return (mx <= root->val ? 1 : 0) +\n                // the second part is the result of the left sub-tree\n                // we traverse it with the updated maximum value at the current point\n                // we don't need to check if root->left is null or not here\n                // as we cover the null case in the first line\n                goodNodes(root->left, max(root->val, mx)) +\n                // the last part is the result of the right sub-tree\n                // we traverse it with the updated maximum value at the current point\n                // we don't need to check if root->right is null or not here\n                // as we cover the null case in the first line\n                goodNodes(root->right, max(root->val, mx));\n    }\n};\n"})})]}),(0,r.jsxs)(o,{value:"python",label:"Python",children:[(0,r.jsx)(t,{name:"@ColeB2"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # Iterative Depth-First Search\n    # We can simply solve this problem by running a DFS, and passing down a max\n    # value to each node. A node is only good of it is >= to this max value.\n    # Time Complexity: O(n). We are going to have to precess each node.\n    # Space Complexity: O(h). Using a stack, we only ever have the current path\n    # inside our stack.\n    def goodNodes(self, root: TreeNode) -> int:\n        # Early termination\n        if not root:\n            return 0\n        # initialize return integer\n        num_good_nodes = 0\n        # initialize our stack, each item will be a tuple (node, max_value)\n        # where the max value is the max value we have seen thus far going down\n        # the path to the node.\n        stack = [(root, root.val)]\n        # while our stack still has nodes inside.\n        while stack:\n            # pop off the node and the highest value we have seen thus far.\n            node, high = stack.pop()\n            # Increment our num_good_nodes integer iff our current nodes value\n            # is greater than or equal to the highest node we have seen.\n            if node.val >= high:\n                num_good_nodes += 1\n            # if node has a left child\n            if node.left:\n                # add left child to the stack with the highest value.\n                # highest value will be larger of the current nodes value and\n                # the highest value that was passed to this iteration.\n                stack.append((node.left, max(node.val,high)))\n            # if the node has a right child\n            if node.right:\n                # add right child, make sure to update the high value.\n                stack.append((node.right, max(node.val, high)))\n        # return the number of good nodse that we calculated above.\n        return num_good_nodes\n"})})]})]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},68906:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var o=t(30758);const r={},i=o.createContext(r);function a(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);