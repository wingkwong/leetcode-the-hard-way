"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[6320],{52307:function(e){e.exports=JSON.parse('{"pluginId":"tutorials","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"Basic Topics","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Arrays","href":"/leetcode-the-hard-way/tutorials/basic-topics/arrays","docId":"basic-topics/arrays"},{"type":"link","label":"Backtracking","href":"/leetcode-the-hard-way/tutorials/basic-topics/backtracking","docId":"basic-topics/backtracking"},{"type":"link","label":"Binary Search","href":"/leetcode-the-hard-way/tutorials/basic-topics/binary-search","docId":"basic-topics/binary-search"},{"type":"link","label":"Hash Map","href":"/leetcode-the-hard-way/tutorials/basic-topics/hash-map","docId":"basic-topics/hash-map"},{"type":"link","label":"Heap (Priority Queue)","href":"/leetcode-the-hard-way/tutorials/basic-topics/heap","docId":"basic-topics/heap"},{"type":"link","label":"Queue & Stack","href":"/leetcode-the-hard-way/tutorials/basic-topics/queue-and-stack","docId":"basic-topics/queue-and-stack"},{"type":"link","label":"Sliding Window","href":"/leetcode-the-hard-way/tutorials/basic-topics/sliding-window","docId":"basic-topics/sliding-window"},{"type":"link","label":"Sorting","href":"/leetcode-the-hard-way/tutorials/basic-topics/sorting","docId":"basic-topics/sorting"},{"type":"link","label":"Time Complexity","href":"/leetcode-the-hard-way/tutorials/basic-topics/time-complexity","docId":"basic-topics/time-complexity"},{"type":"link","label":"Trie","href":"/leetcode-the-hard-way/tutorials/basic-topics/trie","docId":"basic-topics/trie"},{"type":"link","label":"Two Pointers","href":"/leetcode-the-hard-way/tutorials/basic-topics/two-pointers","docId":"basic-topics/two-pointers"}],"href":"/leetcode-the-hard-way/tutorials/category/basic-topics"},{"type":"category","label":"Graph Theory","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/leetcode-the-hard-way/tutorials/graph-theory/introduction","docId":"graph-theory/introduction"},{"type":"link","label":"Breadth First Search (BFS)","href":"/leetcode-the-hard-way/tutorials/graph-theory/breadth-first-search","docId":"graph-theory/breadth-first-search"},{"type":"link","label":"Depth First Search (DFS)","href":"/leetcode-the-hard-way/tutorials/graph-theory/depth-first-search","docId":"graph-theory/depth-first-search"},{"type":"link","label":"Dijkstra\'s Algorithm","href":"/leetcode-the-hard-way/tutorials/graph-theory/dijkstra","docId":"graph-theory/dijkstra"},{"type":"link","label":"Disjoint Set Union (DSU)","href":"/leetcode-the-hard-way/tutorials/graph-theory/disjoint-set-union","docId":"graph-theory/disjoint-set-union"},{"type":"link","label":"Minimum Spanning Tree","href":"/leetcode-the-hard-way/tutorials/graph-theory/minimum-spanning-tree","docId":"graph-theory/minimum-spanning-tree"}],"href":"/leetcode-the-hard-way/tutorials/category/graph-theory"},{"type":"category","label":"Math","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"Number Theory","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Binary Exponentiation","href":"/leetcode-the-hard-way/tutorials/math/number-theory/binary-exponentiation","docId":"math/number-theory/binary-exponentiation"},{"type":"link","label":"Sieve of Eratosthenes","href":"/leetcode-the-hard-way/tutorials/math/number-theory/sieve-of-eratosthenes","docId":"math/number-theory/sieve-of-eratosthenes"}],"href":"/leetcode-the-hard-way/tutorials/category/number-theory"}],"href":"/leetcode-the-hard-way/tutorials/category/math"}]},"docs":{"basic-topics/arrays":{"id":"basic-topics/arrays","title":"Arrays","description":"An array is a data structure consisting of a collection of elements.","sidebar":"tutorialSidebar"},"basic-topics/backtracking":{"id":"basic-topics/backtracking","title":"Backtracking","description":"A backtracking algorithm is used to construct a solution recursively by starting with an empty solution and adding solution one by one.","sidebar":"tutorialSidebar"},"basic-topics/binary-search":{"id":"basic-topics/binary-search","title":"Binary Search","description":"Binary search is the searching strategy that reduces the search space by half every iteration until you have found the target.","sidebar":"tutorialSidebar"},"basic-topics/hash-map":{"id":"basic-topics/hash-map","title":"Hash Map","description":"Hash Map provides quick lookup of certain values in O(1) time.","sidebar":"tutorialSidebar"},"basic-topics/heap":{"id":"basic-topics/heap","title":"Heap (Priority Queue)","description":"A heap, or a priority queue, is a data structure that efficiently stores elements in a particular order.","sidebar":"tutorialSidebar"},"basic-topics/queue-and-stack":{"id":"basic-topics/queue-and-stack","title":"Queue & Stack","description":"Stack is the data structure The first item that comes in will be the first to go out.","sidebar":"tutorialSidebar"},"basic-topics/sliding-window":{"id":"basic-topics/sliding-window","title":"Sliding Window","description":"Sliding window is a technique used to solve problems in array or string.","sidebar":"tutorialSidebar"},"basic-topics/sorting":{"id":"basic-topics/sorting","title":"Sorting","description":"Sorting refers to rearranging elements in a specific order.","sidebar":"tutorialSidebar"},"basic-topics/time-complexity":{"id":"basic-topics/time-complexity","title":"Time Complexity","description":"Time Complexity is one of the important measurements when it comes to writing an efficient solution.","sidebar":"tutorialSidebar"},"basic-topics/trie":{"id":"basic-topics/trie","title":"Trie","description":"A trie or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings.","sidebar":"tutorialSidebar"},"basic-topics/two-pointers":{"id":"basic-topics/two-pointers","title":"Two Pointers","description":"Two Pointers is an effective technique used for searching pairs in a sorted array.","sidebar":"tutorialSidebar"},"graph-theory/breadth-first-search":{"id":"graph-theory/breadth-first-search","title":"Breadth First Search (BFS)","description":"In BFS, we explore all the closest nodes first before going one step further.","sidebar":"tutorialSidebar"},"graph-theory/depth-first-search":{"id":"graph-theory/depth-first-search","title":"Depth First Search (DFS)","description":"In DFS, we aim to finish one branch before looking at other branches.","sidebar":"tutorialSidebar"},"graph-theory/dijkstra":{"id":"graph-theory/dijkstra","title":"Dijkstra\'s Algorithm","description":"Dijkstra\'s Algorithm is used to find the shortest paths between nodes in a graph.","sidebar":"tutorialSidebar"},"graph-theory/disjoint-set-union":{"id":"graph-theory/disjoint-set-union","title":"Disjoint Set Union (DSU)","description":"Disjoint Set Union is a data structure that allows us to combine any two sets into one.","sidebar":"tutorialSidebar"},"graph-theory/introduction":{"id":"graph-theory/introduction","title":"Introduction","description":"Graphs can solve a plethora of interesting problems!","sidebar":"tutorialSidebar"},"graph-theory/minimum-spanning-tree":{"id":"graph-theory/minimum-spanning-tree","title":"Minimum Spanning Tree","description":"A minimum spanning tree is a subset of the edges of a connected undirected graph with the minimum possible total edge weight and it does not contain any cycles.","sidebar":"tutorialSidebar"},"math/number-theory/binary-exponentiation":{"id":"math/number-theory/binary-exponentiation","title":"Binary Exponentiation","description":"Binary Exponentiation is also known as Exponentiation by Squaring.","sidebar":"tutorialSidebar"},"math/number-theory/sieve-of-eratosthenes":{"id":"math/number-theory/sieve-of-eratosthenes","title":"Sieve of Eratosthenes","description":"Sieve of Eratosthenes is a way of finding all prime numbers up to N (inclusive).","sidebar":"tutorialSidebar"}}}')}}]);