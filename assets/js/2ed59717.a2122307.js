"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[37257],{79085:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"2400-2499/number-of-ways-to-reach-a-position-after-exactly-k-steps-medium","title":"2400 - Number of Ways to Reach a Position After Exactly k Steps (Medium)","description":"Author: @wkw | https://leetcode.com/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/","source":"@site/solutions/2400-2499/2400-number-of-ways-to-reach-a-position-after-exactly-k-steps-medium.md","sourceDirName":"2400-2499","slug":"/2400-2499/number-of-ways-to-reach-a-position-after-exactly-k-steps-medium","permalink":"/solutions/2400-2499/number-of-ways-to-reach-a-position-after-exactly-k-steps-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2400-2499/2400-number-of-ways-to-reach-a-position-after-exactly-k-steps-medium.md","tags":[],"version":"current","sidebarPosition":2400,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/"},"sidebar":"tutorialSidebar","previous":{"title":"2400 - 2499","permalink":"/solutions/category/2400---2499"},"next":{"title":"2401 - Longest Nice Subarray (Medium)","permalink":"/solutions/2400-2499/longest-nice-subarray-medium"}}');var o=t(86070),r=t(40629);const i={description:"Author: @wkw | https://leetcode.com/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/"},a="2400 - Number of Ways to Reach a Position After Exactly k Steps (Medium)",c={},l=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: nCr",id:"approach-1-ncr",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{SolutionAuthor:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("SolutionAuthor",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"2400---number-of-ways-to-reach-a-position-after-exactly-k-steps-medium",children:"2400 - Number of Ways to Reach a Position After Exactly k Steps (Medium)"})}),"\n",(0,o.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,o.jsxs)(n.p,{children:["You are given two ",(0,o.jsx)(n.strong,{children:"positive"})," integers ",(0,o.jsx)(n.code,{children:"startPos"})," and ",(0,o.jsx)(n.code,{children:"endPos"}),". Initially, you are standing at position ",(0,o.jsx)(n.code,{children:"startPos"})," on an ",(0,o.jsx)(n.strong,{children:"infinite"})," number line. With one step, you can move either one position to the left, or one position to the right."]}),"\n",(0,o.jsxs)(n.p,{children:["Given a positive integer ",(0,o.jsx)(n.code,{children:"k"}),", return ",(0,o.jsxs)(n.em,{children:["the number of ",(0,o.jsx)(n.strong,{children:"different"})," ways to reach the position"]}),(0,o.jsx)(n.code,{children:"endPos"}),(0,o.jsx)(n.em,{children:"starting from"}),(0,o.jsx)(n.code,{children:"startPos"}),"*, such that you perform ",(0,o.jsx)(n.strong,{children:"exactly*"}),(0,o.jsx)(n.code,{children:"k"}),(0,o.jsx)(n.em,{children:"steps"}),". Since the answer may be very large, return it ",(0,o.jsx)(n.strong,{children:"modulo"})," ",(0,o.jsx)(n.code,{children:"1e9 + 7"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Two ways are considered different if the order of the steps made is not exactly the same."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Note"})," that the number line includes negative integers."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Input: startPos = 1, endPos = 2, k = 3\nOutput: 3\nExplanation: We can reach position 2 from 1 in exactly 3 steps in three ways:\n- 1 -> 2 -> 3 -> 2.\n- 1 -> 2 -> 1 -> 2.\n- 1 -> 0 -> 1 -> 2.\nIt can be proven that no other way is possible, so we return 3.\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Input: startPos = 2, endPos = 5, k = 10\nOutput: 0\nExplanation: It is impossible to reach position 5 from position 2 in exactly 10 steps.\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"1 <= startPos, endPos, k <= 1000"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"approach-1-ncr",children:"Approach 1: nCr"}),"\n",(0,o.jsx)(t,{name:"@wkw"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"struct comb {\n public:\n  int MOD = 1e9 + 7;\n  vector<long long> fac, finv, inv;\n  comb(int mxN) {\n    fac.resize(mxN);\n    finv.resize(mxN);\n    inv.resize(mxN);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 1; i < mxN - 1; i++) {\n      fac[i + 1] = fac[i] * (i + 1) % MOD;\n      inv[i + 1] = MOD - inv[MOD % (i + 1)] * (MOD / (i + 1)) % MOD;\n      finv[i + 1] = finv[i] * inv[i + 1] % MOD;\n    }\n  }\n\n  long long ncr(long long n, long long k) {\n    if (k < 0 || n < k) return 0;\n    long long res = 1;\n    res *= fac[n] * finv[k] % MOD * finv[n - k] % MOD;\n    return res;\n  }\n};\nclass Solution {\npublic:\n    int numberOfWays(int startPos, int endPos, int k) {\n        int MOD = 1e9 + 7;\n        // init comb\n        // see constraints: 1 <= startPos, endPos, k <= 1000\n        comb c = comb(1005);\n        // if (startPos + endPos) and k have different parity, then return 0\n        // otherwise we can use comb to get k choose (endPos - startPos + k) / 2\n        // it can also be k choose k - (endPos - startPos + k) / 2)\n        // assuming endPos >= startPos, and we know\n        // left + right = k -- (1)\n        // right - left = endPos - startPos -- (2)\n        // (1) + (2)\n        // left + right - left + right = k + endPos - startPos\n        // 2 * right = endPos - startPos + k\n        // right = (endPos - startPos + k) / 2\n        // in other word, left would be k - (endPos - startPos + k) / 2)\n        return (((startPos + endPos) ^ k) & 1) ? 0 : c.ncr(k, (endPos - startPos + k) / 2) % MOD;\n    }\n};\n"})}),"\n",(0,o.jsx)(t,{name:"@wkw"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-py",children:"class Solution:\n    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\n        MOD = 10 ** 9 + 7\n        # if (startPos + endPos) and k have different parity, then return 0\n        # otherwise we can use comb to get k choose (endPos - startPos + k) / 2\n        # it can also be k choose k - (endPos - startPos + k) / 2)\n        # assuming endPos >= startPos, and we know\n        # left + right = k -- (1)\n        # right - left = endPos - startPos -- (2)\n        # (1) + (2)\n        # left + right - left + right = k + endPos - startPos\n        # 2 * right = endPos - startPos + k\n        # right = (endPos - startPos + k) / 2\n        # in other word, left would be k - (endPos - startPos + k) / 2)\n        if (startPos + endPos) % 2 != k % 2:\n            return 0\n        else:\n            return comb(k, (endPos - startPos + k) // 2) % MOD\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},40629:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(30758);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);