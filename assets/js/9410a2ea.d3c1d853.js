"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[93040],{31373:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"0900-0999/most-stones-removed-with-same-row-or-column-medium","title":"0947 - Most Stones Removed with Same Row or Column (Medium)","description":"Author: @wkw | https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/","source":"@site/solutions/0900-0999/0947-most-stones-removed-with-same-row-or-column-medium.md","sourceDirName":"0900-0999","slug":"/0900-0999/most-stones-removed-with-same-row-or-column-medium","permalink":"/solutions/0900-0999/most-stones-removed-with-same-row-or-column-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0947-most-stones-removed-with-same-row-or-column-medium.md","tags":[{"inline":true,"label":"Depth-First Search","permalink":"/solutions/tags/depth-first-search"},{"inline":true,"label":"Union Find","permalink":"/solutions/tags/union-find"},{"inline":true,"label":"Graph","permalink":"/solutions/tags/graph"}],"version":"current","sidebarPosition":947,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/","tags":["Depth-First Search","Union Find","Graph"]},"sidebar":"tutorialSidebar","previous":{"title":"0946 - Validate Stack Sequences (Medium)","permalink":"/solutions/0900-0999/validate-stack-sequences-medium"},"next":{"title":"0948 - Bag of Tokens (Medium)","permalink":"/solutions/0900-0999/bag-of-tokens-medium"}}');var s=t(86070),r=t(32790);const i={description:"Author: @wkw | https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/",tags:["Depth-First Search","Union Find","Graph"]},a="0947 - Most Stones Removed with Same Row or Column (Medium)",l={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DSU",id:"approach-1-dsu",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{SolutionAuthor:t,TabItem:o,Tabs:i}=n;return t||d("SolutionAuthor",!0),o||d("TabItem",!0),i||d("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"0947---most-stones-removed-with-same-row-or-column-medium",children:"0947 - Most Stones Removed with Same Row or Column (Medium)"})}),"\n",(0,s.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/",children:"https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/"})}),"\n",(0,s.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,s.jsxs)(n.p,{children:["On a 2D plane, we place ",(0,s.jsx)(n.code,{children:"n"})," stones at some integer coordinate points. Each coordinate point may have at most one stone."]}),"\n",(0,s.jsxs)(n.p,{children:["A stone can be removed if it shares either ",(0,s.jsx)(n.strong,{children:"the same row or the same column"})," as another stone that has not been removed."]}),"\n",(0,s.jsxs)(n.p,{children:["Given an array ",(0,s.jsx)(n.code,{children:"stones"})," of length ",(0,s.jsx)(n.code,{children:"n"})," where ",(0,s.jsx)(n.code,{children:"stones[i] = [xi, yi]"})," represents the location of the ",(0,s.jsx)(n.code,{children:"ith"})," stone, return ",(0,s.jsx)(n.em,{children:"the largest possible number of stones that can be removed"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\nOutput: 5\nExplanation: One way to remove 5 stones is as follows:\n1. Remove stone [2,2] because it shares the same row as [2,1].\n2. Remove stone [2,1] because it shares the same column as [0,1].\n3. Remove stone [1,2] because it shares the same row as [1,0].\n4. Remove stone [1,0] because it shares the same column as [0,0].\n5. Remove stone [0,1] because it shares the same row as [0,0].\nStone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\nOutput: 3\nExplanation: One way to make 3 moves is as follows:\n1. Remove stone [2,2] because it shares the same row as [2,0].\n2. Remove stone [2,0] because it shares the same column as [0,0].\n3. Remove stone [0,2] because it shares the same row as [0,0].\nStones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Input: stones = [[0,0]]\nOutput: 0\nExplanation: [0,0] is the only stone on the plane, so you cannot remove it.\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"1 <= stones.length <= 1000"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"0 <= xi, yi <= 10^4"})}),"\n",(0,s.jsx)(n.li,{children:"No two stones are at the same coordinate point."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"approach-1-dsu",children:"Approach 1: DSU"}),"\n",(0,s.jsx)(i,{children:(0,s.jsxs)(o,{value:"cpp",label:"C++",children:[(0,s.jsx)(t,{name:"@wkw"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// retrieved from https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/disjoint-set-union\nclass dsu {\n public:\n  vector<int> root, rank;\n  int n;\n  int cnt;\n\n  dsu(int _n) : n(_n) {\n    root.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; i++) {\n        root[i] = i;\n        rank[i] = 1;\n    }\n    cnt = n;\n  }\n\n  inline int getCount() { return cnt; }\n\n  inline int get(int x) { return (x == root[x] ? x : (root[x] = get(root[x]))); }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n        if (rank[x] > rank[y]) {\n            root[y] = x;\n        } else if (rank[x] < rank[y]) {\n            root[x] = y;\n        } else {\n            root[y] = x;\n            rank[x] += 1;\n        }\n        cnt--;\n      return true;\n    }\n    return false;\n  }\n};\n\n// idea:\n// if two stones shares the same row or the same column,\n// we can use DSU to unite them together so that they are in the same group\n// for each group, we want to keep at least 1 stone (i.e. others will be removed)\n// hence, the answer is just the total count - the number of the connected components\nclass Solution {\npublic:\n    int removeStones(vector<vector<int>>& stones) {\n        int n = (int) stones.size();\n        // init dsu\n        dsu d = dsu(n);\n        // iterate all pairs\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // if two stones shares the same row or the same column\n                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\n                    // unite them together\n                    d.unite(i, j);\n                }\n            }\n        }\n        // the max number of stones that can be removed is simply\n        // the total count - the number of the connected components\n        return n - d.getCount();\n    }\n};\n"})}),(0,s.jsx)(t,{name:"@wkw"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    vector<int> parent;\n    int find(int x) {\n        return parent[x] == x ? x : find(parent[x]);\n    }\n\n    int removeStones(vector<vector<int>>& stones) {\n        int n = (int) stones.size();\n        parent.resize(n + 1, 0);\n        // at the beginning, each element is in its own group\n        for(int i = 0; i <= n; i++) parent[i] = i;\n        // iterate each pair\n        for(int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                // if two stones shares the same row or the same column\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\n                    // get the root of `i`\n                    int a = find(i);\n                    // get the root of `j`\n                    int b = find(j);\n                    // if they don't belong to the same group, unite them together\n                    if(a != b) parent[b] = a;\n                }\n            }\n        }\n        int connected = 0;\n        // if `i` is the root, then we found a new connected component\n        for(int i = 0; i < n; i++) connected += parent[i] == i;\n        // the max number of stones that can be removed is simply\n        // the total count - the number of the connected components\n        return n - connected;\n    }\n};\n"})})]})})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}function d(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},32790:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(30758);const s={},r=o.createContext(s);function i(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);