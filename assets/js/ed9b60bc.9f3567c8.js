"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[8263],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return h}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function m(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),o=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=o(e.components);return a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=m(e,["components","mdxType","originalType","parentName"]),c=o(t),h=r,d=c["".concat(l,".").concat(h)]||c[h]||u[h]||i;return t?a.createElement(d,s(s({ref:n},p),{},{components:t})):a.createElement(d,s({ref:n},p))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=c;var m={};for(var l in n)hasOwnProperty.call(n,l)&&(m[l]=n[l]);m.originalType=e,m.mdxType="string"==typeof e?e:r,s[1]=m;for(var o=2;o<i;o++)s[o]=t[o];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},6865:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return m},metadata:function(){return o},toc:function(){return u}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),s=["components"],m={description:"Author: @heiheihang | https://leetcode.com/problems/next-greater-element-i/"},l="0469 - Next Greater Element I (Easy)",o={unversionedId:"0400-0499/next-greater-element-i-easy",id:"0400-0499/next-greater-element-i-easy",title:"0469 - Next Greater Element I (Easy)",description:"Author: @heiheihang | https://leetcode.com/problems/next-greater-element-i/",source:"@site/solutions/0400-0499/0469-next-greater-element-i-easy.md",sourceDirName:"0400-0499",slug:"/0400-0499/next-greater-element-i-easy",permalink:"/leetcode-the-hard-way/solutions/0400-0499/next-greater-element-i-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/solutions/0400-0499/0469-next-greater-element-i-easy.md",tags:[],version:"current",lastUpdatedBy:"Wing-Kam Wong",lastUpdatedAt:1652613881,formattedLastUpdatedAt:"5/15/2022",sidebarPosition:469,frontMatter:{description:"Author: @heiheihang | https://leetcode.com/problems/next-greater-element-i/"},sidebar:"tutorialSidebar",previous:{title:"0465 - Optimal Account Balancing (Hard)",permalink:"/leetcode-the-hard-way/solutions/0400-0499/optimal-account-balancing-hard"},next:{title:"0473 - Matchsticks to Square (Medium)",permalink:"/leetcode-the-hard-way/solutions/0400-0499/matchsticks-to-square-medium"}},p={},u=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Hash Map + Stack",id:"approach-1-hash-map--stack",level:2}],c={toc:u};function h(e){var n=e.components,t=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0469---next-greater-element-i-easy"},"0469 - Next Greater Element I (Easy)"),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"next greater element")," of some element ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," in an array is the ",(0,i.kt)("strong",{parentName:"p"},"first greater")," element that is ",(0,i.kt)("strong",{parentName:"p"},"to the right")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," in the same array."),(0,i.kt)("p",null,"You are given two ",(0,i.kt)("strong",{parentName:"p"},"distinct 0-indexed")," integer arrays ",(0,i.kt)("inlineCode",{parentName:"p"},"nums1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"nums2"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"nums1")," is a subset of ",(0,i.kt)("inlineCode",{parentName:"p"},"nums2"),"."),(0,i.kt)("p",null,"For each ",(0,i.kt)("inlineCode",{parentName:"p"},"0 <= i < nums1.length"),", find the index ",(0,i.kt)("inlineCode",{parentName:"p"},"j")," such that ",(0,i.kt)("inlineCode",{parentName:"p"},"nums1[i] == nums2[j]")," and determine the ",(0,i.kt)("strong",{parentName:"p"},"next greater element")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"nums2[j]")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"nums2"),". If there is no next greater element, then the answer for this query is ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),"."),(0,i.kt)("p",null,"Return ",(0,i.kt)("em",{parentName:"p"},"an array")," ",(0,i.kt)("inlineCode",{parentName:"p"},"ans")," ",(0,i.kt)("em",{parentName:"p"},"of length")," ",(0,i.kt)("inlineCode",{parentName:"p"},"nums1.length")," ",(0,i.kt)("em",{parentName:"p"},"such that")," ",(0,i.kt)("inlineCode",{parentName:"p"},"ans[i]")," ",(0,i.kt)("em",{parentName:"p"},"is the ",(0,i.kt)("strong",{parentName:"em"},"next greater element")," as described above.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1. \n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= nums1.length <= nums2.length <= 1000")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0 <= nums1[i], nums2[i] <= 104")),(0,i.kt)("li",{parentName:"ul"},"All integers in ",(0,i.kt)("inlineCode",{parentName:"li"},"nums1")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"nums2")," are ",(0,i.kt)("strong",{parentName:"li"},"unique"),"."),(0,i.kt)("li",{parentName:"ul"},"All the integers of ",(0,i.kt)("inlineCode",{parentName:"li"},"nums1")," also appear in ",(0,i.kt)("inlineCode",{parentName:"li"},"nums2"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Follow up:")," Could you find an ",(0,i.kt)("inlineCode",{parentName:"p"},"O(nums1.length + nums2.length)")," solution?"),(0,i.kt)("h2",{id:"approach-1-hash-map--stack"},"Approach 1: Hash Map + Stack"),(0,i.kt)("p",null,"The first thing we need to do is to store the ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mi",{parentName:"mrow"},"v"),(0,i.kt)("mi",{parentName:"mrow"},"a"),(0,i.kt)("mi",{parentName:"mrow"},"l"),(0,i.kt)("mi",{parentName:"mrow"},"u"),(0,i.kt)("mi",{parentName:"mrow"},"e"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mi",{parentName:"mrow"},"i"),(0,i.kt)("mi",{parentName:"mrow"},"n"),(0,i.kt)("mi",{parentName:"mrow"},"d"),(0,i.kt)("mi",{parentName:"mrow"},"e"),(0,i.kt)("mi",{parentName:"mrow"},"x"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"(value, index)")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"v"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"a"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"u"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"in"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")")))))," pair from ",(0,i.kt)("inlineCode",{parentName:"p"},"nums1")," in a hash map."),(0,i.kt)("p",null,"Then we need to find the ",(0,i.kt)("em",{parentName:"p"},"next greater element")," of all elements in ",(0,i.kt)("inlineCode",{parentName:"p"},"nums2"),". This can be achieved by using a stack. If the current element is greater than the last element of the stack, we know the next greater element of the last element of the stack is the current element. We can access the index of the last element of the stack with ",(0,i.kt)("inlineCode",{parentName:"p"},"hash_map")," (if it exists). Then we can put the current","_","element in result."," "),(0,i.kt)("p",null,"After processing ",(0,i.kt)("inlineCode",{parentName:"p"},"nums2"),", we need to assign ",(0,i.kt)("inlineCode",{parentName:"p"},"-1")," to the elements still in the stack (no ",(0,i.kt)("em",{parentName:"p"},"next greater element"),") with the help of ",(0,i.kt)("inlineCode",{parentName:"p"},"hash_map"),"."," "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        \n        #initialize hash map to store the (value, index) pair in nums1\n        hash_map = {}\n        \n        #put (value, index) pair of nums1 in hash_map\n        for i in range(len(nums1)):\n            hash_map[nums1[i]] = i\n        \n        \n        #initialize result list    \n        result = [0] * len(nums1)\n        \n        #initialize stack list\n        stack = []\n        \n        #iterate all elements in nums2\n        for i in range(len(nums2)):\n            \n            current_number = nums2[i]\n            \n            #if current_number is larger than the last element in stack\n            #current_number is the next greater element of the last number in stack\n            while(stack and current_number > stack[-1]):\n                \n                #we need to check if the last number in stack is in nums1 \n                if(stack[-1] in hash_map):\n                    \n                    #we can get its index from hash_map\n                    index_in_nums1 = hash_map[stack[-1]]\n                    \n                    #we then set the corresponding position in result to current_number\n                    result[index_in_nums1] = current_number\n                    \n                #remove the last element in stack after processing\n                stack.pop()\n                \n            #add current_number to stack, trying to find the next greater element\n            stack.append(current_number)\n        \n        #for the numbers that do not have a next greater element, set it to -1\n        for remaining_number in stack:\n            \n            #we need to check if remaining_number is in nums1\n            if(remaining_number in hash_map):\n                \n                #we can get its index in nums1 from hash_map\n                index_in_nums1 = hash_map[remaining_number]\n    \n                #set its position in result to -1 (no greater element)\n                result[index_in_nums1] = -1\n        \n        #return result\n        return result\n")))}h.isMDXComponent=!0}}]);