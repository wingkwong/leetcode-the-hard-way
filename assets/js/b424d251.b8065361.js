"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[68187],{58860(e,n,t){t.d(n,{xA:()=>d,yg:()=>m});var r=t(37953);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach(function(n){a(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef(function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=p(t),m=a,c=h["".concat(s,".").concat(m)]||h[m]||u[m]||o;return t?r.createElement(c,i(i({ref:n},d),{},{components:t})):r.createElement(c,i({ref:n},d))});function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},59664(e,n,t){t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>y,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=t(9346),a=(t(37953),t(58860));const o={description:"Author: @wkw | https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/",tags:["Bit Manipulation","Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},i="1457 - Pseudo-Palindromic Paths in a Binary Tree (Medium)",l={unversionedId:"1400-1499/pseudo-palindromic-paths-in-a-binary-tree-medium",id:"1400-1499/pseudo-palindromic-paths-in-a-binary-tree-medium",title:"1457 - Pseudo-Palindromic Paths in a Binary Tree (Medium)",description:"Author: @wkw | https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/",source:"@site/solutions/1400-1499/1457-pseudo-palindromic-paths-in-a-binary-tree-medium.md",sourceDirName:"1400-1499",slug:"/1400-1499/pseudo-palindromic-paths-in-a-binary-tree-medium",permalink:"/solutions/1400-1499/pseudo-palindromic-paths-in-a-binary-tree-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1400-1499/1457-pseudo-palindromic-paths-in-a-binary-tree-medium.md",tags:[{label:"Bit Manipulation",permalink:"/solutions/tags/bit-manipulation"},{label:"Tree",permalink:"/solutions/tags/tree"},{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Breadth-First Search",permalink:"/solutions/tags/breadth-first-search"},{label:"Binary Tree",permalink:"/solutions/tags/binary-tree"}],version:"current",sidebarPosition:1457,frontMatter:{description:"Author: @wkw | https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/",tags:["Bit Manipulation","Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},sidebar:"tutorialSidebar",previous:{title:"1448 - Count Good Nodes in Binary Tree (Medium)",permalink:"/solutions/1400-1499/count-good-nodes-in-binary-tree-medium"},next:{title:"1460 - Make Two Arrays Equal by Reversing Subarrays (Easy)",permalink:"/solutions/1400-1499/make-two-arrays-equal-by-reversing-subarrays-easy"}},s={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Preorder Traversal + Bit Manipulation",id:"approach-1-preorder-traversal--bit-manipulation",level:2}],d=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.yg)("div",n)},u=d("Tabs"),h=d("TabItem"),m=d("SolutionAuthor"),c={toc:p};function y({components:e,...n}){return(0,a.yg)("wrapper",(0,r.A)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"1457---pseudo-palindromic-paths-in-a-binary-tree-medium"},"1457 - Pseudo-Palindromic Paths in a Binary Tree (Medium)"),(0,a.yg)("h2",{id:"problem-link"},"Problem Link"),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/"},"https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/")),(0,a.yg)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.yg)("p",null,"Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be ",(0,a.yg)("strong",{parentName:"p"},"pseudo-palindromic")," if at least one permutation of the node values in the path is a palindrome."),(0,a.yg)("p",null,(0,a.yg)("em",{parentName:"p"},"Return the number of ",(0,a.yg)("strong",{parentName:"em"},"pseudo-palindromic")," paths going from the root node to leaf nodes.")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example 1:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"Input: root = [2,3,1,3,1,null,1]\nOutput: 2\nExplanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).\n")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example 2:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"Input: root = [2,1,1,1,3,null,null,null,null,null,1]\nOutput: 1\nExplanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).\n")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example 3:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"Input: root = [9]\nOutput: 1\n")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Constraints:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"The number of nodes in the tree is in the range ",(0,a.yg)("inlineCode",{parentName:"li"},"[1, 105]"),"."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"1 <= Node.val <= 9"))),(0,a.yg)("h2",{id:"approach-1-preorder-traversal--bit-manipulation"},"Approach 1: Preorder Traversal + Bit Manipulation"),(0,a.yg)(u,{mdxType:"Tabs"},(0,a.yg)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.yg)(m,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n// Time Complexity: O(N) where N is the number of nodes\n// Space Complexity: O(H) where H is the tree height\nclass Solution {\npublic:\n    int ans = 0;\n\n    // the idea is that there is at most one digit with odd frequency in pseudo-palindromic path\n    // e.g. [2, 3, 3] - digit 2 has odd frequency\n    // e.g. [9] - digit 9 has odd frequency\n    // so that the digit with odd frequency can be put in the middle, e.g. 323, 9, etc\n    int pseudoPalindromicPaths (TreeNode* root) {\n        preorder(root, 0);\n        return ans;\n    }\n\n    // if you don't know preorder traversal, try 144. Binary Tree Preorder Traversal first\n    // Problem Link: https://leetcode.com/problems/binary-tree-preorder-traversal/\n    // Explanation Link: https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/2549333/LeetCode-The-Hard-Way-DFS-or-Pre-Order-or-Explained-Line-By-Line\n    void preorder(TreeNode* node, int cnt) {\n        // preorder traversal step 1: if node is null, then return\n        if (node == NULL) return;\n        // preorder traversal step 2: do something with node value here\n\n        // first let's understand what (x << y) means\n        // (x << y): shifting `x` `y` bits to the left\n        // e.g. 1 << 0 = 1 (shift 0 bit - stay as it is)\n        // e.g. 1 << 1 = 0b10 (shift 1 bit - becomes 2)\n        // e.g. 1 << 2 = 0b100 (shift 2 bits to the left - becomes 4)\n        // you may find that (1 << n) is actually just power of 2. i.e. 2 ^ n\n\n        // second let's understand three properties of XOR\n        // 1. XOR is self-inverse which means x ^ x = 0 (number XOR number evaluates to 0)\n        // 2. 0 is identity element which means x ^ 0 = x (number XOR 0 remains unchanged)\n        // 3. XOR is commutative, which means x ^ y = y ^ x (order doesn't matter)\n\n        // we can use (1 << i) to set the appearance of digit i\n        // but how to count the odd frequency?\n        // we can use above XOR properties to achieve the following\n        // if the i-bit is set, then digit i has an odd frequency\n        // how? remember XOR property #1, #2, and #3?\n        // if a digit appears even number of times, the bit at the end will be 0. (x ^ x = 0)\n        // if a digit appears odd number of times, the bit at the will be 1. (x ^ x ^ x = (x ^ x) ^ x = 0 ^ x = x)\n        cnt ^= (1 << node->val);\n        // do something at the leaf\n        if (!node->left && !node->right) {\n            // if i-bit is set in `cnt`, that means digit `i` has an odd frequency\n            // therefore, the number of 1 in `cnt` = the number of digits with an odd frequency\n            // however, we only want at most one digit that has an odd frequency\n            // we can use a bit trick (n & (n - 1)) to remove the rightmost set bit.\n            // e.g.\n            // n     n     n - 1  n & (n - 1)\n            // --   ----   ----   -------\n            //  0   0000   0111    0000\n            //  1   0001   0000    0000\n            //  2   0010   0001    0000\n            //  3   0011   0010    0010\n            //  4   0100   0011    0000\n            //  5   0101   0100    0100\n            //  6   0110   0101    0100\n            //  7   0111   0110    0110\n            //  8   1000   0111    0000\n            //  9   1001   1000    1000\n            // 10   1010   1001    1000\n            // 11   1011   1010    1010\n            // 12   1100   1011    1000\n            // 13   1101   1100    1100\n            // 14   1110   1101    1100\n            // 15   1111   1110    1110\n\n            // if the result is 0, that means we have at most one digit that has an odd frequncy\n            // hence, add one to ans\n            ans += (cnt & (cnt - 1)) == 0;\n        }\n        // preorder traversal step 3: traverse the left node\n        preorder(node->left, cnt);\n        // preorder traversal step 4: traverse the right node\n        preorder(node->right, cnt);\n    }\n};\n"))),(0,a.yg)(h,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.yg)(m,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:\n        if not root: return 0\n        cnt ^= 1 << (root.val - 1)\n        if root.left is None and root.right is None:\n            return 1 if cnt & (cnt - 1) == 0 else 0\n        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)\n"))),(0,a.yg)(h,{value:"go",label:"Go",mdxType:"TabItem"},(0,a.yg)(m,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc numberOfOnes(n int) int{\n   res := 0\n   for n > 0 {\n      res += n & 1\n      n >>= 1\n   }\n   return res\n}\n\nfunc preorder(root *TreeNode, cnt int) int {\n    if root == nil { return 0 }\n    cnt ^= (1 << root.Val)\n    if root.Left == nil && root.Right == nil && numberOfOnes(cnt) <= 1  { return 1 }\n    return preorder(root.Left, cnt) + preorder(root.Right, cnt)\n}\n\nfunc pseudoPalindromicPaths (root *TreeNode) int {\n    return preorder(root, 0)\n}\n")))))}y.isMDXComponent=!0}}]);