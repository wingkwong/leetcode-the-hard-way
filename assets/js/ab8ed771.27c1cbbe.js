"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[65428],{80768:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"2000-2099/parallel-courses-iii-hard","title":"2050 - Parallel Courses III (Hard)","description":"Author: @wingkwong | https://leetcode.com/problems/parallel-courses-iii/","source":"@site/solutions/2000-2099/2050-parallel-courses-iii-hard.md","sourceDirName":"2000-2099","slug":"/2000-2099/parallel-courses-iii-hard","permalink":"/solutions/2000-2099/parallel-courses-iii-hard","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2000-2099/2050-parallel-courses-iii-hard.md","tags":[{"inline":true,"label":"Array","permalink":"/solutions/tags/array"},{"inline":true,"label":"Dynamic Programming","permalink":"/solutions/tags/dynamic-programming"},{"inline":true,"label":"Graph","permalink":"/solutions/tags/graph"},{"inline":true,"label":"Topological Sort","permalink":"/solutions/tags/topological-sort"}],"version":"current","sidebarPosition":2050,"frontMatter":{"description":"Author: @wingkwong | https://leetcode.com/problems/parallel-courses-iii/","tags":["Array","Dynamic Programming","Graph","Topological Sort"]},"sidebar":"tutorialSidebar","previous":{"title":"2032 - Two Out of Three (Easy)","permalink":"/solutions/2000-2099/two-out-of-three-easy"},"next":{"title":"2075 - Decode the Slanted Ciphertext (Medium)","permalink":"/solutions/2000-2099/decode-the-slanted-ciphertext-medium"}}');var i=r(74848),s=r(28453);const o={description:"Author: @wingkwong | https://leetcode.com/problems/parallel-courses-iii/",tags:["Array","Dynamic Programming","Graph","Topological Sort"]},l="2050 - Parallel Courses III (Hard)",a={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS",id:"approach-1-dfs",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{SolutionAuthor:r,TabItem:t,Tabs:o}=n;return r||u("SolutionAuthor",!0),t||u("TabItem",!0),o||u("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"2050---parallel-courses-iii-hard",children:"2050 - Parallel Courses III (Hard)"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/parallel-courses-iii/",children:"https://leetcode.com/problems/parallel-courses-iii/"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(n.p,{children:["You are given an integer ",(0,i.jsx)(n.code,{children:"n"}),", which indicates that there are ",(0,i.jsx)(n.code,{children:"n"})," courses labeled from ",(0,i.jsx)(n.code,{children:"1"})," to ",(0,i.jsx)(n.code,{children:"n"}),". You are also given a 2D integer array ",(0,i.jsx)(n.code,{children:"relations"})," where ",(0,i.jsx)(n.code,{children:"relations[j] = [prevCoursej, nextCoursej]"})," denotes that course ",(0,i.jsx)(n.code,{children:"prevCoursej"})," has to be completed ",(0,i.jsx)(n.strong,{children:"before"})," course ",(0,i.jsx)(n.code,{children:"nextCoursej"})," (prerequisite relationship). Furthermore, you are given a ",(0,i.jsx)(n.strong,{children:"0-indexed"})," integer array ",(0,i.jsx)(n.code,{children:"time"})," where ",(0,i.jsx)(n.code,{children:"time[i]"})," denotes how many ",(0,i.jsx)(n.strong,{children:"months"})," it takes to complete the ",(0,i.jsx)(n.code,{children:"(i+1)th"})," course."]}),"\n",(0,i.jsxs)(n.p,{children:["You must find the ",(0,i.jsx)(n.strong,{children:"minimum"})," number of months needed to complete all the courses following these rules:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["You may start taking a course at ",(0,i.jsx)(n.strong,{children:"any time"})," if the prerequisites are met."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Any number of courses"})," can be taken at the ",(0,i.jsx)(n.strong,{children:"same time"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Return ",(0,i.jsxs)(n.em,{children:["the ",(0,i.jsx)(n.strong,{children:"minimum"})," number of months needed to complete all the courses"]}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: n = 3, relations = [[1,3],[2,3]], time = [3,2,5]\nOutput: 8\nExplanation: The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]\nOutput: 12\nExplanation: The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= n <= 5 * 10 ^ 4"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"0 <= relations.length <= min(n * (n - 1) / 2, 5 * 10 ^ 4)"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"relations[j].length == 2"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= prevCoursej, nextCoursej <= n"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"prevCoursej != nextCoursej"})}),"\n",(0,i.jsxs)(n.li,{children:["All the pairs ",(0,i.jsx)(n.code,{children:"[prevCoursej, nextCoursej]"})," are ",(0,i.jsx)(n.strong,{children:"unique"}),"."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"time.length == n"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= time[i] <= 10 ^ 4"})}),"\n",(0,i.jsx)(n.li,{children:"The given graph is a directed acyclic graph."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"approach-1-dfs",children:"Approach 1: DFS"}),"\n",(0,i.jsxs)(n.p,{children:["We can use dfs to find the maximum time of all the paths starting from ",(0,i.jsx)(n.code,{children:"u"}),". If there is no prerequisite relationship for ",(0,i.jsx)(n.code,{children:"u"}),", we can simply return ",(0,i.jsx)(n.code,{children:"time[u]"}),". Otherwise, we check the same for all of the neighbors. We can the maximum of all the results."]}),"\n",(0,i.jsx)(o,{children:(0,i.jsxs)(t,{value:"py",label:"Python",children:[(0,i.jsx)(r,{name:"@wingkwong"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"class Solution:\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\n        g = defaultdict(list)\n        # build the prerequisite graph \n        # minus one to make it zero indexing\n        for x in relations: g[x[0] - 1].append(x[1] - 1)\n        # memoize it to improve performance\n        @cache\n        def dfs(u):\n            # no prerequisite relationship -> return its time\n            if not g[u]: return time[u]\n            # the current time + the max of the dfs result from the neighbors\n            return max([dfs(v) for v in g[u]]) + time[u]\n        # try all the nodes \n        return max([dfs(i) for i in range(n)])\n"})})]})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var t=r(96540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);