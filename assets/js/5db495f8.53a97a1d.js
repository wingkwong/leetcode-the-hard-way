"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[43790],{58860(e,n,t){t.d(n,{xA:()=>g,yg:()=>u});var s=t(37953);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,s)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach(function(n){r(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function o(e,n){if(null==e)return{};var t,s,r=function(e,n){if(null==e)return{};var t,s,r={},a=Object.keys(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=s.createContext({}),d=function(e){var n=s.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},g=function(e){var n=d(e.components);return s.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return s.createElement(s.Fragment,{},n)}},m=s.forwardRef(function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,g=o(e,["components","mdxType","originalType","parentName"]),m=d(t),u=r,c=m["".concat(l,".").concat(u)]||m[u]||p[u]||a;return t?s.createElement(c,i(i({ref:n},g),{},{components:t})):s.createElement(c,i({ref:n},g))});function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=m;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var d=2;d<a;d++)i[d]=t[d];return s.createElement.apply(null,i)}return s.createElement.apply(null,t)}m.displayName="MDXCreateElement"},64387(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var s=t(9346),r=(t(37953),t(58860));const a={description:"Author: @wkw | https://leetcode.com/problems/restore-ip-addresses/",tags:["String","Backtracking"]},i="0093 - Restore IP Addresses (Medium)",o={unversionedId:"0000-0099/restore-ip-addresses-medium",id:"0000-0099/restore-ip-addresses-medium",title:"0093 - Restore IP Addresses (Medium)",description:"Author: @wkw | https://leetcode.com/problems/restore-ip-addresses/",source:"@site/solutions/0000-0099/0093-restore-ip-addresses-medium.md",sourceDirName:"0000-0099",slug:"/0000-0099/restore-ip-addresses-medium",permalink:"/solutions/0000-0099/restore-ip-addresses-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0000-0099/0093-restore-ip-addresses-medium.md",tags:[{label:"String",permalink:"/solutions/tags/string"},{label:"Backtracking",permalink:"/solutions/tags/backtracking"}],version:"current",sidebarPosition:93,frontMatter:{description:"Author: @wkw | https://leetcode.com/problems/restore-ip-addresses/",tags:["String","Backtracking"]},sidebar:"tutorialSidebar",previous:{title:"0091 - Decode Ways (Medium)",permalink:"/solutions/0000-0099/decode-ways-medium"},next:{title:"0094 - Binary Tree Inorder Traversal (Easy)",permalink:"/solutions/0000-0099/binary-tree-inorder-traversal-easy"}},l={},d=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Iterative",id:"approach-1-iterative",level:2}],g=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.yg)("div",n)},p=g("Tabs"),m=g("TabItem"),u=g("SolutionAuthor"),c={toc:d};function h({components:e,...n}){return(0,r.yg)("wrapper",(0,s.A)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"0093---restore-ip-addresses-medium"},"0093 - Restore IP Addresses (Medium)"),(0,r.yg)("h2",{id:"problem-link"},"Problem Link"),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/restore-ip-addresses/"},"https://leetcode.com/problems/restore-ip-addresses/")),(0,r.yg)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.yg)("p",null,"A ",(0,r.yg)("strong",{parentName:"p"},"valid IP address")," consists of exactly four integers separated by single dots. Each integer is between ",(0,r.yg)("inlineCode",{parentName:"p"},"0")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"255")," (",(0,r.yg)("strong",{parentName:"p"},"inclusive"),") and cannot have leading zeros."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"For example, ",(0,r.yg)("inlineCode",{parentName:"li"},'"0.1.2.201"')," and ",(0,r.yg)("inlineCode",{parentName:"li"},'"192.168.1.1"')," are ",(0,r.yg)("strong",{parentName:"li"},"valid")," IP addresses, but ",(0,r.yg)("inlineCode",{parentName:"li"},'"0.011.255.245"'),", ",(0,r.yg)("inlineCode",{parentName:"li"},'"192.168.1.312"')," and ",(0,r.yg)("inlineCode",{parentName:"li"},'"192.168@1.1"')," are ",(0,r.yg)("strong",{parentName:"li"},"invalid")," IP addresses.")),(0,r.yg)("p",null,"Given a string ",(0,r.yg)("inlineCode",{parentName:"p"},"s")," containing only digits, return ",(0,r.yg)("em",{parentName:"p"},"all possible valid IP addresses that can be formed by inserting dots into"),(0,r.yg)("inlineCode",{parentName:"p"},"s"),". You are ",(0,r.yg)("strong",{parentName:"p"},"not")," allowed to reorder or remove any digits in ",(0,r.yg)("inlineCode",{parentName:"p"},"s"),". You may return the valid IP addresses in ",(0,r.yg)("strong",{parentName:"p"},"any")," order."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 1:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},'Input: s = "25525511135"\nOutput: ["255.255.11.135","255.255.111.35"]\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 2:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},'Input: s = "0000"\nOutput: ["0.0.0.0"]\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 3:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},'Input: s = "101023"\nOutput: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Constraints:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"1 <= s.length <= 20")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"s")," consists of digits only.")),(0,r.yg)("h2",{id:"approach-1-iterative"},"Approach 1: Iterative"),(0,r.yg)(p,{mdxType:"Tabs"},(0,r.yg)(m,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.yg)(u,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},'// ideas:\n// A valid ip address would have 4 parts separated by dots\n// we iterate through `s` to insert 3 dots and separate the string into 4 segments\n// for each segment, we check if it is valid\n// if all 4 segments are valid, we combine those 4 segments with dots and push to the answer\n\nclass Solution {\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        vector<string> ans;\n        int n = s.size();\n        // iterate `s` - place 3 dots to have 4 segments\n        // [seg1].[seg2].[seg3].[seg4]\n        // 1st dot - we just need to run it 3 times at most\n        // e.g. for 255, we can place the first dot at `2.55`, `25.5` or `255.`\n        for (int i = 1; i < 4 && i < n; i++) {\n            // we place the 2nd dot in a similar way\n            for (int j = i + 1; j < i + 4 && j < n; j++) {\n                // we place the 3rd dot in a similar way\n                for (int k = j + 1; k < j + 4 && k < n; k++) {\n                    // now we can separate into 4 segments\n                    string seg1 = s.substr(0, i),\n                           seg2 = s.substr(i, j - i),\n                           seg3 = s.substr(j, k - j),\n                           seg4 = s.substr(k);\n                    // for each segment, check if it is valid\n                    if (ok(seg1) && ok(seg2) && ok(seg3) && ok(seg4)) {\n                        // if so, we build the ip address and push to answer\n                        ans.push_back(seg1 + "." + seg2 + "." + seg3 + "." + seg4);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n\n    // check if a given IP address segment is valid\n    // 192 -> true\n    // 312 -> false\n    bool ok(string s) {\n        // string length > 3 is not a valid IP address segment\n        if (s.size() > 3 ||\n            // empty segment is not valid\n            s.size() == 0 ||\n            // if the first character is 0, we cannot have something like 0x, 0xx\n            (s[0] == \'0\' && s.size() > 1) ||\n            // segment is out of range\n            stoi(s) > 255\n           ) {\n            return false;\n        }\n        return true;\n    }\n};\n\n'))),(0,r.yg)(m,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.yg)(u,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'\n// ideas:\n// A valid ip address would have 4 parts separated by dots\n// we iterate through `s` to insert 3 dots and separate the string into 4 segments\n// for each segment, we check if it is valid\n// if all 4 segments are valid, we combine those 4 segments with dots and push to the answer\nclass Solution {\n    public List<String> restoreIpAddresses(String s) {\n        List<String> ans = new ArrayList<>();\n        int n = s.length();\n        // iterate `s` - place 3 dots to have 4 segments\n        // [seg1].[seg2].[seg3].[seg4]\n        // 1st dot - we just need to run it 3 times at most\n        // e.g. for 255, we can place the first dot at `2.55`, `25.5` or `255.`\n        for (int i = 1; i < 4 && i < n; i++) {\n            // we place the 2nd dot in a similar way\n            for (int j = i + 1; j < i + 4 && j < n; j++) {\n                // we place the 3rd dot in a similar way\n                for (int k = j + 1; k < j + 4 && k < n; k++) {\n                    // now we can separate into 4 segments\n                    String seg1 = s.substring(0, i),\n                           seg2 = s.substring(i, j),\n                           seg3 = s.substring(j, k),\n                           seg4 = s.substring(k);\n                    // for each segment, check if it is valid\n                    if (ok(seg1) && ok(seg2) && ok(seg3) && ok(seg4)) {\n                        // if so, we build the ip address and push to answer\n                        ans.add(seg1 + "." + seg2 + "." + seg3 + "." + seg4);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n\n    // check if a given IP address segment is valid\n    // 192 -> true\n    // 312 -> false\n    private boolean ok(String s) {\n        // string length > 3 is not a valid IP address segment\n        if (s.length() > 3 ||\n            // empty segment is not valid\n            s.length() == 0 ||\n            // if the first character is 0, we cannot have something like 0x, 0xx\n            (s.charAt(0) == \'0\' && s.length() > 1) ||\n            // segment is out of range\n            Integer.parseInt(s) > 255\n           ) {\n            return false;\n        }\n        return true;\n    }\n}\n\n'))),(0,r.yg)(m,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.yg)(u,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-py"},'# ideas:\n# A valid ip address would have 4 parts separated by dots\n# we iterate through `s` to insert 3 dots and separate the string into 4 segments\n# for each segment, we check if it is valid\n# if all 4 segments are valid, we combine those 4 segments with dots and push to the answer\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        ans = []\n        n = len(s)\n\n        # check if a given IP address segment is valid\n        # 192 -> true\n        # 312 -> false\n        def ok(seg: str) -> bool:\n            # string length > 3 is not a valid IP address segment\n            # empty segment is not valid\n            # if the first character is 0, we cannot have something like 0x, 0xx\n            # segment is out of range\n            if len(seg) > 3 or len(seg) == 0 or (seg[0] == \'0\' and len(seg) > 1) or int(seg) > 255:\n                return False\n            return True\n\n        # iterate `s` - place 3 dots to have 4 segments\n        # [seg1].[seg2].[seg3].[seg4]\n        # 1st dot - we just need to run it 3 times at most\n        # e.g. for 255, we can place the first dot at `2.55`, `25.5` or `255.`\n        for i in range(1, 4):\n            # we place the 2nd dot in a similar way\n            for j in range(i + 1, i + 4):\n                # we place the 3rd dot in a similar way\n                for k in range(j + 1, j + 4):\n                    # now we can separate into 4 segments\n                    seg1, seg2, seg3, seg4 = s[:i], s[i:j], s[j:k], s[k:]\n                    # for each segment, check if it is valid\n                    if ok(seg1) and ok(seg2) and ok(seg3) and ok(seg4):\n                        # if so, we build the ip address and push to answer\n                        ans.append(seg1 + "." + seg2 + "." + seg3 + "." + seg4)\n        return ans\n\n'))),(0,r.yg)(m,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,r.yg)(u,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rs"},"// ideas:\n// A valid ip address would have 4 parts separated by dots\n// we iterate through `s` to insert 3 dots and separate the string into 4 segments\n// for each segment, we check if it is valid\n// if all 4 segments are valid, we combine those 4 segments with dots and push to the answer\n\nimpl Solution {\n    fn restore_ip_addresses(s: String) -> Vec<String> {\n        let mut ans = vec![];\n        let n = s.len();\n        // iterate `s` - place 3 dots to have 4 segments\n        // [seg1].[seg2].[seg3].[seg4]\n        // 1st dot - we just need to run it 3 times at most\n        // e.g. for 255, we can place the first dot at `2.55`, `25.5` or `255.`\n        for i in 1 .. 4 {\n            // we place the 2nd dot in a similar way\n            for j in i + 1 .. i + 4 {\n                // we place the 3rd dot in a similar way\n                for k in j + 1 .. j + 4 {\n                    if k < n {\n                        // now we can separate into 4 segments\n                        let seg1 = &s[..i];\n                        let seg2 = &s[i..j];\n                        let seg3 = &s[j..k];\n                        let seg4 = &s[k..];\n                        // for each segment, check if it is valid\n                        if Solution::ok(seg1) &&\n                           Solution::ok(seg2) &&\n                           Solution::ok(seg3) &&\n                           Solution::ok(seg4) {\n                            // if so, we build the ip address and push to answer\n                            ans.push(format!(\"{}.{}.{}.{}\", seg1, seg2, seg3, seg4));\n                        }\n                    }\n                }\n            }\n        }\n        ans\n    }\n\n    // check if a given IP address segment is valid\n    // 192 -> true\n    // 312 -> false\n    fn ok(seg: &str) -> bool {\n        seg.len() > 0 && seg.len() <= 3 && !(seg.starts_with('0') && seg.len() > 1) && seg.parse::<u32>().unwrap() <= 255\n    }\n}\n\n")))))}h.isMDXComponent=!0}}]);