"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[17365],{38560:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var i=t(85893),s=t(11151);const r={description:"Author: @wingkwong, @ganajayant, @radojicic23| https://leetcode.com/problems/swap-nodes-in-pairs/"},o="0024 - Swap Nodes in Pairs (Medium)",a={id:"0000-0099/swap-nodes-in-pairs-medium",title:"0024 - Swap Nodes in Pairs (Medium)",description:"Author: @wingkwong, @ganajayant, @radojicic23| https://leetcode.com/problems/swap-nodes-in-pairs/",source:"@site/solutions/0000-0099/0024-swap-nodes-in-pairs-medium.md",sourceDirName:"0000-0099",slug:"/0000-0099/swap-nodes-in-pairs-medium",permalink:"/solutions/0000-0099/swap-nodes-in-pairs-medium",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0000-0099/0024-swap-nodes-in-pairs-medium.md",tags:[],version:"current",sidebarPosition:24,frontMatter:{description:"Author: @wingkwong, @ganajayant, @radojicic23| https://leetcode.com/problems/swap-nodes-in-pairs/"},sidebar:"tutorialSidebar",previous:{title:"0023 - Merge k Sorted Lists (Hard)",permalink:"/solutions/0000-0099/merge-k-sorted-lists-hard"},next:{title:"0025 - Reverse Nodes in k-Group (Hard)",permalink:"/solutions/0000-0099/reverse-nodes-in-k-group-hard"}},d={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement:",id:"problem-statement",level:2},{value:"Approach 1: Recursive",id:"approach-1-recursive",level:2},{value:"Approach 2: Iterative",id:"approach-2-iterative",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components},{SolutionAuthor:t,TabItem:r,Tabs:o}=n;return t||u("SolutionAuthor",!0),r||u("TabItem",!0),o||u("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"0024---swap-nodes-in-pairs-medium",children:"0024 - Swap Nodes in Pairs (Medium)"}),"\n",(0,i.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/swap-nodes-in-pairs/",children:"https://leetcode.com/problems/swap-nodes-in-pairs/"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement:"}),"\n",(0,i.jsx)(n.p,{children:"Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg",alt:""})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: head = [1,2,3,4]\nOutput: [2,1,4,3]\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: head = []\nOutput: []\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: head = [1]\nOutput: [1]\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The number of nodes in the list is in the range ",(0,i.jsx)(n.code,{children:"[0, 100]"}),"."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"0 <= Node.val <= 10"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"approach-1-recursive",children:"Approach 1: Recursive"}),"\n",(0,i.jsx)(n.p,{children:"For each round, we just need to take care of two nodes to be swapped. The remaining nodes are passed to the next call. First, we check if we can take two nodes. If not, return head. Otherwise, take the first two nodes and process the following logic."}),"\n",(0,i.jsx)(n.p,{children:"Let's think of the second node first. If two nodes are swapped, the second node will link to the first node after swapping. Therefore, we can simply link the second node to the first node. After swapping, the first one will link to the all nodes linked by the original second node. We just need to call swapPairs again to handle it."}),"\n",(0,i.jsxs)(o,{children:[(0,i.jsxs)(r,{value:"cpp",label:"C++",children:[(0,i.jsx)(t,{name:"@wingkwong"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // check if it is possible to take two nodes\n        if (head == nullptr || head->next == nullptr) return head;\n        // take the first node\n        ListNode* f = head;\n        // take the second node\n        ListNode* s = head->next;\n        // the first node links to all nodes originally linked by the second node\n        f->next = swapPairs(s->next);\n        // the second node links to the first node\n        s->next = f;\n        // return head\n        return s;\n    }\n};\n"})})]}),(0,i.jsxs)(r,{value:"python",label:"Python",children:[(0,i.jsx)(t,{name:"@radojicic23"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        v1 = head\n        v2 = head.next\n        v3 = head.next.next\n        v2.next = v1\n        v1.next = self.swapPairs(v3)\n        return v2\n"})})]}),(0,i.jsxs)(r,{value:"js",label:"JavaScript",children:[(0,i.jsx)(t,{name:"@radojicic23"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  if (!head || !head.next) {\n    return head;\n  }\n  let v1 = head;\n  let v2 = head.next;\n  let v3 = head.next.next;\n  v2.next = v1;\n  v1.next = swapPairs(v3);\n  return v2;\n};\n"})})]})]}),"\n",(0,i.jsx)(n.h2,{id:"approach-2-iterative",children:"Approach 2: Iterative"}),"\n",(0,i.jsx)(n.p,{children:"See, we need to swap adjacent nodes right, So can we see that as a linked list in which we have to swap a linked list of length 2 and then after doing on that, we can move it further.\nExample:\n1->2->3->4\nAfter swapping first part or linked list of length 2, It would be\n2->1->3->4\nNow we need to go to 3->4 and do on the same on it and final answer would become\n2->1->4->3\nFor this new linked list of length 2, We maintain two variables currentnode and nextnode denoting first and last of that linked list.\nNow we need to think how would we connect those linked list of len 2, For this I maintained two variables previousnode which is helping to form this linked list."}),"\n",(0,i.jsxs)(o,{children:[(0,i.jsxs)(r,{value:"java",label:"Java",children:[(0,i.jsx)(t,{name:"@ganajayant"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode currentnode = head;\n        ListNode previousnode = null;\n\n        while (currentnode != null && currentnode.next != null) {\n            ListNode nextnode = currentnode.next;\n            if (previousnode == null) {\n                currentnode.next = nextnode.next;\n                nextnode.next = currentnode;\n                head = nextnode;\n            } else {\n                currentnode.next = nextnode.next;\n                previousnode.next = nextnode;\n                nextnode.next = currentnode;\n            }\n\n            previousnode = currentnode;\n            currentnode = currentnode.next;\n        }\n\n        return head;\n    }\n}\n"})})]}),(0,i.jsxs)(r,{value:"python",label:"Python",children:[(0,i.jsx)(t,{name:"@radojicic23"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # initialize dummy node (dummy -> head)\n        dummy = ListNode(0, next=head)\n        prev, curr = dummy, head\n\n        while curr and curr.next:\n            # save pointers\n            nxtPair = curr.next.next\n            second = curr.next\n            # reverse this pair\n            second.next = curr\n            curr.next = nxtPair\n            prev.next = second\n            # update pointers\n            prev = curr\n            curr = nxtPair\n        return dummy.next\n"})})]}),(0,i.jsxs)(r,{value:"js",label:"JavaScript",children:[(0,i.jsx)(t,{name:"@radojicic23"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  // initialize dummy node (dummy -> head)\n  const dummy = new ListNode(-1);\n  dummy.next = head;\n  let curr = head;\n  let prev = dummy;\n  while (curr && curr.next) {\n    // save pointers\n    let nxt_pair = curr.next.next;\n    let second = curr.next;\n    // reverse this pair\n    second.next = curr;\n    curr.next = nxt_pair;\n    prev.next = second;\n    // update pointers\n    prev = curr;\n    curr = nxt_pair;\n  }\n  return dummy.next;\n};\n"})})]}),(0,i.jsxs)(r,{value:"cpp",label:"C++",children:[(0,i.jsx)(t,{name:"@radojicic23"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // initialize dummy node (dummy -> head)\n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        auto prev = dummy, curr = head;\n        while (curr && curr->next) {\n            // initialize pointers\n            auto second = curr->next;\n            auto nxtPair = curr->next->next;\n            // swap this pair \n            second->next = curr;\n            curr->next = nxtPair;\n            prev->next = second;\n            // update pointers\n            prev = curr ;\n            curr = nxtPair;\n        }\n        return dummy->next;\n    }\n};\n"})})]})]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var i=t(67294);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);