"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[54320],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return c}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var m=r.createContext({}),l=function(e){var n=r.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=l(e.components);return r.createElement(m.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,m=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=l(t),c=a,d=h["".concat(m,".").concat(c)]||h[c]||p[c]||i;return t?r.createElement(d,o(o({ref:n},u),{},{components:t})):r.createElement(d,o({ref:n},u))}));function c(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=h;var s={};for(var m in n)hasOwnProperty.call(n,m)&&(s[m]=n[m]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=t[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},3948:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return m},default:function(){return y},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return p}});var r=t(87462),a=t(63366),i=(t(67294),t(3905)),o=["components"],s={description:"Author: @wingkwong | https://leetcode.com/problems/maximum-length-of-repeated-subarray/",tags:["Array","Binary Search","Dynamic Programming","Sliding Window","Rolling Hash","Hash Function"]},m="0718 - Maximum Length of Repeated Subarray (Medium)",l={unversionedId:"0700-0799/maximum-length-of-repeated-subarray-medium",id:"0700-0799/maximum-length-of-repeated-subarray-medium",title:"0718 - Maximum Length of Repeated Subarray (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/maximum-length-of-repeated-subarray/",source:"@site/solutions/0700-0799/0718-maximum-length-of-repeated-subarray-medium.md",sourceDirName:"0700-0799",slug:"/0700-0799/maximum-length-of-repeated-subarray-medium",permalink:"/solutions/0700-0799/maximum-length-of-repeated-subarray-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0700-0799/0718-maximum-length-of-repeated-subarray-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Binary Search",permalink:"/solutions/tags/binary-search"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{label:"Sliding Window",permalink:"/solutions/tags/sliding-window"},{label:"Rolling Hash",permalink:"/solutions/tags/rolling-hash"},{label:"Hash Function",permalink:"/solutions/tags/hash-function"}],version:"current",sidebarPosition:718,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/maximum-length-of-repeated-subarray/",tags:["Array","Binary Search","Dynamic Programming","Sliding Window","Rolling Hash","Hash Function"]},sidebar:"tutorialSidebar",previous:{title:"0706 - Design HashMap (Medium)",permalink:"/solutions/0700-0799/design-hashmap-medium"},next:{title:"0724 - Find Pivot Index (Easy)",permalink:"/solutions/0700-0799/find-pivot-index-easy"}},u={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dynamic Programming",id:"approach-1-dynamic-programming",level:2},{value:"Approach 2: Binary Search",id:"approach-2-binary-search",level:2}],h=function(e){return function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",n)}},c=h("Tabs"),d=h("TabItem"),g=h("SolutionAuthor"),f={toc:p};function y(e){var n=e.components,t=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0718---maximum-length-of-repeated-subarray-medium"},"0718 - Maximum Length of Repeated Subarray (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/maximum-length-of-repeated-subarray/"},"https://leetcode.com/problems/maximum-length-of-repeated-subarray/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Given two integer arrays ",(0,i.kt)("inlineCode",{parentName:"p"},"nums1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"nums2"),", return ",(0,i.kt)("em",{parentName:"p"},"the maximum length of a subarray that appears in ",(0,i.kt)("strong",{parentName:"em"},"both")," arrays"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\nOutput: 3\nExplanation: The repeated subarray with maximum length is [3,2,1].\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\nOutput: 5\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= nums1.length, nums2.length <= 1000")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0 <= nums1[i], nums2[i] <= 100"))),(0,i.kt)("h2",{id:"approach-1-dynamic-programming"},"Approach 1: Dynamic Programming"),(0,i.kt)(c,{mdxType:"Tabs"},(0,i.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(g,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    // DP Approach - Similar to 1143. Longest Common Subsequence\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size(), m = nums2.size(), ans = 0;\n        // dp[i][j] means the length of repeated subarray of nums1[:i] and nums2[:j]\n        // initially the first row (i = 0) and the first col (j = 0) would be zero\n        // dp[i][0] = 0 for all i and dp[0][j] = 0 for all j\n        // if you use int dp[n + 1][m + 1], then you need to take care of this part\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                // if both character is same\n                if (nums1[i - 1] == nums2[j - 1]) {\n                    // then we add 1 to the previous state, which is dp[i - 1][j - 1]\n                    // in other word, we extend the repeated subarray by 1\n                    // e.g. a = [1], b = [1], length of repeated array is 1\n                    //      a = [1,2], b = [1,2], length of repeated array is the previous result + 1 = 2\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                    // record the max ans here\n                    ans = max(ans, dp[i][j]);\n                } else {\n                    // if you are looking for longest common sequence,\n                    // then you put dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); here\n                    // however, this problem is looking for subarray,\n                    // since both character is not equal, which means we need to break it here\n                    // hence, set dp[i][j] to 0\n                    // since we use vector<vector<int>> dp instead of int dp[n + 1][m + 1]\n                    // this part can be skipped as it is already 0\n                }\n            }\n        }\n        return ans;\n    }\n};\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    // DP Approach - Space Optimized\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size(), m = nums2.size(), ans = 0;\n        // swap it to ensure n > m\n        if (n < m) {\n            // or you can call findLength(nums2, nums1); \n            swap(nums1, nums2);\n            swap(n, m);\n        }\n        // dp records current dp state\n        // dp2 records the previous dp state\n        vector<int> dp(n + 1), dp2(n + 1);\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (nums1[i - 1] == nums2[j - 1]) {\n                    // extend from the previous dp state\n                    dp[j] = dp2[j - 1] + 1; \n                } else {\n                    // reset to 0\n                    dp[j] = 0;\n                }\n                // record the max length\n                ans = max(ans, dp[j]);\n            }\n            // the current state now becomes the previous state for next round\n            dp2 = dp;\n        }\n        return ans;\n    }\n};\n"))),(0,i.kt)(d,{value:"py",label:"Python",mdxType:"TabItem"},(0,i.kt)(g,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    # DP Approach - Similar to 1143. Longest Common Subsequence\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n, m = len(nums1), len(nums2)\n        # dp[i][j] means the length of repeated subarray of nums1[:i] and nums2[:j]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        ans = 0\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                # if both character is same\n                if nums1[i - 1] == nums2[j - 1]:\n                    # then we add 1 to the previous state, which is dp[i - 1][j - 1]\n                    # in other word, we extend the repeated subarray by 1\n                    # e.g. a = [1], b = [1], length of repeated array is 1\n                    #      a = [1,2], b = [1,2], length of repeated array is the previous result + 1 = 2\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    # record the max ans here\n                    ans = max(ans, dp[i][j])\n                # else:\n                    # if you are looking for longest common sequence,\n                    # then you put dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); here\n                    # however, this problem is looking for subarray,\n                    # since both character is not equal, which means we need to break it here\n                    # hence, set dp[i][j] to 0\n        return ans\n")))),(0,i.kt)("h2",{id:"approach-2-binary-search"},"Approach 2: Binary Search"),(0,i.kt)(c,{mdxType:"Tabs"},(0,i.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(g,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Binary Search + Rolling Hash Approach\nclass Solution {\npublic:\n    // the idea is to use binary search to find the length `m`\n    // then we check if there is any nums1[i : i + m] == nums2[i : i + m]\n    // for c++, it may get TLE. so we can use rolling hash to speed up\n    // we can see `nums1[i : j]` as a hash, then we insert all the possible hashes to a set\n    // then we do the same on `nums2` to see if the hash exists in the set\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n        int N = nums1.size(), M = nums2.size();\n        // build hashes for nums1\n        PolyHash H1 = PolyHash(nums1);\n        // build hashes for nums2\n        PolyHash H2 = PolyHash(nums2);\n        \n        int l = 0, r = min(N, M);\n        // binary search\n        while (l < r) {\n            // guess that the length is m\n            int m = l + (r - l + 1) / 2, ok = 0;\n            // use set to store all the possible hashes\n            set<int> s;\n            // for each subarray, we get the hash and store in set\n            for (int i = 0; i < N - m + 1; i++) {\n                s.insert(H1.get_hash(i, i + m - 1));\n            }\n            // see if we can get the same hash\n            for (int i = 0; i < M - m + 1; i++) {\n                if (s.find(H2.get_hash(i, i + m - 1)) != s.end()) {\n                    ok = 1;\n                    break;\n                }\n            }\n            // include m\n            if (ok) l = m;\n            // exclude m\n            else r = m - 1;\n        }\n        return l;\n    }\n};\n"))),(0,i.kt)(d,{value:"py",label:"Python",mdxType:"TabItem"},(0,i.kt)(g,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    # Binary Search Approach\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\n        N, M = len(nums1), len(nums2)\n        \n        def ok(k):\n            # the idea is to use binary search to find the length `k`\n            # then we check if there is any nums1[i : i + k] == nums2[i : i + k]\n            s = set(tuple(nums1[i : i + k]) for i in range(N - k + 1))\n            return any(tuple(nums2[i : i + k]) in s for i in range(M - k + 1))\n        \n        # init possible boundary\n        l, r = 0, min(N, M)\n        while l < r:\n            # get the middle one\n            # for even number of elements, take the upper one\n            m = (l + r + 1) // 2\n            if ok(m): \n                # include m\n                l = m\n            else:\n                # exclude m\n                r = m - 1\n        return l\n")))))}y.isMDXComponent=!0}}]);