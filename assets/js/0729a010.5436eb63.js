"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[34556],{35280:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var i=n(85893),s=n(11151);const r={description:"Author: @wingkwong | https://leetcode.com/problems/find-duplicate-file-in-system/",tags:["Array","Hash Table","String"]},o="0609 - Find Duplicate File in System (Medium)",l={id:"0600-0699/find-duplicate-file-in-system-medium",title:"0609 - Find Duplicate File in System (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/find-duplicate-file-in-system/",source:"@site/solutions/0600-0699/0609-find-duplicate-file-in-system-medium.md",sourceDirName:"0600-0699",slug:"/0600-0699/find-duplicate-file-in-system-medium",permalink:"/solutions/0600-0699/find-duplicate-file-in-system-medium",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0600-0699/0609-find-duplicate-file-in-system-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Hash Table",permalink:"/solutions/tags/hash-table"},{label:"String",permalink:"/solutions/tags/string"}],version:"current",sidebarPosition:609,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/find-duplicate-file-in-system/",tags:["Array","Hash Table","String"]},sidebar:"tutorialSidebar",previous:{title:"0606 - Construct String from Binary Tree (Easy)",permalink:"/solutions/0600-0699/construct-string-from-binary-tree-easy"},next:{title:"0621 - Task Scheduler (Medium)",permalink:"/solutions/0600-0699/task-scheduler-medium"}},a={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: HashMap",id:"approach-1-hashmap",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components},{SolutionAuthor:n,TabItem:r,Tabs:o}=t;return n||p("SolutionAuthor",!0),r||p("TabItem",!0),o||p("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"0609---find-duplicate-file-in-system-medium",children:"0609 - Find Duplicate File in System (Medium)"}),"\n",(0,i.jsx)(t.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://leetcode.com/problems/find-duplicate-file-in-system/",children:"https://leetcode.com/problems/find-duplicate-file-in-system/"})}),"\n",(0,i.jsx)(t.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(t.p,{children:["Given a list ",(0,i.jsx)(t.code,{children:"paths"})," of directory info, including the directory path, and all the files with contents in this directory, return ",(0,i.jsx)(t.em,{children:"all the duplicate files in the file system in terms of their paths"}),". You may return the answer in ",(0,i.jsx)(t.strong,{children:"any order"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"A group of duplicate files consists of at least two files that have the same content."}),"\n",(0,i.jsx)(t.p,{children:"A single directory info string in the input list has the following format:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:'"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"'})}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["It means there are ",(0,i.jsx)(t.code,{children:"n"})," files ",(0,i.jsx)(t.code,{children:"(f1.txt, f2.txt ... fn.txt)"})," with content ",(0,i.jsx)(t.code,{children:"(f1_content, f2_content ... fn_content)"}),' respectively in the directory "',(0,i.jsx)(t.code,{children:'root/d1/d2/.../dm"'}),". Note that ",(0,i.jsx)(t.code,{children:"n >= 1"})," and ",(0,i.jsx)(t.code,{children:"m >= 0"}),". If ",(0,i.jsx)(t.code,{children:"m = 0"}),", it means the directory is just the root directory."]}),"\n",(0,i.jsx)(t.p,{children:"The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:'"directory_path/file_name.txt"'})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)","root 4.txt(efgh)"]\nOutput: [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]\n'})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)"]\nOutput: [["root/a/2.txt","root/c/d/4.txt"],["root/a/1.txt","root/c/3.txt"]]\n'})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"1 <= paths.length <= 2 * 10^4"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"1 <= paths[i].length <= 3000"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"1 <= sum(paths[i].length) <= 5 * 105"})}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"paths[i]"})," consist of English letters, digits, ",(0,i.jsx)(t.code,{children:"'/'"}),", ",(0,i.jsx)(t.code,{children:"'.'"}),", ",(0,i.jsx)(t.code,{children:"'('"}),", ",(0,i.jsx)(t.code,{children:"')'"}),", and ",(0,i.jsx)(t.code,{children:"' '"}),"."]}),"\n",(0,i.jsx)(t.li,{children:"You may assume no files or directories share the same name in the same directory."}),"\n",(0,i.jsx)(t.li,{children:"You may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Follow up:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Imagine you are given a real file system, how will you search files? DFS or BFS?"}),"\n",(0,i.jsx)(t.li,{children:"If the file content is very large (GB level), how will you modify your solution?"}),"\n",(0,i.jsx)(t.li,{children:"If you can only read the file by 1kb each time, how will you modify your solution?"}),"\n",(0,i.jsx)(t.li,{children:"What is the time complexity of your modified solution? What is the most time-consuming part and memory-consuming part of it? How to optimize?"}),"\n",(0,i.jsx)(t.li,{children:"How to make sure the duplicated files you find are not false positive?"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"approach-1-hashmap",children:"Approach 1: HashMap"}),"\n",(0,i.jsxs)(o,{children:[(0,i.jsxs)(r,{value:"cpp",label:"C++",children:[(0,i.jsx)(n,{name:"@wingkwong"}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'class Solution {\npublic:\n    // custom split template\n    vector<string> split(string str, char delim) {\n        string line;\n        vector<string> res;\n        stringstream ss(str);\n        while (getline(ss, line, delim)) res.push_back(line);\n        return res;\n    }\n    \n    // steps\n    // 1. for each path, split by the \' \', then get the directory path, file name and file content\n    // 2. combine the directory path and file name\n    // 3. group directoryPath/fileName by file content using hash map\n    // 4. build the final ans \n    vector<vector<string>> findDuplicate(vector<string>& paths) {\n        vector<vector<string>> ans;\n        unordered_map<string, vector<string>> m;\n        for (auto p : paths) {\n            vector<string> path = split(p, \' \');\n            string directoryPath;\n            for (int i = 0; i < path.size(); i++) {\n                if (i == 0) {\n                    directoryPath = path[i];\n                } else {\n                    // e.g. 1.txt\n                    string fileName = path[i].substr(0, path[i].find(\'(\'));\n                    // e.g. abcd\n                    string fileContent =  path[i].substr(path[i].find(\'(\') + 1, path[i].find(\')\') - path[i].find(\'(\') - 1);\n                    // e.g. efgh: ["root/a/2.txt","root/c/d/4.txt","root/4.txt"]\n                    m[fileContent].push_back(directoryPath + "/" + fileName);\n                }\n            }\n        }\n        // build the final answer\n        for (auto x : m) {\n            // check if there is duplicate\n            // e.g. ["root/a 1.txt(abcd) 2.txt(efsfgh)","root/c 3.txt(abdfcd)","root/c/d 4.txt(efggdfh)"]\n            if (x.second.size() > 1) {\n                // x.second is already the full list of paths\n                ans.push_back(x.second);    \n            }\n        }\n        return ans;\n    }\n};\n'})})]}),(0,i.jsxs)(r,{value:"python",label:"Python",children:[(0,i.jsx)(n,{name:"@wingkwong"}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-py",children:"class Solution:\n    def findDuplicate(self, paths: List[str]) -> List[List[str]]:\n        m = defaultdict(list)\n        for p in paths:\n            # 1. split the string by ' '\n            path = p.split()\n            # the first string is the directory path\n            # the rest of them are just file names with content\n            directoryPath, rest = path[0], path[1:]\n            # for each file names with content\n            for f in rest:\n                # we retrieve the file name and the file content\n                fileName, fileContent = f.split('(')[0], f.split('(')[1][:-1]\n                # then group {directoryPath}/{fileName} by file content\n                m[fileContent].append(\"{}/{}\".format(directoryPath, fileName))\n        # return the file list only when the size is greater than 1, meaning they are duplicate files\n        return [m[k] for k in m.keys() if len(m[k]) > 1]\n"})})]})]})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function p(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(e,t,n)=>{n.d(t,{Z:()=>l,a:()=>o});var i=n(67294);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);