"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[5495],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return p}});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),x=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=x(e.components);return i.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=x(n),p=a,f=m["".concat(l,".").concat(p)]||m[p]||u[p]||r;return n?i.createElement(f,o(o({ref:t},c),{},{components:n})):i.createElement(f,o({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var x=2;x<r;x++)o[x]=n[x];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},94904:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return b},frontMatter:function(){return s},metadata:function(){return x},toc:function(){return u}});var i=n(87462),a=n(63366),r=(n(67294),n(3905)),o=["components"],s={description:"Author: @wingkwong | https://leetcode.com/problems/utf-8-validation/",tags:["Array","Bit Manipulation"]},l="0393 - UTF-8 Validation (Medium)",x={unversionedId:"0300-0399/utf-8-validation-medium",id:"0300-0399/utf-8-validation-medium",title:"0393 - UTF-8 Validation (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/utf-8-validation/",source:"@site/solutions/0300-0399/0393-utf-8-validation-medium.md",sourceDirName:"0300-0399",slug:"/0300-0399/utf-8-validation-medium",permalink:"/leetcode-the-hard-way/solutions/0300-0399/utf-8-validation-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0300-0399/0393-utf-8-validation-medium.md",tags:[{label:"Array",permalink:"/leetcode-the-hard-way/solutions/tags/array"},{label:"Bit Manipulation",permalink:"/leetcode-the-hard-way/solutions/tags/bit-manipulation"}],version:"current",sidebarPosition:393,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/utf-8-validation/",tags:["Array","Bit Manipulation"]},sidebar:"tutorialSidebar",previous:{title:"0392 - Is Subsequence (Easy)",permalink:"/leetcode-the-hard-way/solutions/0300-0399/is-subsequence-easy"},next:{title:"0400 - 0499",permalink:"/leetcode-the-hard-way/solutions/category/0400---0499"}},c={},u=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Bit Manipulation",id:"approach-1-bit-manipulation",level:2}],m=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)}},p=m("Tabs"),f=m("TabItem"),d=m("SolutionAuthor"),h={toc:u};function b(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"0393---utf-8-validation-medium"},"0393 - UTF-8 Validation (Medium)"),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"Given an integer array ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," representing the data, return whether it is a valid ",(0,r.kt)("strong",{parentName:"p"},"UTF-8")," encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters)."),(0,r.kt)("p",null,"A character in ",(0,r.kt)("strong",{parentName:"p"},"UTF8")," can be from ",(0,r.kt)("strong",{parentName:"p"},"1 to 4 bytes")," long, subjected to the following rules:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"For a ",(0,r.kt)("strong",{parentName:"li"},"1-byte")," character, the first bit is a ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),", followed by its Unicode code."),(0,r.kt)("li",{parentName:"ol"},"For an ",(0,r.kt)("strong",{parentName:"li"},"n-bytes")," character, the first ",(0,r.kt)("inlineCode",{parentName:"li"},"n")," bits are all one's, the ",(0,r.kt)("inlineCode",{parentName:"li"},"n + 1")," bit is ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),", followed by ",(0,r.kt)("inlineCode",{parentName:"li"},"n - 1")," bytes with the most significant ",(0,r.kt)("inlineCode",{parentName:"li"},"2")," bits being ",(0,r.kt)("inlineCode",{parentName:"li"},"10"),".")),(0,r.kt)("p",null,"This is how the UTF-8 encoding would work:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Number of Bytes   |        UTF-8 Octet Sequence\n                       |              (binary)\n   --------------------+-----------------------------------------\n            1          |   0xxxxxxx\n            2          |   110xxxxx 10xxxxxx\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"x")," denotes a bit in the binary form of a byte that may be either ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note:"),"The input is an array of integers. Only the ",(0,r.kt)("strong",{parentName:"p"},"least significant 8 bits")," of each integer is used to store the data. This means each integer represents only 1 byte of data."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: data = [197,130,1]\nOutput: true\nExplanation: data represents the octet sequence: 11000101 10000010 00000001.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: data = [235,140,4]\nOutput: false\nExplanation: data represented the octet sequence: 11101011 10001100 00000100.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= data.length <= 2 * 10^4")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"0 <= data[i] <= 255"))),(0,r.kt)("h2",{id:"approach-1-bit-manipulation"},"Approach 1: Bit Manipulation"),(0,r.kt)(p,{mdxType:"Tabs"},(0,r.kt)(f,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Time Complexity : O(N) where N is the number of elements in data\n// Space Complexity: O(1) \nclass Solution {\npublic:\n    // the idea is to keep track the number of segments of utf-8 octet sequence left\n    // we increase / decrease the count based on some cases\n    // first you need to know that `x >> n` means shift the number `x` `n` bits to the right\n    // e.g. shift 110xxxxx 5 bits to the right becomes 110 (in binary format)\n    // e.g. shift 11110xxx 4 bits to the right becomes 1111 (in binary format)\n    // second, 0bxxxx is a binary literal which means xxxx is a binary number\n    // alternatively, you can use decimal format but it's not that convenient in this problem\n    // e.g. 0b1110 -> 14\n    // e.g. 0b11000000 -> 192\n    bool validUtf8(vector<int>& data) {\n        // used to track the remaining number of segments\n        int remaining = 0;\n        // iterate each data and perform the following logic\n        for (auto& x : data) {\n            // case 1: there is no remaining segement left, \n            // then it means we should check the first segement of UTF-8 octet sequence\n            // i.e. 0xxxxxxx (for no of. bytes = 1)\n            // i.e. 110xxxxx (for no of. bytes = 2)\n            // i.e. 1110xxxx (for no of. bytes = 3)\n            // i.e. 11110xxx (for no of. bytes = 4)\n            if (remaining == 0) {\n                if ((x >> 5) == 0b110) {\n                    // case 1.1 - shift `x` 5 bits to the right\n                    // i.e making the first (8 - 5) = 3 bits left\n                    // e.g (110xxxxx >> 5) becomes 110 (in binary format)\n                    // if it is 0b110, \n                    // then it is only possible to form `110xxxxx 10xxxxxx` \n                    // so we set remaining to 1 to look for `10xxxxxx` later\n                    remaining = 1;\n                } else if ((x >> 4) == 0b1110) {\n                    // case 1.2 -  shift `x` 4 bits to the right\n                    // i.e making the first (8 - 4) = 4 bits left\n                    // e.g (1110xxxx >> 4) becomes 1110 (in binary format)\n                    // if it is 0b1110, \n                    // then it is only possible to form `1110xxxx 10xxxxxx 10xxxxxx`\n                    // so we set remaining to 2 to look for `10xxxxxx 10xxxxxx` later\n                     remaining = 2;\n                } else if ((x >> 3) == 0b11110) {\n                    // case 1.3 -  shift `x` 3 bits to the right\n                    // i.e making the first (8 - 3) = 5 bits left\n                    // e.g (11110xxx >> 5) becomes 11110 (in binary format)\n                    // if it is 0b11110, \n                    // then it is only possible to form `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`\n                    // so we set remaining to 3 to look for `10xxxxxx 10xxxxxx 10xxxxxx` later\n                    remaining = 3;\n                } else if ((x >> 7) != 0) {\n                     // case 1.4 -  shift `x` 7 bits to the right\n                    // i.e making the first (8 - 7) = 1 bit left\n                    // e.g (0xxxxxxx >> 7) becomes 0 (in binary format)\n                    // here we cover the last case which is when Number of Bytes = 1\n                    // we need to make sure the first bit is 0\n                    // otherwise, it is not valid\n                    return false;\n                }\n            } else {\n                // case 2: check 10xxxxxx\n                // if we enter this part, that means it may be number of bytes 2, 3, or 4.\n                // based on the table in problem statement, we know what's left is just `10xxxxxx`\n                // therefore, we shift `x` 6 bits to the right\n                // i.e making the first (8 - 6) = 2 bits left\n                // e.g (10xxxxxx >> 6) becomes 10 (in binary format)\n                // if the first 2 bits are not 10 (in binary format), then it is not valid\n                if ((x >> 6) != 0b10) return false;\n                // otherwise, this segement is ok so we decrease `remaining` by 1\n                else remaining--;\n            }\n        }\n        // at the end, remaining will be 0 if data can represent the octet sequence \n        return remaining == 0;\n    }\n};\n")))))}b.isMDXComponent=!0}}]);