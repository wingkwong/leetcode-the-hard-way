"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[61123],{99422:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"1600-1699/arithmetic-subarrays-medium","title":"1630 - Arithmetic Subarrays (Medium)","description":"Author: @jit, @martin0327, @heder | https://leetcode.com/problems/arithmetic-subarrays/","source":"@site/solutions/1600-1699/1630-arithmetic-subarrays-medium.md","sourceDirName":"1600-1699","slug":"/1600-1699/arithmetic-subarrays-medium","permalink":"/solutions/1600-1699/arithmetic-subarrays-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1600-1699/1630-arithmetic-subarrays-medium.md","tags":[{"inline":true,"label":"Array","permalink":"/solutions/tags/array"},{"inline":true,"label":"Sorting","permalink":"/solutions/tags/sorting"}],"version":"current","sidebarPosition":1630,"frontMatter":{"description":"Author: @jit, @martin0327, @heder | https://leetcode.com/problems/arithmetic-subarrays/","tags":["Array","Sorting"]},"sidebar":"tutorialSidebar","previous":{"title":"1626 - Best Team With No Conflicts (Medium)","permalink":"/solutions/1600-1699/best-team-with-no-conflicts-medium"},"next":{"title":"1631 - Path With Minimum Effort (Medium)","permalink":"/solutions/1600-1699/path-with-minimum-effort-medium"}}');var t=i(74848),s=i(28453);const l={description:"Author: @jit, @martin0327, @heder | https://leetcode.com/problems/arithmetic-subarrays/",tags:["Array","Sorting"]},a="1630 - Arithmetic Subarrays (Medium)",c={},o=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Brute Force",id:"approach-1-brute-force",level:2},{value:"Approach 2: Mo&#39;s Algorithm",id:"approach-2-mos-algorithm",level:2},{value:"Approach 3: RMQ",id:"approach-3-rmq",level:2}];function d(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components},{SolutionAuthor:i,TabItem:r,Tabs:l}=e;return i||h("SolutionAuthor",!0),r||h("TabItem",!0),l||h("Tabs",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"1630---arithmetic-subarrays-medium",children:"1630 - Arithmetic Subarrays (Medium)"})}),"\n",(0,t.jsx)(e.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"https://leetcode.com/problems/arithmetic-subarrays/",children:"https://leetcode.com/problems/arithmetic-subarrays/"})}),"\n",(0,t.jsx)(e.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,t.jsxs)(e.p,{children:["A sequence of numbers is called ",(0,t.jsx)(e.strong,{children:"arithmetic"})," if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence ",(0,t.jsx)(e.code,{children:"s"})," is arithmetic if and only if ",(0,t.jsx)(e.code,{children:"s[i+1] - s[i] == s[1] - s[0]"}),"for all valid ",(0,t.jsx)(e.code,{children:"i"}),"."]}),"\n",(0,t.jsxs)(e.p,{children:["For example, these are ",(0,t.jsx)(e.strong,{children:"arithmetic"})," sequences:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\n"})}),"\n",(0,t.jsxs)(e.p,{children:["The following sequence is not ",(0,t.jsx)(e.strong,{children:"arithmetic"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"1, 1, 2, 5, 7\n"})}),"\n",(0,t.jsxs)(e.p,{children:["You are given an array of ",(0,t.jsx)(e.code,{children:"n"})," integers, ",(0,t.jsx)(e.code,{children:"nums"}),", and two arrays of ",(0,t.jsx)(e.code,{children:"m"})," integers each, ",(0,t.jsx)(e.code,{children:"l"})," and ",(0,t.jsx)(e.code,{children:"r"}),", representing the ",(0,t.jsx)(e.code,{children:"m"})," range queries, where the ",(0,t.jsx)(e.code,{children:"ith"})," query is the range ",(0,t.jsx)(e.code,{children:"[l[i], r[i]]"}),". All the arrays are ",(0,t.jsx)(e.strong,{children:"0-indexed"}),"."]}),"\n",(0,t.jsxs)(e.p,{children:["Return ",(0,t.jsx)(e.em,{children:"a list of"}),(0,t.jsx)(e.code,{children:"boolean"})," ",(0,t.jsx)(e.em,{children:"elements"})," ",(0,t.jsx)(e.code,{children:"answer"}),(0,t.jsx)(e.em,{children:", where"})," ",(0,t.jsx)(e.code,{children:"answer[i]"})," ",(0,t.jsx)(e.em,{children:"is"})," ",(0,t.jsx)(e.code,{children:"true"})," ",(0,t.jsx)(e.em,{children:"if the subarray"})," ",(0,t.jsx)(e.code,{children:"nums[l[i]], nums[l[i]+1], ... , nums[r[i]]"}),(0,t.jsxs)(e.em,{children:["can be ",(0,t.jsx)(e.strong,{children:"rearranged"})," to form an ",(0,t.jsx)(e.strong,{children:"arithmetic"})," sequence, and"]})," ",(0,t.jsx)(e.code,{children:"false"})," ",(0,t.jsx)(e.em,{children:"otherwise."})]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example 1:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]\nOutput: [true,false,true]\nExplanation:\nIn the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.\nIn the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.\nIn the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example 2:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]\nOutput: [false,true,false,false,true,true]\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Constraints:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:"n == nums.length"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:"m == l.length"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:"m == r.length"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:"2 <= n <= 500"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:"1 <= m <= 500"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:"0 <= l[i] < r[i] < n"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:"-10 ^ 5 <= nums[i] <= 10 ^ 5"})}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"approach-1-brute-force",children:"Approach 1: Brute Force"}),"\n",(0,t.jsx)(l,{children:(0,t.jsxs)(r,{value:"elixir",label:"Elixir",children:[(0,t.jsx)(i,{name:"@jit"}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-elixir",children:"@spec check_arithmetic_subarrays(nums :: [integer], l :: [integer], r :: [integer]) :: [boolean]\n# A fairly naive solution:\ndef check_arithmetic_subarrays(nums, l, r) do\n  Enum.zip_with(l, r, fn ll, rr ->\n    nums |> Enum.slice(ll..rr) |> Enum.sort() |> is_arith?()\n  end)\nend\n\ndefp is_arith?([a | [b | rest] = tl]) do\n  diff = a - b\n  Enum.zip_with(tl, rest, &-/2) |> Enum.all?(&(&1 == diff))\nend\n  \ndefp is_arith?(_), do: true\n"})})]})}),"\n",(0,t.jsx)(e.h2,{id:"approach-2-mos-algorithm",children:"Approach 2: Mo's Algorithm"}),"\n",(0,t.jsx)(l,{children:(0,t.jsxs)(r,{value:"cpp",label:"C++",children:[(0,t.jsx)(i,{name:"@martin0327"}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"using ti3 = tuple<int,int,int>;\nconst int inf = 1e9;\n\nclass Solution {\npublic:\n    vector<bool> checkArithmeticSubarrays(vector<int>& a, vector<int>& ql, vector<int>& qr) {\n        int n = a.size(), q = ql.size(), sz = sqrt(n);\n        map<int,vector<ti3>> mo;\n        for (int i=0; i<q; i++) {\n            int l = ql[i], r = qr[i];\n            mo[l/sz].push_back({r,l,i});\n        }\n        \n        int i=0, j=0, mul = 0;\n        map<int,int> mp1, mp2;\n        mp1[a[0]]++;\n\n        auto inc1 = [&] (int x) { if (++mp1[x] == 2) mul++; };\n        auto dec1 = [&] (int x) {\n            if (mp1[x] == 2) mul--;\n            if (--mp1[x] == 0) mp1.erase(x);\n        }; \n        auto inc2 = [&] (int x) { mp2[x]++; };\n        auto dec2 = [&] (int x) { if (--mp2[x] == 0) mp2.erase(x); };\n        \n        auto lr = [&] (int x) {\n            auto it1 = mp1.lower_bound(x);\n            auto it2 = mp1.upper_bound(x);\n            int l = (it1 == mp1.begin()) ? inf : prev(it1)->first;\n            int r = (it2 == mp1.end()) ? inf : it2->first;\n            return make_pair(l,r);\n        };\n\n        auto push = [&] (int x) {\n            auto [l,r] = lr(x);\n            if (!mp1.count(x)) {\n                if (l != inf) inc2(x-l);\n                if (r != inf) inc2(r-x);\n                if (l != inf && r != inf) dec2(r-l);\n            }\n            inc1(x);\n        };\n\n        auto pop = [&] (int x) {\n            auto [l,r] = lr(x);\n            if (mp1[x] == 1) {\n                if (l != inf) dec2(x-l);\n                if (r != inf) dec2(r-x);\n                if (l != inf && r != inf) inc2(r-l);\n            }\n            dec1(x);\n        };\n        \n        vector<bool> ans(q);\n        for (auto &[_,rli] : mo) {\n            sort(rli.begin(), rli.end());\n            for (auto [r,l,idx] : rli) {\n                while (i!=l || j!=r) {\n                    if (r>j) push(a[++j]);\n                    else if (l<i) push(a[--i]);\n                    else if (r<j) pop(a[j--]);\n                    else if (l>i) pop(a[i++]);\n                }\n                if (mul+mp2.size()==1) ans[idx] = 1;\n            }\n        }\n        return ans;\n    }\n}; \n"})})]})}),"\n",(0,t.jsx)(e.h2,{id:"approach-3-rmq",children:"Approach 3: RMQ"}),"\n",(0,t.jsx)(l,{children:(0,t.jsxs)(r,{value:"cpp",label:"C++",children:[(0,t.jsx)(i,{name:"@heder"}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"static int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\n\n// Using sparse table, see https://www.youtube.com/watch?v=0jWeUdxrGm4\nclass RangeMinMaxQuery {\nprivate:\n    vector<vector<pair<int, int>>> m_;\n\npublic:\n    RangeMinMaxQuery(vector<int>& nums)\n        : m_(bin_log(size(nums)) + 1, vector<pair<int, int>>(size(nums))) {\n        transform(begin(nums), end(nums), begin(m_[0]),\n                  [](int x) { return make_pair(x, x); });\n        \n        for (int k = 1; k < size(m_); ++k) {\n            for (int i = 0; i + (1 << k) - 1 < size(nums); ++i) {\n                const auto& p1 = m_[k - 1][i];\n                const auto& p2 = m_[k - 1][i + (1 << (k - 1))];\n                m_[k][i] = make_pair(\n                    min(p1.first, p2.first),\n                    max(p1.second, p2.second));\n            }\n        }\n    }\n    \n    pair<int, int> query(int l, int r) {\n        const int len = r - l + 1;\n    \tconst int k = bin_log(len);\n        const auto& p1 = m_[k][l];\n        const auto& p2 = m_[k][r - (1 << k) + 1];\n\t    return make_pair(\n            min(p1.first, p2.first),\n            max(p1.second, p2.second));   \n    }\n\nprivate:\n    static constexpr int bin_log(int n) {\n        return 31 - __builtin_clz(n);\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& ls, vector<int>& rs) {\n        RangeMinMaxQuery rmq(nums);\n        \n        const int m = size(ls);\n        vector<bool> ans;\n        for (int i = 0; i < m; ++i) {\n            const int l = ls[i];\n            const int r = rs[i];\n            const int len = r - l + 1;\n            if (len <= 2) {\n                ans.push_back(true);\n                continue;\n            }\n            \n            const auto [mn, mx] = rmq.query(l, r);\n            const int d = (mx - mn) / (len - 1);\n            \n            if (mn == mx) {\n                ans.push_back(true);\n            } else if ((mx - mn) % (len -1)) {\n                ans.push_back(false);\n            } else {\n                bitset<512> seen;;\n                int j;\n                for (j = l; j <= r; ++j) {\n                    if ((nums[j] - mn) % d || seen[(nums[j] - mn) / d])\n                        break;\n                    seen[(nums[j] - mn) / d] = true;\n                }\n                ans.push_back(j > r);\n            }\n        }\n        return ans;\n    }\n};\n"})})]})})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}function h(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>a});var r=i(96540);const t={},s=r.createContext(t);function l(n){const e=r.useContext(s);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);