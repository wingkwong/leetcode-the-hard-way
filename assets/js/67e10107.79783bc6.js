"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[78594],{88909:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"0500-0599/subtree-of-another-tree-easy","title":"0572 - Subtree of Another Tree (Easy)","description":"Author: @vigneshshiv | https://leetcode.com/problems/subtree-of-another-tree/","source":"@site/solutions/0500-0599/0572-subtree-of-another-tree-easy.md","sourceDirName":"0500-0599","slug":"/0500-0599/subtree-of-another-tree-easy","permalink":"/solutions/0500-0599/subtree-of-another-tree-easy","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0500-0599/0572-subtree-of-another-tree-easy.md","tags":[],"version":"current","sidebarPosition":572,"frontMatter":{"description":"Author: @vigneshshiv | https://leetcode.com/problems/subtree-of-another-tree/"},"sidebar":"tutorialSidebar","previous":{"title":"0567 - Permutation in String (Medium)","permalink":"/solutions/0500-0599/permutation-in-string-medium"},"next":{"title":"0581 - Shortest Unsorted Continuous Subarray (Medium)","permalink":"/solutions/0500-0599/shortest-unsorted-continuous-subarray-medium"}}');var o=n(86070),s=n(68906);const i={description:"Author: @vigneshshiv | https://leetcode.com/problems/subtree-of-another-tree/"},l="0572 - Subtree of Another Tree (Easy)",a={},d=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Pre-order Recursive Solution",id:"approach-1-pre-order-recursive-solution",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{SolutionAuthor:n,TabItem:r,Tabs:i}=t;return n||u("SolutionAuthor",!0),r||u("TabItem",!0),i||u("Tabs",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"0572---subtree-of-another-tree-easy",children:"0572 - Subtree of Another Tree (Easy)"})}),"\n",(0,o.jsx)(t.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.a,{href:"https://leetcode.com/problems/subtree-of-another-tree/",children:"https://leetcode.com/problems/subtree-of-another-tree/"})}),"\n",(0,o.jsx)(t.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,o.jsxs)(t.p,{children:["Given the roots of two binary trees ",(0,o.jsx)(t.code,{children:"root"})," and ",(0,o.jsx)(t.code,{children:"subRoot"}),", return true if there is a subtree of ",(0,o.jsx)(t.code,{children:"root"})," with the same structure and node values of ",(0,o.jsx)(t.code,{children:"subRoot"})," and ",(0,o.jsx)(t.code,{children:"false"})," otherwise."]}),"\n",(0,o.jsxs)(t.p,{children:["A subtree of a binary tree tree is a ",(0,o.jsx)(t.code,{children:"tree"})," that consists of a node in ",(0,o.jsx)(t.code,{children:"tree"})," and all of this node's descendants. The ",(0,o.jsx)(t.code,{children:"tree"})," could also be considered as a subtree of itself."]}),"\n",(0,o.jsxs)(t.p,{children:["Given the ",(0,o.jsx)(t.code,{children:"head"})," of a linked list, remove the ",(0,o.jsx)(t.code,{children:"nth"})," node from the end of the list and return its head."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Example 1:"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:"https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg",alt:"Alt text"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"Input: root = [3,4,5,1,2], subRoot = [4,1,2]\nOutput: true\n"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Example 2:"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:"https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg",alt:"Alt text"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\nOutput: false\n"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Constraints:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["The number of nodes in the ",(0,o.jsx)(t.code,{children:"root"})," tree is in the range ",(0,o.jsx)(t.code,{children:"[1, 2000]"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["The number of nodes in the ",(0,o.jsx)(t.code,{children:"subRoot"})," tree is in the range ",(0,o.jsx)(t.code,{children:"[1, 1000]"}),"."]}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"-10^4 <= root.val <= 10^4"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"-10^4 <= subRoot.val <= 10^4"})}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Follow up:"})," Could you do this in one pass?"]}),"\n",(0,o.jsx)(t.h2,{id:"approach-1-pre-order-recursive-solution",children:"Approach 1: Pre-order Recursive Solution"}),"\n",(0,o.jsxs)(i,{children:[(0,o.jsxs)(r,{value:"java",label:"Java",children:[(0,o.jsx)(n,{name:"@vigneshshiv"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        boolean contains = Objects.nonNull(subRoot) ? containsTree(root, subRoot) : true;\n        return contains;\n    }\n\n    private boolean containsTree(TreeNode t1, TreeNode t2) {\n        // Big tree t1 is empty, not a matching case\n        if (Objects.isNull(t1)) return false;\n        if (Objects.equals(t1.val, t2.val) && matchTree(t1, t2)) return true;\n        return containsTree(t1.left, t2) || containsTree(t1.right, t2);\n    }\n\n    private boolean matchTree(TreeNode t1, TreeNode t2) {\n        // nothing left in the subtree to compare\n        if (Objects.isNull(t1) && Objects.isNull(t2)) return true;\n        // one tree is empty, therefore trees don't match\n        if (Objects.isNull(t1) || Objects.isNull(t2)) return false;\n        // value doesn't match\n        if (!Objects.equals(t1.val, t2.val)) return false;\n        // Repeat until the last node of both left and right\n        return matchTree(t1.left, t2.left) && matchTree(t1.right, t2.right);\n    }\n}\n"})})]}),(0,o.jsxs)(r,{value:"python",label:"Python",children:[(0,o.jsx)(n,{name:"@ColeB2"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-py",children:"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # Time O(mn) - for every node in tree, n, we may have to check it against subRoot, m.\n    # Space: O(hm+hn) - height of m, subRoot and height of n, root.\n    # isSubtree is DFS solution which with our stack holding the current path\n    # which will scale with hn, and the isSameTree function will hold up to hm\n    # calls inside the call stack as it scales with the height of subRoot.\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        # check p and q exists and the values are equal.\n        if p and q and p.val == q.val:\n            # are equal, recursively check corresponding left and right children.\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right,q.right)\n        # aren't equal. p is q handles both are None -> return True else 1 is None\n        # and the other a node -> return False\n        return p is q\n\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        # initialize stack with our root\n        stack = [root]\n        # traverse the root tree.\n        while stack:\n            # pop current node off.\n            node = stack.pop()\n            # node matches subRoot root node, check same tree.\n            if node.val == subRoot.val:\n                # check if same tree.\n                if self.isSameTree(node, subRoot):\n                    # they are, we can return True\n                    return True\n            # add left subtree child node to the stack\n            if node.left:\n                stack.append(node.left)\n            # add right subtree child node to the stack\n            if node.right:\n                stack.append(node.right)\n        # made it through without finding subtree inside, return False.\n        return False\n"})})]})]})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}function u(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},68906:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>l});var r=n(30758);const o={},s=r.createContext(o);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);