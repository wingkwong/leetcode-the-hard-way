"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[93040],{26407(e,n,t){t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>a,default:()=>g,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=t(9346),r=(t(37953),t(58860));const s={description:"Author: @wkw | https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/",tags:["Depth-First Search","Union Find","Graph"]},a="0947 - Most Stones Removed with Same Row or Column (Medium)",i={unversionedId:"0900-0999/most-stones-removed-with-same-row-or-column-medium",id:"0900-0999/most-stones-removed-with-same-row-or-column-medium",title:"0947 - Most Stones Removed with Same Row or Column (Medium)",description:"Author: @wkw | https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/",source:"@site/solutions/0900-0999/0947-most-stones-removed-with-same-row-or-column-medium.md",sourceDirName:"0900-0999",slug:"/0900-0999/most-stones-removed-with-same-row-or-column-medium",permalink:"/solutions/0900-0999/most-stones-removed-with-same-row-or-column-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0947-most-stones-removed-with-same-row-or-column-medium.md",tags:[{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Union Find",permalink:"/solutions/tags/union-find"},{label:"Graph",permalink:"/solutions/tags/graph"}],version:"current",sidebarPosition:947,frontMatter:{description:"Author: @wkw | https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/",tags:["Depth-First Search","Union Find","Graph"]},sidebar:"tutorialSidebar",previous:{title:"0946 - Validate Stack Sequences (Medium)",permalink:"/solutions/0900-0999/validate-stack-sequences-medium"},next:{title:"0948 - Bag of Tokens (Medium)",permalink:"/solutions/0900-0999/bag-of-tokens-medium"}},m={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DSU",id:"approach-1-dsu",level:2}],p=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.yg)("div",n)},u=p("Tabs"),c=p("TabItem"),h=p("SolutionAuthor"),d={toc:l};function g({components:e,...n}){return(0,r.yg)("wrapper",(0,o.A)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"0947---most-stones-removed-with-same-row-or-column-medium"},"0947 - Most Stones Removed with Same Row or Column (Medium)"),(0,r.yg)("h2",{id:"problem-link"},"Problem Link"),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/"},"https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/")),(0,r.yg)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.yg)("p",null,"On a 2D plane, we place ",(0,r.yg)("inlineCode",{parentName:"p"},"n")," stones at some integer coordinate points. Each coordinate point may have at most one stone."),(0,r.yg)("p",null,"A stone can be removed if it shares either ",(0,r.yg)("strong",{parentName:"p"},"the same row or the same column")," as another stone that has not been removed."),(0,r.yg)("p",null,"Given an array ",(0,r.yg)("inlineCode",{parentName:"p"},"stones")," of length ",(0,r.yg)("inlineCode",{parentName:"p"},"n")," where ",(0,r.yg)("inlineCode",{parentName:"p"},"stones[i] = [xi, yi]")," represents the location of the ",(0,r.yg)("inlineCode",{parentName:"p"},"ith")," stone, return ",(0,r.yg)("em",{parentName:"p"},"the largest possible number of stones that can be removed"),"."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 1:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\nOutput: 5\nExplanation: One way to remove 5 stones is as follows:\n1. Remove stone [2,2] because it shares the same row as [2,1].\n2. Remove stone [2,1] because it shares the same column as [0,1].\n3. Remove stone [1,2] because it shares the same row as [1,0].\n4. Remove stone [1,0] because it shares the same column as [0,0].\n5. Remove stone [0,1] because it shares the same row as [0,0].\nStone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 2:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\nOutput: 3\nExplanation: One way to make 3 moves is as follows:\n1. Remove stone [2,2] because it shares the same row as [2,0].\n2. Remove stone [2,0] because it shares the same column as [0,0].\n3. Remove stone [0,2] because it shares the same row as [0,0].\nStones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 3:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: stones = [[0,0]]\nOutput: 0\nExplanation: [0,0] is the only stone on the plane, so you cannot remove it.\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Constraints:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"1 <= stones.length <= 1000")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"0 <= xi, yi <= 10^4")),(0,r.yg)("li",{parentName:"ul"},"No two stones are at the same coordinate point.")),(0,r.yg)("h2",{id:"approach-1-dsu"},"Approach 1: DSU"),(0,r.yg)(u,{mdxType:"Tabs"},(0,r.yg)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.yg)(h,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},"// retrieved from https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/disjoint-set-union\nclass dsu {\n public:\n  vector<int> root, rank;\n  int n;\n  int cnt;\n\n  dsu(int _n) : n(_n) {\n    root.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; i++) {\n        root[i] = i;\n        rank[i] = 1;\n    }\n    cnt = n;\n  }\n\n  inline int getCount() { return cnt; }\n\n  inline int get(int x) { return (x == root[x] ? x : (root[x] = get(root[x]))); }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n        if (rank[x] > rank[y]) {\n            root[y] = x;\n        } else if (rank[x] < rank[y]) {\n            root[x] = y;\n        } else {\n            root[y] = x;\n            rank[x] += 1;\n        }\n        cnt--;\n      return true;\n    }\n    return false;\n  }\n};\n\n// idea:\n// if two stones shares the same row or the same column,\n// we can use DSU to unite them together so that they are in the same group\n// for each group, we want to keep at least 1 stone (i.e. others will be removed)\n// hence, the answer is just the total count - the number of the connected components\nclass Solution {\npublic:\n    int removeStones(vector<vector<int>>& stones) {\n        int n = (int) stones.size();\n        // init dsu\n        dsu d = dsu(n);\n        // iterate all pairs\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // if two stones shares the same row or the same column\n                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\n                    // unite them together\n                    d.unite(i, j);\n                }\n            }\n        }\n        // the max number of stones that can be removed is simply\n        // the total count - the number of the connected components\n        return n - d.getCount();\n    }\n};\n")),(0,r.yg)(h,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    vector<int> parent;\n    int find(int x) {\n        return parent[x] == x ? x : find(parent[x]);\n    }\n\n    int removeStones(vector<vector<int>>& stones) {\n        int n = (int) stones.size();\n        parent.resize(n + 1, 0);\n        // at the beginning, each element is in its own group\n        for(int i = 0; i <= n; i++) parent[i] = i;\n        // iterate each pair\n        for(int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                // if two stones shares the same row or the same column\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\n                    // get the root of `i`\n                    int a = find(i);\n                    // get the root of `j`\n                    int b = find(j);\n                    // if they don't belong to the same group, unite them together\n                    if(a != b) parent[b] = a;\n                }\n            }\n        }\n        int connected = 0;\n        // if `i` is the root, then we found a new connected component\n        for(int i = 0; i < n; i++) connected += parent[i] == i;\n        // the max number of stones that can be removed is simply\n        // the total count - the number of the connected components\n        return n - connected;\n    }\n};\n")))))}g.isMDXComponent=!0},58860(e,n,t){t.d(n,{xA:()=>p,yg:()=>h});var o=t(37953);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach(function(n){r(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function i(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},s=Object.keys(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var m=o.createContext({}),l=function(e){var n=o.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=l(e.components);return o.createElement(m.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},c=o.forwardRef(function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,m=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=l(t),h=r,d=c["".concat(m,".").concat(h)]||c[h]||u[h]||s;return t?o.createElement(d,a(a({ref:n},p),{},{components:t})):o.createElement(d,a({ref:n},p))});function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,a=new Array(s);a[0]=c;var i={};for(var m in n)hasOwnProperty.call(n,m)&&(i[m]=n[m]);i.originalType=e,i.mdxType="string"==typeof e?e:r,a[1]=i;for(var l=2;l<s;l++)a[l]=t[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}c.displayName="MDXCreateElement"}}]);