"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[71070],{3294:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>r,suggestedProblems:()=>l,toc:()=>c});var s=n(85893),i=n(11151);const a={title:"Heap (Priority Queue)",description:"A heap, or a priority queue, is a data structure that efficiently stores elements in a particular order.",keywords:["leetcode","tutorial","heap","priority queue","algorithm"]},o=void 0,r={id:"basic-topics/heap",title:"Heap (Priority Queue)",description:"A heap, or a priority queue, is a data structure that efficiently stores elements in a particular order.",source:"@site/tutorials/basic-topics/heap.md",sourceDirName:"basic-topics",slug:"/basic-topics/heap",permalink:"/tutorials/basic-topics/heap",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/basic-topics/heap.md",tags:[],version:"current",frontMatter:{title:"Heap (Priority Queue)",description:"A heap, or a priority queue, is a data structure that efficiently stores elements in a particular order.",keywords:["leetcode","tutorial","heap","priority queue","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Hash Map",permalink:"/tutorials/basic-topics/hash-map"},next:{title:"Kadane Algorithm",permalink:"/tutorials/basic-topics/kadane"}},h={},l=[{problemName:"0703 - Kth Largest Element in a Stream",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/kth-largest-element-in-a-stream/",solutionLink:"../../solutions/0700-0799/kth-largest-element-in-a-stream-easy"},{problemName:"0215 - Kth Largest Element in an Array",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/kth-largest-element-in-an-array/",solutionLink:"../../solutions/0200-0299/kth-largest-element-in-an-array-medium"},{problemName:"0973 - K Closest Points to Origin",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/k-closest-points-to-origin/",solutionLink:"../../solutions/0900-0999/k-closest-points-to-origin-medium"}],c=[{value:"Overview",id:"overview",level:2},{value:"Operations",id:"operations",level:2},{value:"Insertion",id:"insertion",level:3},{value:"Deletion",id:"deletion",level:3},{value:"Python",id:"python",level:2},{value:"C++",id:"c",level:2}];function p(e){const t={a:"a",annotation:"annotation",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,i.a)(),...e.components},{Table:n,TutorialAuthors:a}=t;return n||d("Table",!0),a||d("TutorialAuthors",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a,{names:"@heiheihang,@potatochick,@SkollRyu"}),"\n",(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(t.p,{children:["A heap, or a priority queue, is a data structure that efficiently stores elements in a particular order. It is very efficient in inserting an element to the heap (",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsxs)(t.mrow,{children:[(0,s.jsx)(t.mi,{children:"O"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mi,{children:"l"}),(0,s.jsx)(t.mi,{children:"o"}),(0,s.jsx)(t.mi,{children:"g"}),(0,s.jsx)(t.mi,{children:"N"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"O(logN)"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"o"}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"}),(0,s.jsx)(t.span,{className:"mclose",children:")"})]})})]}),"), and very efficient in removing the first element of the heap (",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsxs)(t.mrow,{children:[(0,s.jsx)(t.mi,{children:"O"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mi,{children:"l"}),(0,s.jsx)(t.mi,{children:"o"}),(0,s.jsx)(t.mi,{children:"g"}),(0,s.jsx)(t.mi,{children:"N"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"O(logN)"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"o"}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"}),(0,s.jsx)(t.span,{className:"mclose",children:")"})]})})]}),"). To know the details of heap, we recommend you to look at ",(0,s.jsx)(t.a,{href:"https://www.youtube.com/watch?v=t0Cq6tVNRBA",children:"this"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"operations",children:"Operations"}),"\n",(0,s.jsx)(t.h3,{id:"insertion",children:"Insertion"}),"\n",(0,s.jsxs)(t.p,{children:["To do insetion in heap, we would add the new element to the end of the heap. If the position of the new element violates the heap properity, the new elements will be sifted up until it reaches the correct position.\n",(0,s.jsx)(t.img,{src:"https://user-images.githubusercontent.com/63882653/171032169-d92bc368-8f5a-44eb-8507-3c84f884c113.gif",alt:"heap_insertion"})]}),"\n",(0,s.jsx)(t.h3,{id:"deletion",children:"Deletion"}),"\n",(0,s.jsxs)(t.p,{children:["In heap, the deletion refers to pop the root in the heap. After the root of the heap has been popped out, the last element in the heap will be inserted to the root position. If this violates the heap porperity, the new root would be sifted down until it reaches the correct position.\n",(0,s.jsx)(t.img,{src:"https://user-images.githubusercontent.com/63882653/171033836-ec8841ac-649a-468d-8961-4ad395152df7.gif",alt:"deletion_heap"})]}),"\n",(0,s.jsx)(t.h2,{id:"python",children:"Python"}),"\n",(0,s.jsx)(t.p,{children:"By default, when we refer to heap, most implementations are min-heaps. This means the first element is always the smallest element."}),"\n",(0,s.jsx)(t.p,{children:"In Python, you can use the following functions to interact with a heap:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"heap = [] #to initialize a heap, it is just a list\n\nheappush(heap, 3) # to add an element to the heap, we can use heappush\n#heap = [3] \n\nheappush(heap, 5)\n#heap = [3, 5] , the heap always keeps the smallest element in front!\n\nsmallest_element_from_heap = heappop(heap) #we can remove the first element from heap with heappop\n#heap = [5] , 3 is removed\n#smallest_element_from_heap = 3  #after heappop, it is stored in the variable\n"})}),"\n",(0,s.jsx)(t.p,{children:"That's it! These are the operations you need for using heap in LeetCode."}),"\n",(0,s.jsx)(t.p,{children:"There is one more trick to learn for using heap. How do we tweak the heap to make it a max-heap?"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"max_heap = []\n\n#we want to store 10, but change it to -10 for max-heap\nheappush(max_heap, -10)\n#max_heap = [-10]\n\n\n#we want to store 7, but change it to -7 for max-heap\nheappush(max_heap, -7)\n#max_heap = [-10, -7]\n\nmax_element_from_heap = -1 * heappop(heap)\n#heap = [-7], -10 is removed\n#max_element_from_heap = 10, we have retrieved the largest element from the heap\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Let's work on a problem (",(0,s.jsx)(t.a,{href:"https://leetcode.com/problems/last-stone-weight/",children:"LeetCode Link"}),")"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["You are given an array of integers ",(0,s.jsx)(t.code,{children:"stones"})," where ",(0,s.jsx)(t.code,{children:"stones[i]"})," is the weight of the ",(0,s.jsx)(t.code,{children:"ith"})," stone."]}),"\n",(0,s.jsxs)(t.p,{children:["We are playing a game with the stones. On each turn, we choose the ",(0,s.jsx)(t.strong,{children:"heaviest two stones"})," and smash them together. Suppose the heaviest two stones have weights ",(0,s.jsx)(t.code,{children:"x"})," and ",(0,s.jsx)(t.code,{children:"y"})," with ",(0,s.jsx)(t.code,{children:"x <= y"}),". The result of this smash is:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["If ",(0,s.jsx)(t.code,{children:"x == y"}),", both stones are destroyed, and"]}),"\n",(0,s.jsxs)(t.li,{children:["If ",(0,s.jsx)(t.code,{children:"x != y"}),", the stone of weight ",(0,s.jsx)(t.code,{children:"x"})," is destroyed, and the stone of weight ",(0,s.jsx)(t.code,{children:"y"})," has new weight ",(0,s.jsx)(t.code,{children:"y - x"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["At the end of the game, there is ",(0,s.jsx)(t.strong,{children:"at most one"})," stone left."]}),"\n",(0,s.jsxs)(t.p,{children:["Return ",(0,s.jsx)(t.em,{children:"the smallest possible weight of the left stone"}),". If there are no stones left, return ",(0,s.jsx)(t.code,{children:"0"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"I want you to think about these questions before working on it:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Should we use a min-heap or a max-heap?"}),"\n",(0,s.jsx)(t.li,{children:'If it is a max-heap, how to we "store" the numbers?'}),"\n",(0,s.jsx)(t.li,{children:"What do we have to check before retrieving the two heaviest stones?"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"As we need to get the two heaviest stones in every iteration, we should use a max-heap for quick access of the largest elements. To use a max-heap, we can store the negative of the integer. We have to check if there are at least two more stones in the heap before retrieving the two heaviest stones."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"def lastStoneWeight(self, stones: List[int]) -> int:\n        \n        #initialize the max_heap\n        max_heap = []\n        \n        #add elements to max_heap\n        for stone in stones:\n            #store its negative to keep the most positive stone in front\n            heappush(max_heap, -stone)\n            \n        #we have to check if there are at least two stones in the heap\n        while(len(max_heap) > 1):\n            \n            #pop the largest element from max_heap, multiplied by -1\n            largest_stone = -1 * heappop(max_heap)\n            \n            #pop the second largest element (now largest) from max_heap, multiplied by -1\n            second_largest_stone = -1 * heappop(max_heap)\n            \n            #push the new stone if they are not equal\n            if(largest_stone != second_largest_stone):\n                new_stone = largest_stone - second_largest_stone\n                #remember to store its negative\n                heappush(max_heap, -new_stone)\n        \n        #if there is a stone left, return the stone, its positive value\n        if(max_heap):\n            return -max_heap[0]\n            \n        #if no stone left, return 0\n        return 0\n"})}),"\n",(0,s.jsx)(t.h2,{id:"c",children:"C++"}),"\n",(0,s.jsx)(t.p,{children:"In C++, when we are refer to heap, we mostly refer to priority queue. By default, priority queue is a max heap in c++."}),"\n",(0,s.jsx)(t.p,{children:"Create a max heap:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"priority_queue<int> max_heap; // max heap \n"})}),"\n",(0,s.jsx)(t.p,{children:"Create a min heap:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"priority_queue<int,vector<int>,greater<int>> min_heap; // min heap \n"})}),"\n",(0,s.jsx)(t.p,{children:"Other related function:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:'priority_queue<int> max_heap; //max heap\n\n//To push element into a priority queue\nmax_heap.push(1);\nmax_heap.push(2);\nmax_heap.push(3);\n//max_heap now contains: {3,2,1}\n\n//To push element from a vector into a priority queue\nvector<int> vc = {6,5,4};\nfor (auto x:vc){\n  max_heap.push(x);\n}\n//max_heap now contains: {6,5,4,3,2,1}\n\n//To get element from the priority queue\nint top_element = max_heap.top();max_heap.pop();\ncout<<top_element; //output: 6\n//As we want to access the second largest element later, we need to remove the max element after we access it. \n\n//To get all element from the priority queue\nwhile(!max_heap.empty()){\n  int element = max_heap.top();max_heap.pop();\n  cout<<element<<" "; //output: 5 4 3 2 1\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Advance usage:"})," Use heap to sort the element by value while containing the index of the elements."]}),"\n",(0,s.jsxs)(t.p,{children:["Let's work on a problem (",(0,s.jsx)(t.a,{href:"https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/",children:"LeetCode Link"}),")"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"you are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of >the civilians. That is, all the 1's will appear to the left of all the 0's in each row."}),"\n",(0,s.jsx)(t.p,{children:"A row i is weaker than a row j if one of the following is true:"}),"\n",(0,s.jsx)(t.p,{children:"The number of soldiers in row i is less than the number of soldiers in row j.\nBoth rows have the same number of soldiers and i < j.\nReturn the indices of the k weakest rows in the matrix ordered from weakest to strongest."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The idea of this question is"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"count the number of soilders in each row"}),"\n",(0,s.jsx)(t.li,{children:"sort it"}),"\n",(0,s.jsxs)(t.li,{children:["return the 1st - kth weakest ",(0,s.jsx)(t.strong,{children:"index"})," of row"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["We will use a min heap as we want the result rank from ",(0,s.jsx)(t.code,{children:"weakest to strongest"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Create a min heap which will contains ",(0,s.jsx)(t.code,{children:"pair of {number of soldiers in the row, row index}"}),". By default, c++ will rank the order of element by the first element in the heap. In this case, it will be ",(0,s.jsx)(t.code,{children:"number of soldiers"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\n//priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> pq; // this line will also work\n"})}),"\n",(0,s.jsxs)(t.p,{children:["To access the ",(0,s.jsx)(t.code,{children:"pair of {number of soldiers in the row, row index}"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"pair<int,int> top_element;\ntop_element=pq.top();pq.pop();\nint number_of_soldiers = top_element.first;\nint index = top_element.second;\n"})}),"\n",(0,s.jsx)(t.p,{children:"My solution:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> pq; //min heap\n        //push elements to min heap\n        for (int i =0;i<mat.size();i++){\n            int count= 0;\n            for (int j=0;j<mat[0].size();j++){\n                if (mat[i][j] == 1) count++;\n            }\n            pq.push({count,i}); //push pair of {number of soldiers in the row, row index} to the min heap\n            //pq.push(make_pair(count,i)); can replace with this line of syntax \n        }\n        vector<int> result;\n        int count = 0;\n        \n        //get the index only from the heap and put it in the array\n        while(!pq.empty() && count<k){\n            count++;\n            int ans = pq.top().second;\n            pq.pop();\n            result.push_back(ans);\n        }\n        return result;\n    }\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Additional knowledge:"})," You can create a ",(0,s.jsx)(t.code,{children:"max heap with pair<int,int>"})," with following syntax"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"priority_queue<pair<int,int>> pq;\n"})}),"\n","\n",(0,s.jsx)(n,{title:"Suggested Problems",data:l})]})}function m(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}function d(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var s=n(67294);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);