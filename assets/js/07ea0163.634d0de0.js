"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[82202],{29305:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"0700-0799/cheapest-flights-within-k-stops-medium","title":"0787 - Cheapest Flights Within K Stops (Medium)","description":"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/cheapest-flights-within-k-stops/","source":"@site/solutions/0700-0799/0787-cheapest-flights-within-k-stops-medium.md","sourceDirName":"0700-0799","slug":"/0700-0799/cheapest-flights-within-k-stops-medium","permalink":"/solutions/0700-0799/cheapest-flights-within-k-stops-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0700-0799/0787-cheapest-flights-within-k-stops-medium.md","tags":[{"inline":true,"label":"Dynamic Programming","permalink":"/solutions/tags/dynamic-programming"},{"inline":true,"label":"Depth-First Search","permalink":"/solutions/tags/depth-first-search"},{"inline":true,"label":"Breadth-First Search","permalink":"/solutions/tags/breadth-first-search"},{"inline":true,"label":"Graph","permalink":"/solutions/tags/graph"},{"inline":true,"label":"Heap (Priority Queue)","permalink":"/solutions/tags/heap-priority-queue"},{"inline":true,"label":"Shortest Path","permalink":"/solutions/tags/shortest-path"}],"version":"current","sidebarPosition":787,"frontMatter":{"description":"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/cheapest-flights-within-k-stops/","tags":["Dynamic Programming","Depth-First Search","Breadth-First Search","Graph","Heap (Priority Queue)","Shortest Path"]},"sidebar":"tutorialSidebar","previous":{"title":"0785 -  Is Graph Bipartite? (Medium)","permalink":"/solutions/0700-0799/is-graph-bipartite-medium"},"next":{"title":"0799 - Champagne Tower (Medium)","permalink":"/solutions/0700-0799/champagne-tower-medium"}}');var i=t(74848),a=t(28453);const r={description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/cheapest-flights-within-k-stops/",tags:["Dynamic Programming","Depth-First Search","Breadth-First Search","Graph","Heap (Priority Queue)","Shortest Path"]},l="0787 - Cheapest Flights Within K Stops (Medium)",o={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DP",id:"approach-1-dp",level:2},{value:"Approach 2: Bellman Ford",id:"approach-2-bellman-ford",level:2},{value:"Approach 3: Dijkstra&#39;s Algorithm",id:"approach-3-dijkstras-algorithm",level:2}];function c(e){const s={a:"a",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{SolutionAuthor:t,TabItem:n,Tabs:r}=s;return t||m("SolutionAuthor",!0),n||m("TabItem",!0),r||m("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"0787---cheapest-flights-within-k-stops-medium",children:"0787 - Cheapest Flights Within K Stops (Medium)"})}),"\n",(0,i.jsx)(s.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.a,{href:"https://leetcode.com/problems/cheapest-flights-within-k-stops/",children:"https://leetcode.com/problems/cheapest-flights-within-k-stops/"})}),"\n",(0,i.jsx)(s.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(s.p,{children:["There are ",(0,i.jsx)(s.code,{children:"n"})," cities connected by some number of flights. You are given an array ",(0,i.jsx)(s.code,{children:"flights"})," where ",(0,i.jsx)(s.code,{children:"flights[i] = [fromi, toi, pricei]"})," indicates that there is a flight from city ",(0,i.jsx)(s.code,{children:"fromi"})," to city ",(0,i.jsx)(s.code,{children:"toi"})," with cost ",(0,i.jsx)(s.code,{children:"pricei"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["You are also given three integers ",(0,i.jsx)(s.code,{children:"src"}),", ",(0,i.jsx)(s.code,{children:"dst"}),", and ",(0,i.jsx)(s.code,{children:"k"}),", return ",(0,i.jsxs)(s.em,{children:[(0,i.jsx)(s.strong,{children:"the cheapest price"})," from"]})," ",(0,i.jsx)(s.code,{children:"src"})," ",(0,i.jsx)(s.em,{children:"to"})," ",(0,i.jsx)(s.code,{children:"dst"})," ",(0,i.jsx)(s.em,{children:"with at most"})," ",(0,i.jsx)(s.code,{children:"k"})," ",(0,i.jsx)(s.em,{children:"stops."})," If there is no such route, return __ ",(0,i.jsx)(s.code,{children:"-1"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{src:"https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-3drawio.png",alt:""})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"Input: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\nOutput: 700\nExplanation:\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{src:"https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-1drawio.png",alt:""})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200\nExplanation:\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example 3:"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{src:"https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-2drawio.png",alt:""})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500\nExplanation:\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"1 <= n <= 100"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"0 <= flights.length <= (n * (n - 1) / 2)"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"flights[i].length == 3"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"0 <= fromi, toi < n"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"fromi != toi"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"1 <= pricei <= 10^4"})}),"\n",(0,i.jsx)(s.li,{children:"There will not be any multiple flights between two cities."}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"0 <= src, dst, k < n"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"src != dst"})}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"approach-1-dp",children:"Approach 1: DP"}),"\n",(0,i.jsx)(r,{children:(0,i.jsxs)(n,{value:"cpp",label:"C++",children:[(0,i.jsx)(t,{name:"@wingkwong"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"// TC: O(F * K)\n// SC: O(N * K) \n// where \n// - F is the number of flights\n// - K is the number of stops\n// - N is the number of cities and K is the number of stops\nclass Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // dp[i][j]: min cost to reach city j using at most i edges from src\n        vector<vector<int>> dp(k + 2, vector<int>(n, INT_MAX));\n        // base case\n        for (int i = 0; i <= k + 1; i++) dp[i][src] = 0;\n        // iterate each stop\n        for (int i = 1; i <= k + 1; i++) {\n            // iterate each flight\n            for (auto f : flights) {\n                int from = f[0], to = f[1], cost = f[2];\n                // ensure city `from` is reachable \n                if (dp[i - 1][from] != INT_MAX) {\n                    // from + cost -> to\n                    dp[i][to] = min(dp[i][to], dp[i - 1][from] + cost);   \n                }\n            }\n        }\n        // if dp[k + 1][dst] == INT_MAX, it means it is unreachable\n        // else return the cost\n        return dp[k + 1][dst] == INT_MAX ? -1 : dp[k + 1][dst];\n    }\n};\n"})})]})}),"\n",(0,i.jsx)(s.h2,{id:"approach-2-bellman-ford",children:"Approach 2: Bellman Ford"}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsxs)(n,{value:"cpp",label:"C++",children:[(0,i.jsx)(t,{name:"@wingkwong"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"// TC: O(F * K + N * K)\n// SC: O(F) \n// where \n// - F is the number of flights\n// - K is the number of stops\n// - N is the number of cities and K is the number of stops\nclass Solution {\npublic:\n    // https://leetcodethehardway.com/tutorials/graph-theory/bellman-ford-algorithm\n    template<typename T_a3, typename T_vector>\n    void bellman_ford(T_a3 &g, T_vector &dist, int src, int mx_edges) {\n        dist[src] = 0;\n        for (int i = 0; i <= mx_edges; i++) {\n            T_vector ndist = dist;\n            for (auto x : g) {\n                auto [from, to, cost] = x;\n                ndist[to] = min(ndist[to], dist[from] + cost);\n            }\n            dist = ndist;\n        }\n    }\n    \n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // we can directly use bellman ford template here (prerequisite: you need to understand bellman ford algo)\n        // bellman ford algo is used to find the shortest paths from source node to other nodes in a weighted graph\n        vector<array<int, 3>> g;\n        // initially cost with a large value\n        // cost[i] means the cheapest price from src to city i\n        vector<int> cost(n, 1e9);\n        // reconstruct a bit - {src, dst, cost}\n        for (auto f : flights) g.push_back({f[0], f[1], f[2]});\n        bellman_ford(g, cost, src, k);\n        // if cost[dst] == 1e9, it means it is unreachable\n        // else we can show cost[dst]\n        return cost[dst] == 1e9 ? -1 : cost[dst];\n    }\n};\n"})})]}),(0,i.jsxs)(n,{value:"py",label:"Python",children:[(0,i.jsx)(t,{name:"@wingkwong"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-py",children:"class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        def bellman_ford(g, dist, src, mx_edges):\n            dist[src] = 0\n            for i in range(mx_edges + 1):\n                ndist = dist.copy()\n                for x in g:\n                    _from, to, cost = x\n                    ndist[to] = min(ndist[to], dist[_from] + cost)\n                dist = ndist\n            return dist\n        g = []\n        for f in flights:\n            g.append([f[0], f[1], f[2]])\n        cost = bellman_ford(g, [1e9] * n, src, k)\n        if cost[dst] == 1e9:\n            return -1\n        return cost[dst]\n"})})]})]}),"\n",(0,i.jsx)(s.h2,{id:"approach-3-dijkstras-algorithm",children:"Approach 3: Dijkstra's Algorithm"}),"\n",(0,i.jsx)(s.p,{children:"We can use Dijkstra's Algorithm to find the shortest path. Dijkstra's Algorithm uses a heap for weights of distance we travelled, meaning with a min heap we can always check the path that is currently the shortest. One key difference though is instead of a visited set, we will use a hash map, as we might visit a city early, but run out of stops and a set would prevent us from reaching this city again. So to prevent this we can use a hash map that maps cities to stops, and if we reach a city with fewer stops than last time, we can visit this city again."}),"\n",(0,i.jsxs)(s.p,{children:["Time Complexity: ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"O"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mi,{children:"F"}),(0,i.jsx)(s.mo,{children:"+"}),(0,i.jsx)(s.mi,{children:"C"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"}),(0,i.jsx)(s.mi,{children:"l"}),(0,i.jsx)(s.mi,{children:"o"}),(0,i.jsx)(s.mi,{children:"g"}),(0,i.jsx)(s.mi,{children:"C"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"O((F + C)logC)"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(s.span,{className:"mopen",children:"(("}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"F"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(s.span,{className:"mbin",children:"+"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"}),(0,i.jsx)(s.span,{className:"mclose",children:")"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"o"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"}),(0,i.jsx)(s.span,{className:"mclose",children:")"})]})]})]})," Where ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsx)(s.mrow,{children:(0,i.jsx)(s.mi,{children:"F"})}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"F"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"F"})]})})]})," is the number of flights, and ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsx)(s.mrow,{children:(0,i.jsx)(s.mi,{children:"C"})}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"C"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"})]})})]})," is the number of cities. Worst case we must take all flights and visit all cities, updating our heap ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"l"}),(0,i.jsx)(s.mi,{children:"o"}),(0,i.jsx)(s.mi,{children:"g"}),(0,i.jsx)(s.mi,{children:"C"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"logC"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"o"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"})]})})]})," times at each city."]}),"\n",(0,i.jsxs)(s.p,{children:["Space Complexity: ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"O"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mi,{children:"C"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(C)"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(s.span,{className:"mopen",children:"("}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"}),(0,i.jsx)(s.span,{className:"mclose",children:")"})]})})]})," Where ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsx)(s.mrow,{children:(0,i.jsx)(s.mi,{children:"C"})}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"C"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"})]})})]})," is the number of cities. We must create an adjacency list, a heap, and a visited dictionary, all of which scale proportionally to the number of cities."]}),"\n",(0,i.jsx)(r,{children:(0,i.jsxs)(n,{value:"python",label:"Python",children:[(0,i.jsx)(t,{name:"@ColeB2"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-py",children:"class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        # create an adjacency list\n        adj_list = [[] for _ in range(n)]\n        # adjacenty list will be a list for cities and prices\n        # we can fly to from a desitination, i, in the list.\n        for from_i, to_i, price_i in flights:\n            adj_list[from_i].append((to_i, price_i))\n        # heap (price, stops, destination)\n        heap = [(0, 0, src)]\n        visited = defaultdict(int)\n\n        while heap:\n            # pop off the lowest price destination in our heap.\n            # Tracking price, # of stops we took, and destination.\n            price, stops, dest = heapq.heappop(heap)\n            # if we reached the destination, return the total price.\n            if dest == dst:\n                return price\n            # Track the destination as visited, and stops to reach it.\n            visited[dest] = stops\n            # Loop through all potential flights from current destination.\n            for to_i, price_i in adj_list[dest]:\n                # stops > k, it means this path doesn't work.\n                # also if to destination isn't visited, or it is\n                # visited, but the # of stops < # of stops it took us\n                # to reach the city the last time:\n                if stops <= k and (to_i not in visited or stops < visited[to_i]):\n                    # add that destination to the queue.\n                    # price, stops, to destination. Where price is the\n                    # current running price + price to fly there.\n                    # The stops should be incremented by 1, and\n                    # the destination is the to_i value.\n                    heapq.heappush(heap, (price + price_i, stops + 1, to_i))\n        # process everything but never reach destination, return -1\n        return -1\n"})})]})})]})}function d(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function m(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453:(e,s,t)=>{t.d(s,{R:()=>r,x:()=>l});var n=t(96540);const i={},a=n.createContext(i);function r(e){const s=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);