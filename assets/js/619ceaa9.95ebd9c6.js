"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[34536],{7956:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"2900-2999/minimum-number-of-changes-to-make-binary-string-beautiful-medium","title":"2914 - Minimum Number of Changes to Make Binary String Beautiful (Medium)","description":"Author: @wkw | https://leetcode.com/problems/minimum-number-of-changes-to-make-binary-string-beautiful/","source":"@site/solutions/2900-2999/2914-minimum-number-of-changes-to-make-binary-string-beautiful-medium.md","sourceDirName":"2900-2999","slug":"/2900-2999/minimum-number-of-changes-to-make-binary-string-beautiful-medium","permalink":"/solutions/2900-2999/minimum-number-of-changes-to-make-binary-string-beautiful-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2900-2999/2914-minimum-number-of-changes-to-make-binary-string-beautiful-medium.md","tags":[],"version":"current","sidebarPosition":2914,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/minimum-number-of-changes-to-make-binary-string-beautiful/"},"sidebar":"tutorialSidebar","previous":{"title":"2913 - Subarrays Distinct Element Sum of Squares I (Easy)","permalink":"/solutions/2900-2999/subarrays-distinct-element-sum-of-squares-i-easy"},"next":{"title":"3000 - 3099","permalink":"/solutions/category/3000---3099"}}');var i=s(86070),a=s(32790);const r={description:"Author: @wkw | https://leetcode.com/problems/minimum-number-of-changes-to-make-binary-string-beautiful/"},c="2914 - Minimum Number of Changes to Make Binary String Beautiful (Medium)",l={},o=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Counting",id:"approach-1-counting",level:2}];function h(e){const n={a:"a",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mn:"mn",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{SolutionAuthor:s,TabItem:t,Tabs:r}=n;return s||d("SolutionAuthor",!0),t||d("TabItem",!0),r||d("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"2914---minimum-number-of-changes-to-make-binary-string-beautiful-medium",children:"2914 - Minimum Number of Changes to Make Binary String Beautiful (Medium)"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-number-of-changes-to-make-binary-string-beautiful/",children:"https://leetcode.com/problems/minimum-number-of-changes-to-make-binary-string-beautiful/"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(n.p,{children:["You are given a ",(0,i.jsx)(n.strong,{children:"0-indexed"})," binary string ",(0,i.jsx)(n.code,{children:"s"})," having an even length."]}),"\n",(0,i.jsxs)(n.p,{children:["A string is ",(0,i.jsx)(n.strong,{children:"beautiful"})," if it's possible to partition it into one or more substrings such that:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Each substring has an ",(0,i.jsx)(n.strong,{children:"even length"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Each substring contains ",(0,i.jsx)(n.strong,{children:"only"})," ",(0,i.jsx)(n.code,{children:"1"}),"'s or ",(0,i.jsx)(n.strong,{children:"only"})," ",(0,i.jsx)(n.code,{children:"0"}),"'s."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["You can change any character in ",(0,i.jsx)(n.code,{children:"s"})," to ",(0,i.jsx)(n.code,{children:"0"})," or ",(0,i.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Return ",(0,i.jsxs)(n.em,{children:["the ",(0,i.jsx)(n.strong,{children:"minimum"})," number of changes required to make the string"]}),(0,i.jsx)(n.code,{children:"s"})," ",(0,i.jsx)(n.em,{children:"beautiful"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Input: s = "1001"\nOutput: 2\nExplanation: We change s[1] to 1 and s[3] to 0 to get string "1100".\nIt can be seen that the string "1100" is beautiful because we can partition it into "11|00".\nIt can be proven that 2 is the minimum number of changes needed to make the string beautiful.\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Input: s = "10"\nOutput: 1\nExplanation: We change s[1] to 1 to get string "11".\nIt can be seen that the string "11" is beautiful because we can partition it into "11".\nIt can be proven that 1 is the minimum number of changes needed to make the string beautiful.\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Input: s = "0000"\nOutput: 0\nExplanation: We don\'t need to make any changes as the string "0000" is beautiful already.\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"2 <= s.length <= 1e5"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"s"})," has an even length."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"s[i]"})," is either ",(0,i.jsx)(n.code,{children:"'0'"})," or ",(0,i.jsx)(n.code,{children:"'1'"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"approach-1-counting",children:"Approach 1: Counting"}),"\n",(0,i.jsxs)(n.p,{children:["Given each substring has an even length and each substring contains only 1's or only 0's, we can simply check how many pairs of adjacent differences for every 2 characters. If we have ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mn,{children:"01"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"01"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"01"})]})})]})," or ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mn,{children:"10"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"10"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"10"})]})})]}),", we need ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mn,{children:"1"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"1"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"1"})]})})]})," action to make it beautiful by converting it to either ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mn,{children:"00"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"00"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"00"})]})})]})," or ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mn,{children:"11"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"11"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"11"})]})})]}),". Therefore, we can simply count the differences for every 2 characters."]}),"\n",(0,i.jsx)(r,{children:(0,i.jsxs)(t,{value:"cpp",label:"C++",children:[(0,i.jsx)(s,{name:"@wkw"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    int minChanges(string s) {\n        int ans = 0;\n        for (int i = 1; i < s.size(); i += 2) ans += s[i] ^ s[i - 1];\n        return ans;\n    }\n};\n"})})]})})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}function d(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},32790:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var t=s(30758);const i={},a=t.createContext(i);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);