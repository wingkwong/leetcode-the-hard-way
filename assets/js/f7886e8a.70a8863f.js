"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[27344],{33889:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"0900-0999/valid-mountain-array-easy","title":"0941 - Valid Mountain Array (Easy)","description":"Author: @wingkwong, @radojicic23 | https://leetcode.com/problems/valid-mountain-array/","source":"@site/solutions/0900-0999/0941-valid-mountain-array-easy.md","sourceDirName":"0900-0999","slug":"/0900-0999/valid-mountain-array-easy","permalink":"/solutions/0900-0999/valid-mountain-array-easy","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0941-valid-mountain-array-easy.md","tags":[],"version":"current","sidebarPosition":941,"frontMatter":{"description":"Author: @wingkwong, @radojicic23 | https://leetcode.com/problems/valid-mountain-array/"},"sidebar":"tutorialSidebar","previous":{"title":"0936 - Stamping The Sequence (Hard)","permalink":"/solutions/0900-0999/stamping-the-sequence-hard"},"next":{"title":"0944 - Delete Columns to Make Sorted (Easy)","permalink":"/solutions/0900-0999/delete-columns-to-make-sorted-easy"}}');var a=r(74848),t=r(28453);const l={description:"Author: @wingkwong, @radojicic23 | https://leetcode.com/problems/valid-mountain-array/"},s="0941 - Valid Mountain Array (Easy)",o={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Prefix and Suffix",id:"approach-1-prefix-and-suffix",level:2},{value:"Approach 2: One Pass",id:"approach-2-one-pass",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components},{SolutionAuthor:r,TabItem:i,Tabs:l}=n;return r||u("SolutionAuthor",!0),i||u("TabItem",!0),l||u("Tabs",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"0941---valid-mountain-array-easy",children:"0941 - Valid Mountain Array (Easy)"})}),"\n",(0,a.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/valid-mountain-array/",children:"https://leetcode.com/problems/valid-mountain-array/"})}),"\n",(0,a.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,a.jsxs)(n.p,{children:["Given an array of integers ",(0,a.jsx)(n.code,{children:"arr"}),", return ",(0,a.jsxs)(n.em,{children:[(0,a.jsx)(n.code,{children:"true"})," if and only if it is a valid mountain array"]}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Recall that arr is a mountain array if and only if:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"arr.length >= 3"})}),"\n",(0,a.jsxs)(n.li,{children:["There exists some ",(0,a.jsx)(n.code,{children:"i"})," with ",(0,a.jsx)(n.code,{children:"0 < i < arr.length - 1"})," such that:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"arr[0] < arr[1] < ... < arr[i - 1] < arr[i]"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"arr[i] > arr[i + 1] > ... > arr[arr.length - 1]"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png",alt:""})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input: arr = [2,1]\nOutput: false\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input: arr = [3,5,5]\nOutput: false\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input: arr = [0,3,2,1]\nOutput: true\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"1 <= arr.length <= 10^4"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"0 <= arr[i] <= 10^4"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"approach-1-prefix-and-suffix",children:"Approach 1: Prefix and Suffix"}),"\n",(0,a.jsxs)(n.p,{children:["If the array length is less than 3, then it must be false. Otherwise, we can calculate the prefix and suffix.  ",(0,a.jsx)(n.code,{children:"prefix[i]"})," means it is a strictly increasing array from the first mountain till mountain ",(0,a.jsx)(n.code,{children:"i"}),". Similarly, ",(0,a.jsx)(n.code,{children:"suffix[j]"})," means it is a strictly decreasing array from the last mountain till mountain ",(0,a.jsx)(n.code,{children:"j"}),". If there is a certain point ",(0,a.jsx)(n.code,{children:"k"})," where ",(0,a.jsx)(n.code,{children:"prefix[k]"})," and ",(0,a.jsx)(n.code,{children:"suffix[k]"})," both true, then that would be the peak of a valid mountain."]}),"\n",(0,a.jsx)(l,{children:(0,a.jsxs)(i,{value:"cpp",label:"C++",children:[(0,a.jsx)(r,{name:"@wingkwong"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    bool validMountainArray(vector<int>& arr) {\n        int n = arr.size();\n        if(n < 3) return false;\n        vector<int> p(n, 0), s(n, 0); // prefix & suffix\n        p[0] = s[n - 1] = 1;\n        for(int i = 1; i < n - 1; i++) p[i] = arr[i] > arr[i - 1] && p[i - 1];\n        for(int i = n - 2; i >= 1; i--) s[i] = arr[i] > arr[i + 1] && s[i + 1];\n        for(int i = 1; i < n - 1; i++) if(p[i] && s[i]) return true;\n        return false;\n    }\n};\n"})})]})}),"\n",(0,a.jsx)(n.h2,{id:"approach-2-one-pass",children:"Approach 2: One Pass"}),"\n",(0,a.jsxs)(n.p,{children:["From approach 1, we can see that both prefix and suffix array only record if it is a strictly increasing or decreasing array till certain point. We can optimise it using two pointers ",(0,a.jsx)(n.code,{children:"i"})," and ",(0,a.jsx)(n.code,{children:"j"}),", where pointer ",(0,a.jsx)(n.code,{children:"i"})," is to check the strictly increasing array and pointer ",(0,a.jsx)(n.code,{children:"j"})," is to check the strictly decreasing array.  If they stop at the same point, then that would be the peak of the same mountain."]}),"\n",(0,a.jsxs)(l,{children:[(0,a.jsxs)(i,{value:"cpp",label:"C++",children:[(0,a.jsx)(r,{name:"@wingkwong"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    bool validMountainArray(vector<int>& arr) {\n        int n = arr.size(), i = 0, j = n - 1;\n        while (i + 1 < n && arr[i] < arr[i + 1]) i++;\n        while (j - 1 > 0 && arr[j - 1] > arr[j]) j--;\n        return i == j && i > 0 && j < n - 1;\n    }\n};\n"})})]}),(0,a.jsxs)(i,{value:"py",label:"Python",children:[(0,a.jsx)(r,{name:"@radojicic23"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"class Solution:\n    def validMountainArray(self, arr: List[int]) -> bool:\n        l, r = 0, len(arr) - 1\n        if len(arr) < 3: return False\n        while l + 1 < len(arr) - 1 and arr[l] < arr[l + 1]:\n            l += 1\n        while r - 1 > 0 and arr[r] < arr[r - 1]:\n            r -= 1\n        return l == r\n        \n"})})]}),(0,a.jsxs)(i,{value:"js",label:"JavaScript",children:[(0,a.jsx)(r,{name:"@radojicic23"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"/**\n * @param {number[]} arr\n * @return {boolean}\n */\nvar validMountainArray = function(arr) {\n    let left = 0;\n    let right = arr.length - 1;\n    if (arr.length < 3) return false;\n    while (left + 1 < arr.length - 1 && arr[left] < arr[left + 1]) left++;\n    while (right - 1 > 0 && arr[right] < arr[right - 1]) right--;\n    return left == right;\n};     \n"})})]})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>s});var i=r(96540);const a={},t=i.createContext(a);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);