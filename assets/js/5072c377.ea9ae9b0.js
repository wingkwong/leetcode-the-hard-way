"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[5849],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return b}});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=l(n),b=o,d=m["".concat(u,".").concat(b)]||m[b]||c[b]||a;return n?r.createElement(d,i(i({ref:t},p),{},{components:n})):r.createElement(d,i({ref:t},p))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},44018:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return k},frontMatter:function(){return u},metadata:function(){return p},toc:function(){return m}});var r,o=n(87462),a=n(63366),i=(n(67294),n(3905)),s=["components"],u={description:"Author: @wingkwong | https://leetcode.com/problems/subsets/"},l="0078 - Subsets (Medium)",p={unversionedId:"0000-0099/subsets-medium",id:"0000-0099/subsets-medium",title:"0078 - Subsets (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/subsets/",source:"@site/solutions/0000-0099/0078-subsets-medium.md",sourceDirName:"0000-0099",slug:"/0000-0099/subsets-medium",permalink:"/leetcode-the-hard-way/solutions/0000-0099/subsets-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0000-0099/0078-subsets-medium.md",tags:[],version:"current",sidebarPosition:78,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/subsets/"},sidebar:"tutorialSidebar",previous:{title:"0074 - Search a 2D Matrix (Medium)",permalink:"/leetcode-the-hard-way/solutions/0000-0099/search-a-2d-matrix-medium"},next:{title:"0094 - Binary Tree Inorder Traversal (Easy)",permalink:"/leetcode-the-hard-way/solutions/0000-0099/binary-tree-inorder-traversal-easy"}},c={},m=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Bit  Manipulation",id:"approach-1-bit--manipulation",level:2},{value:"Approach 2: Backtracking",id:"approach-2-backtracking",level:2}],b=(r="SolutionAuthor",function(e){return console.warn("Component "+r+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)}),d={toc:m};function k(e){var t=e.components,n=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0078---subsets-medium"},"0078 - Subsets (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/subsets/"},"https://leetcode.com/problems/subsets/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Given an integer array ",(0,i.kt)("inlineCode",{parentName:"p"},"nums")," of ",(0,i.kt)("strong",{parentName:"p"},"unique")," elements, return ",(0,i.kt)("em",{parentName:"p"},"all possible subsets (the power set)"),"."),(0,i.kt)("p",null,"The solution set ",(0,i.kt)("strong",{parentName:"p"},"must not")," contain duplicate subsets. Return the solution in ",(0,i.kt)("strong",{parentName:"p"},"any order"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums = [0]\nOutput: [[],[0]] \n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= nums.length <= 10")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-10 <= nums[i] <= 10")),(0,i.kt)("li",{parentName:"ul"},"All the numbers of ",(0,i.kt)("inlineCode",{parentName:"li"},"nums")," are ",(0,i.kt)("strong",{parentName:"li"},"unique"),".")),(0,i.kt)("h2",{id:"approach-1-bit--manipulation"},"Approach 1: Bit  Manipulation"),(0,i.kt)("p",null,"We can try all the possible combinations of the numbers. For each number there are only two options - you either take the number or not. If the bit is set as 1, then it means this number needs to be taken. If the bit is set as 0, we don't take this number."),(0,i.kt)(b,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        int n = nums.size();\n        // number of subsets for n elements would be 2 ^ n\n        // because for each element, you can choose to take it or not\n        // if take = 1, don't take = 0, then we can use bit manipulation \n        int p = 1 << n; // 1 * 2 ^ n\n        vector<vector<int>> ans;\n        for(int i = 0; i < p; i++){\n            vector<int> t; \n            for(int j = 0; j < n; j++){\n               if((1 << j) & i) t.emplace_back(nums[j]); \n            }\n            ans.emplace_back(t);\n        }\n        return ans;\n    }\n};\n")),(0,i.kt)("h2",{id:"approach-2-backtracking"},"Approach 2: Backtracking"),(0,i.kt)("p",null,"Standard ",(0,i.kt)("a",{parentName:"p",href:"../../tutorials/basic-topics/backtracking"},"Backtracking")," problem."),(0,i.kt)(b,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    void backtrack(vector<vector<int>>& ans, vector<int>& tmp, vector<int>& nums, int start) {\n        ans.push_back(tmp);    \n        for(int i = start; i < nums.size(); i++) {\n            tmp.push_back(nums[i]);\n            backtrack(ans, tmp, nums, i + 1);\n            tmp.pop_back();\n        }\n    }\n    \n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        vector<int> tmp;\n        sort(nums.begin(), nums.end());\n        backtrack(ans, tmp, nums,  0);\n        return ans;\n    }\n};\n")))}k.isMDXComponent=!0}}]);