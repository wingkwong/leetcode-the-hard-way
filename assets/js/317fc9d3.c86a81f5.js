"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[5887],{17090:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>h});var a=s(85893),t=s(11151);const i={description:"Author: @ColeB2 | https://leetcode.com/problems/clone-graph/",tags:["Hash Table","Depth-First Search","Breadth-First Search","Graph"]},r="0133 - Clone Graph (Medium)",o={id:"0100-0199/clone-graph-medium",title:"0133 - Clone Graph (Medium)",description:"Author: @ColeB2 | https://leetcode.com/problems/clone-graph/",source:"@site/solutions/0100-0199/0133-clone-graph-medium.md",sourceDirName:"0100-0199",slug:"/0100-0199/clone-graph-medium",permalink:"/solutions/0100-0199/clone-graph-medium",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0100-0199/0133-clone-graph-medium.md",tags:[{inline:!0,label:"Hash Table",permalink:"/solutions/tags/hash-table"},{inline:!0,label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{inline:!0,label:"Breadth-First Search",permalink:"/solutions/tags/breadth-first-search"},{inline:!0,label:"Graph",permalink:"/solutions/tags/graph"}],version:"current",sidebarPosition:133,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/clone-graph/",tags:["Hash Table","Depth-First Search","Breadth-First Search","Graph"]},sidebar:"tutorialSidebar",previous:{title:"0131 - Palindrome Partitioning (Medium)",permalink:"/solutions/0100-0199/palindrome-partitioning-medium"},next:{title:"0134 - Gas Station (Medium)",permalink:"/solutions/0100-0199/gas-station-medium"}},l={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Iterative Depth/Breadth-First Search",id:"approach-1-iterative-depthbreadth-first-search",level:2}];function c(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,t.a)(),...e.components},{SolutionAuthor:s,TabItem:i,Tabs:r}=n;return s||p("SolutionAuthor",!0),i||p("TabItem",!0),r||p("Tabs",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"0133---clone-graph-medium",children:"0133 - Clone Graph (Medium)"})}),"\n",(0,a.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/clone-graph/",children:"https://leetcode.com/problems/clone-graph/"})}),"\n",(0,a.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,a.jsxs)(n.p,{children:["Given a reference of a node in a ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph",children:(0,a.jsx)(n.strong,{children:"connected"})})," undirected graph."]}),"\n",(0,a.jsxs)(n.p,{children:["Return a ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Object_copying#Deep_copy",children:(0,a.jsx)(n.strong,{children:"deep copy"})})," (clone) of the graph."]}),"\n",(0,a.jsxs)(n.p,{children:["Each node in the graph contains a value (",(0,a.jsx)(n.code,{children:"int"}),") and a list (",(0,a.jsx)(n.code,{children:"List[Node]"}),") of its neighbors."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"class Node {\n    public int val;\n    public List<Node> neighbors;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Test case format:"})}),"\n",(0,a.jsxs)(n.p,{children:["For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with ",(0,a.jsx)(n.code,{children:"val == 1"}),", the second node with ",(0,a.jsx)(n.code,{children:"val == 2"}),", and so on. The graph is represented in the test case using an adjacency list."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"An adjacency list"})," is a collection of unordered ",(0,a.jsx)(n.strong,{children:"lists"})," used to represent a finite graph. Each list describes the set of neighbors of a node in the graph."]}),"\n",(0,a.jsxs)(n.p,{children:["The given node will always be the first node with ",(0,a.jsx)(n.code,{children:"val = 1"}),". You must return the ",(0,a.jsx)(n.strong,{children:"copy of the given node"})," as a reference to the cloned graph."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png",alt:""})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\nExplanation: There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2020/01/07/graph.png",alt:""})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input: adjList = [[]]\nOutput: [[]]\nExplanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input: adjList = []\nOutput: []\nExplanation: This an empty graph, it does not have any nodes.\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The number of nodes in the graph is in the range ",(0,a.jsx)(n.code,{children:"[0, 100]"}),"."]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"1 <= Node.val <= 100"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Node.val"})," is unique for each node."]}),"\n",(0,a.jsx)(n.li,{children:"There are no repeated edges and no self-loops in the graph."}),"\n",(0,a.jsx)(n.li,{children:"The Graph is connected and all nodes can be visited starting from the given node."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"approach-1-iterative-depthbreadth-first-search",children:"Approach 1: Iterative Depth/Breadth-First Search"}),"\n",(0,a.jsx)(n.p,{children:"We need to traverse all the nodes in the graph, create copies, and connect the copies. Iteratively we can use a stack or a queue to traverse nodes we haven't visited already."}),"\n",(0,a.jsx)(n.p,{children:"Starting at the first node, we will traverse by checking all the neighbors of the nodes. For each neighbor, we will get/create ae copy of that neighbor and add the copied neighbour to the neighbour of the node we are looking at."}),"\n",(0,a.jsx)(n.p,{children:"We will also want to check if the neighbour has been added to our hash map. If not, we can add it to our queue/stack to visit it and its neighbors, as well as add it to the hash map with its copy."}),"\n",(0,a.jsxs)(n.p,{children:["Time Complexity: ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"O"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mi,{children:"V"}),(0,a.jsx)(n.mo,{children:"+"}),(0,a.jsx)(n.mi,{children:"E"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(V + E)"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"+"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),(0,a.jsx)(n.span,{className:"mclose",children:")"})]})]})]}),". Where ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"V"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"V"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"})]})})]})," is the number of nodes, and ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"E"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"E"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"})]})})]})," is the number of edges in the graph. We will visit each vertex/node once during our BFS/DFS, and while looking through the neighbors, we will check on each edge twice. Once for each neighbor."]}),"\n",(0,a.jsxs)(n.p,{children:["Space: ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"O"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mi,{children:"V"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(V)"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,a.jsx)(n.span,{className:"mclose",children:")"})]})})]})," Our hash map, and stack/queue will take ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"O"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mi,{children:"V"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(V)"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,a.jsx)(n.span,{className:"mclose",children:")"})]})})]})," space."]}),"\n",(0,a.jsx)(r,{children:(0,a.jsxs)(i,{value:"python",label:"Python",children:[(0,a.jsx)(s,{name:"@ColeB2"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"class Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':\n        # Base case, return early\n        if not node:\n            return None\n        # initialize our nodes hash map. This track whether we have\n        # visited a node or node, as well as gives us access to the \n        # copies. Key: Value -> node.val, node copy.\n        nodes = {node.val : Node(node.val)}\n        # Stack/Queue containing node we are traversing and the copy.\n        stack = [(node, nodes[node.val])]\n        while stack:\n            # pop off the node, and the copy\n            n1, c1 = stack.pop()\n            # traverse the node we popped, neighbors.\n            for n in n1.neighbors:\n                # Get our copy from our hash map, if it doesn't exist\n                # we will create it based on the neighbors value.\n                c2 = nodes.get(n.val, Node(n.val))\n                # if neighbor hasn't been visited yet.\n                if n.val not in nodes:\n                    # add it to the stack to process later\n                    stack.append((n, c2))\n                    # add it to our visited hash map, with reference\n                    # to the copy.\n                    nodes[n.val] = c2\n                # add the neighbor copies to our node copy.\n                c1.neighbors.append(c2)\n        # return the copy of our node. Above we created an undirected\n        # graph, and the copies should all now point to the proper copies.\n        return nodes[node.val]\n"})})]})})]})}function d(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}function p(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>r});var a=s(67294);const t={},i=a.createContext(t);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);