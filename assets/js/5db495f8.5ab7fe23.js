"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[43790],{29958:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>g,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"0000-0099/restore-ip-addresses-medium","title":"0093 - Restore IP Addresses (Medium)","description":"Author: @wingkwong | https://leetcode.com/problems/restore-ip-addresses/","source":"@site/solutions/0000-0099/0093-restore-ip-addresses-medium.md","sourceDirName":"0000-0099","slug":"/0000-0099/restore-ip-addresses-medium","permalink":"/solutions/0000-0099/restore-ip-addresses-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0000-0099/0093-restore-ip-addresses-medium.md","tags":[{"inline":true,"label":"String","permalink":"/solutions/tags/string"},{"inline":true,"label":"Backtracking","permalink":"/solutions/tags/backtracking"}],"version":"current","sidebarPosition":93,"frontMatter":{"description":"Author: @wingkwong | https://leetcode.com/problems/restore-ip-addresses/","tags":["String","Backtracking"]},"sidebar":"tutorialSidebar","previous":{"title":"0091 - Decode Ways (Medium)","permalink":"/solutions/0000-0099/decode-ways-medium"},"next":{"title":"0094 - Binary Tree Inorder Traversal (Easy)","permalink":"/solutions/0000-0099/binary-tree-inorder-traversal-easy"}}');var i=n(74848),r=n(28453);const a={description:"Author: @wingkwong | https://leetcode.com/problems/restore-ip-addresses/",tags:["String","Backtracking"]},o="0093 - Restore IP Addresses (Medium)",d={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Iterative",id:"approach-1-iterative",level:2}];function c(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{SolutionAuthor:n,TabItem:t,Tabs:a}=s;return n||h("SolutionAuthor",!0),t||h("TabItem",!0),a||h("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"0093---restore-ip-addresses-medium",children:"0093 - Restore IP Addresses (Medium)"})}),"\n",(0,i.jsx)(s.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.a,{href:"https://leetcode.com/problems/restore-ip-addresses/",children:"https://leetcode.com/problems/restore-ip-addresses/"})}),"\n",(0,i.jsx)(s.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.strong,{children:"valid IP address"})," consists of exactly four integers separated by single dots. Each integer is between ",(0,i.jsx)(s.code,{children:"0"})," and ",(0,i.jsx)(s.code,{children:"255"})," (",(0,i.jsx)(s.strong,{children:"inclusive"}),") and cannot have leading zeros."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["For example, ",(0,i.jsx)(s.code,{children:'"0.1.2.201"'})," and ",(0,i.jsx)(s.code,{children:'"192.168.1.1"'})," are ",(0,i.jsx)(s.strong,{children:"valid"})," IP addresses, but ",(0,i.jsx)(s.code,{children:'"0.011.255.245"'}),", ",(0,i.jsx)(s.code,{children:'"192.168.1.312"'})," and ",(0,i.jsx)(s.code,{children:'"192.168@1.1"'})," are ",(0,i.jsx)(s.strong,{children:"invalid"})," IP addresses."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Given a string ",(0,i.jsx)(s.code,{children:"s"})," containing only digits, return ",(0,i.jsx)(s.em,{children:"all possible valid IP addresses that can be formed by inserting dots into"}),(0,i.jsx)(s.code,{children:"s"}),". You are ",(0,i.jsx)(s.strong,{children:"not"})," allowed to reorder or remove any digits in ",(0,i.jsx)(s.code,{children:"s"}),". You may return the valid IP addresses in ",(0,i.jsx)(s.strong,{children:"any"})," order."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'Input: s = "25525511135"\nOutput: ["255.255.11.135","255.255.111.35"]\n'})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'Input: s = "0000"\nOutput: ["0.0.0.0"]\n'})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example 3:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'Input: s = "101023"\nOutput: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]\n'})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"1 <= s.length <= 20"})}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"s"})," consists of digits only."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"approach-1-iterative",children:"Approach 1: Iterative"}),"\n",(0,i.jsxs)(a,{children:[(0,i.jsxs)(t,{value:"cpp",label:"C++",children:[(0,i.jsx)(n,{name:"@wingkwong"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:'// ideas:\n// A valid ip address would have 4 parts separated by dots\n// we iterate through `s` to insert 3 dots and separate the string into 4 segments\n// for each segment, we check if it is valid\n// if all 4 segments are valid, we combine those 4 segments with dots and push to the answer\n\nclass Solution {\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        vector<string> ans;\n        int n = s.size();\n        // iterate `s` - place 3 dots to have 4 segments \n        // [seg1].[seg2].[seg3].[seg4]\n        // 1st dot - we just need to run it 3 times at most\n        // e.g. for 255, we can place the first dot at `2.55`, `25.5` or `255.`\n        for (int i = 1; i < 4 && i < n; i++) {\n            // we place the 2nd dot in a similar way\n            for (int j = i + 1; j < i + 4 && j < n; j++) {\n                // we place the 3rd dot in a similar way\n                for (int k = j + 1; k < j + 4 && k < n; k++) {\n                    // now we can separate into 4 segments\n                    string seg1 = s.substr(0, i),\n                           seg2 = s.substr(i, j - i),\n                           seg3 = s.substr(j, k - j), \n                           seg4 = s.substr(k);\n                    // for each segment, check if it is valid\n                    if (ok(seg1) && ok(seg2) && ok(seg3) && ok(seg4)) {\n                        // if so, we build the ip address and push to answer\n                        ans.push_back(seg1 + "." + seg2 + "." + seg3 + "." + seg4);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n    \n    // check if a given IP address segment is valid\n    // 192 -> true\n    // 312 -> false\n    bool ok(string s) {\n        // string length > 3 is not a valid IP address segment\n        if (s.size() > 3 || \n            // empty segment is not valid\n            s.size() == 0 ||\n            // if the first character is 0, we cannot have something like 0x, 0xx\n            (s[0] == \'0\' && s.size() > 1) || \n            // segment is out of range\n            stoi(s) > 255\n           ) {\n            return false;\n        }\n        return true;\n    }\n};\n\n'})})]}),(0,i.jsxs)(t,{value:"java",label:"Java",children:[(0,i.jsx)(n,{name:"@wingkwong"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-java",children:'\n// ideas:\n// A valid ip address would have 4 parts separated by dots\n// we iterate through `s` to insert 3 dots and separate the string into 4 segments\n// for each segment, we check if it is valid\n// if all 4 segments are valid, we combine those 4 segments with dots and push to the answer\nclass Solution {\n    public List<String> restoreIpAddresses(String s) {\n        List<String> ans = new ArrayList<>();\n        int n = s.length();\n        // iterate `s` - place 3 dots to have 4 segments \n        // [seg1].[seg2].[seg3].[seg4]\n        // 1st dot - we just need to run it 3 times at most\n        // e.g. for 255, we can place the first dot at `2.55`, `25.5` or `255.`\n        for (int i = 1; i < 4 && i < n; i++) {\n            // we place the 2nd dot in a similar way\n            for (int j = i + 1; j < i + 4 && j < n; j++) {\n                // we place the 3rd dot in a similar way\n                for (int k = j + 1; k < j + 4 && k < n; k++) {\n                    // now we can separate into 4 segments\n                    String seg1 = s.substring(0, i),\n                           seg2 = s.substring(i, j),\n                           seg3 = s.substring(j, k), \n                           seg4 = s.substring(k);\n                    // for each segment, check if it is valid\n                    if (ok(seg1) && ok(seg2) && ok(seg3) && ok(seg4)) {\n                        // if so, we build the ip address and push to answer\n                        ans.add(seg1 + "." + seg2 + "." + seg3 + "." + seg4);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n    \n    // check if a given IP address segment is valid\n    // 192 -> true\n    // 312 -> false\n    private boolean ok(String s) {\n        // string length > 3 is not a valid IP address segment\n        if (s.length() > 3 || \n            // empty segment is not valid\n            s.length() == 0 ||\n            // if the first character is 0, we cannot have something like 0x, 0xx\n            (s.charAt(0) == \'0\' && s.length() > 1) || \n            // segment is out of range\n            Integer.parseInt(s) > 255\n           ) {\n            return false;\n        }\n        return true;\n    }\n}\n\n'})})]}),(0,i.jsxs)(t,{value:"py",label:"Python",children:[(0,i.jsx)(n,{name:"@wingkwong"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-py",children:'# ideas:\n# A valid ip address would have 4 parts separated by dots\n# we iterate through `s` to insert 3 dots and separate the string into 4 segments\n# for each segment, we check if it is valid\n# if all 4 segments are valid, we combine those 4 segments with dots and push to the answer\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        ans = []\n        n = len(s)\n        \n        # check if a given IP address segment is valid\n        # 192 -> true\n        # 312 -> false\n        def ok(seg: str) -> bool:\n            # string length > 3 is not a valid IP address segment\n            # empty segment is not valid\n            # if the first character is 0, we cannot have something like 0x, 0xx\n            # segment is out of range\n            if len(seg) > 3 or len(seg) == 0 or (seg[0] == \'0\' and len(seg) > 1) or int(seg) > 255:\n                return False\n            return True\n    \n        # iterate `s` - place 3 dots to have 4 segments \n        # [seg1].[seg2].[seg3].[seg4]\n        # 1st dot - we just need to run it 3 times at most\n        # e.g. for 255, we can place the first dot at `2.55`, `25.5` or `255.`\n        for i in range(1, 4):\n            # we place the 2nd dot in a similar way\n            for j in range(i + 1, i + 4):\n                # we place the 3rd dot in a similar way\n                for k in range(j + 1, j + 4):\n                    # now we can separate into 4 segments\n                    seg1, seg2, seg3, seg4 = s[:i], s[i:j], s[j:k], s[k:]\n                    # for each segment, check if it is valid\n                    if ok(seg1) and ok(seg2) and ok(seg3) and ok(seg4):\n                        # if so, we build the ip address and push to answer\n                        ans.append(seg1 + "." + seg2 + "." + seg3 + "." + seg4)\n        return ans\n\n'})})]}),(0,i.jsxs)(t,{value:"rs",label:"Rust",children:[(0,i.jsx)(n,{name:"@wingkwong"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rs",children:"// ideas:\n// A valid ip address would have 4 parts separated by dots\n// we iterate through `s` to insert 3 dots and separate the string into 4 segments\n// for each segment, we check if it is valid\n// if all 4 segments are valid, we combine those 4 segments with dots and push to the answer\n\nimpl Solution {\n    fn restore_ip_addresses(s: String) -> Vec<String> {\n        let mut ans = vec![];\n        let n = s.len();\n        // iterate `s` - place 3 dots to have 4 segments \n        // [seg1].[seg2].[seg3].[seg4]\n        // 1st dot - we just need to run it 3 times at most\n        // e.g. for 255, we can place the first dot at `2.55`, `25.5` or `255.`\n        for i in 1 .. 4 {\n            // we place the 2nd dot in a similar way\n            for j in i + 1 .. i + 4 {\n                // we place the 3rd dot in a similar way\n                for k in j + 1 .. j + 4 {\n                    if k < n {\n                        // now we can separate into 4 segments\n                        let seg1 = &s[..i];\n                        let seg2 = &s[i..j];\n                        let seg3 = &s[j..k];\n                        let seg4 = &s[k..];\n                        // for each segment, check if it is valid\n                        if Solution::ok(seg1) && \n                           Solution::ok(seg2) && \n                           Solution::ok(seg3) && \n                           Solution::ok(seg4) {\n                            // if so, we build the ip address and push to answer\n                            ans.push(format!(\"{}.{}.{}.{}\", seg1, seg2, seg3, seg4));\n                        }\n                    }\n                }\n            }\n        }\n        ans\n    }\n\n    // check if a given IP address segment is valid\n    // 192 -> true\n    // 312 -> false\n    fn ok(seg: &str) -> bool {\n        seg.len() > 0 && seg.len() <= 3 && !(seg.starts_with('0') && seg.len() > 1) && seg.parse::<u32>().unwrap() <= 255\n    }\n}\n\n"})})]})]})]})}function g(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function h(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>o});var t=n(96540);const i={},r=t.createContext(i);function a(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);