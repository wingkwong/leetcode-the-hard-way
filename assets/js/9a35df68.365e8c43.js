"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[70093],{79189:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"0200-0299/delete-node-in-a-linked-list-medium","title":"0237 - Delete Node in a Linked List (Medium)","description":"Author: @heder | https://leetcode.com/problems/delete-node-in-a-linked-list/","source":"@site/solutions/0200-0299/0237-delete-node-in-a-linked-list-medium.md","sourceDirName":"0200-0299","slug":"/0200-0299/delete-node-in-a-linked-list-medium","permalink":"/solutions/0200-0299/delete-node-in-a-linked-list-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0200-0299/0237-delete-node-in-a-linked-list-medium.md","tags":[{"inline":true,"label":"Linked List","permalink":"/solutions/tags/linked-list"}],"version":"current","sidebarPosition":237,"frontMatter":{"description":"Author: @heder | https://leetcode.com/problems/delete-node-in-a-linked-list/","tags":["Linked List"]},"sidebar":"tutorialSidebar","previous":{"title":"0235 - Lowest Common Ancestor of a Binary Search Tree (Medium)","permalink":"/solutions/0200-0299/lowest-common-ancestor-of-a-binary-search-tree-medium"},"next":{"title":"0239 - Sliding Window Maximum (Hard)","permalink":"/solutions/0200-0299/sliding-maximum-window-hard"}}');var d=t(86070),i=t(40629);const l={description:"Author: @heder | https://leetcode.com/problems/delete-node-in-a-linked-list/",tags:["Linked List"]},s="0237 - Delete Node in a Linked List (Medium)",r={},a=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Copy next node",id:"approach-1-copy-next-node",level:2},{value:"Variant 1: C style code",id:"variant-1-c-style-code",level:3},{value:"Variant 2: std::unique_ptr",id:"variant-2-stdunique_ptr",level:3},{value:"Variant 3: std::exchange (just for fun, not recommended)",id:"variant-3-stdexchange-just-for-fun-not-recommended",level:3},{value:"Appendix: Looking at the generated assembly",id:"appendix-looking-at-the-generated-assembly",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{SolutionAuthor:t,TabItem:o,Tabs:l}=n;return t||u("SolutionAuthor",!0),o||u("TabItem",!0),l||u("Tabs",!0),(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.header,{children:(0,d.jsx)(n.h1,{id:"0237---delete-node-in-a-linked-list-medium",children:"0237 - Delete Node in a Linked List (Medium)"})}),"\n",(0,d.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.a,{href:"https://leetcode.com/problems/delete-node-in-a-linked-list/",children:"https://leetcode.com/problems/delete-node-in-a-linked-list/"})}),"\n",(0,d.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,d.jsxs)(n.p,{children:["There is a singly-linked list ",(0,d.jsx)(n.code,{children:"head"})," and we want to delete a node ",(0,d.jsx)(n.code,{children:"node"})," in it."]}),"\n",(0,d.jsxs)(n.p,{children:["You are given the node to be deleted ",(0,d.jsx)(n.code,{children:"node"}),". You will ",(0,d.jsx)(n.strong,{children:"not be given access"})," to the first node of ",(0,d.jsx)(n.code,{children:"head"}),"."]}),"\n",(0,d.jsxs)(n.p,{children:["All the values of the linked list are ",(0,d.jsx)(n.strong,{children:"unique"}),", and it is guaranteed that the given node ",(0,d.jsx)(n.code,{children:"node"})," is not the last node in the linked list."]}),"\n",(0,d.jsx)(n.p,{children:"Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"The value of the given node should not exist in the linked list."}),"\n",(0,d.jsx)(n.li,{children:"The number of nodes in the linked list should decrease by one."}),"\n",(0,d.jsxs)(n.li,{children:["All the values before ",(0,d.jsx)(n.code,{children:"node"})," should be in the same order."]}),"\n",(0,d.jsxs)(n.li,{children:["All the values after ",(0,d.jsx)(n.code,{children:"node"})," should be in the same order."]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Custom testing:"})}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["For the input, you should provide the entire linked list ",(0,d.jsx)(n.code,{children:"head"})," and the node to be given ",(0,d.jsx)(n.code,{children:"node"}),". ",(0,d.jsx)(n.code,{children:"node"})," should not be the last node of the list and should be an actual node in the list."]}),"\n",(0,d.jsx)(n.li,{children:"We will build the linked list and pass the node to your function."}),"\n",(0,d.jsx)(n.li,{children:"The output will be the entire list after calling your function."}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"Input: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"Input: head = [4,5,1,9], node = 1\nOutput: [4,5,9]\nExplanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["The number of the nodes in the given list is in the range ",(0,d.jsx)(n.code,{children:"[2, 1000]"}),"."]}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.code,{children:"-1000 <= Node.val <= 1000"})}),"\n",(0,d.jsxs)(n.li,{children:["The value of each node in the list is ",(0,d.jsx)(n.strong,{children:"unique"}),"."]}),"\n",(0,d.jsxs)(n.li,{children:["The ",(0,d.jsx)(n.code,{children:"node"})," to be deleted is ",(0,d.jsx)(n.strong,{children:"in the list"})," and is ",(0,d.jsx)(n.strong,{children:"not a tail"})," node."]}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"approach-1-copy-next-node",children:"Approach 1: Copy next node"}),"\n",(0,d.jsx)(n.p,{children:"Before looking at different implementation let me briefly touch on the intiution. Usually for a linked list if we want to remove a ListNode we would update the previous node to point the the node after the one we want to remove. For this problem we don't know the previous node, we are only given the address of the node we want to remove. The approach is to overwrite the node we want to remove with the content of the next node and then remove the next node. The problem description states that we can expect that the node we should remove is never the last node, otherwise the problem can't be solved."}),"\n",(0,d.jsx)(n.h3,{id:"variant-1-c-style-code",children:"Variant 1: C style code"}),"\n",(0,d.jsx)(n.p,{children:"Instead of assigning node->val and node->next we can just assign the entire node."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"Time Complexity: left as an exercise to the reader."}),"\n",(0,d.jsxs)(n.li,{children:["Space Complexity: Is negative space complexity a thing, since we are freeing memory here? ",":D"]}),"\n"]}),"\n",(0,d.jsx)(l,{children:(0,d.jsxs)(o,{value:"cpp",label:"C++",children:[(0,d.jsx)(t,{name:"@heder"}),(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"static void deleteNode(ListNode* node) {\n    ListNode* next = node->next;\n    *node = *next;\n    // Don't be that person that leaks memory.\n    delete next;\n}\n"})})]})}),"\n",(0,d.jsx)(n.h3,{id:"variant-2-stdunique_ptr",children:"Variant 2: std::unique_ptr"}),"\n",(0,d.jsx)(n.p,{children:'Instead of calling delete on the "next" node, we can also use std::unique_ptr which take owner ship of the node we want to delete. As soon as this std::unique_ptr goes out of scope it will delete the owned node. This approach has the benefit if we have a function with multiple returns the object will be destroyed, i.e. we can not forget to call delete on it.'}),"\n",(0,d.jsx)(l,{children:(0,d.jsxs)(o,{value:"cpp",label:"C++",children:[(0,d.jsx)(t,{name:"@heder"}),(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"static void deleteNode(ListNode* node) {\n    std::unique_ptr<ListNode> to_be_deleted(node->next);\n    *node = *node->next;\n}\n"})})]})}),"\n",(0,d.jsx)(n.h3,{id:"variant-3-stdexchange-just-for-fun-not-recommended",children:"Variant 3: std::exchange (just for fun, not recommended)"}),"\n",(0,d.jsx)(n.p,{children:"With std::exchange we can turn approach 1 into a oneliner. I don't recommend actually doing this."}),"\n",(0,d.jsx)(l,{children:(0,d.jsxs)(o,{value:"cpp",label:"C++",children:[(0,d.jsx)(t,{name:"@heder"}),(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"static void deleteNode(ListNode* node) {\n    delete std::exchange(*node, *node->next).next;\n}\n"})})]})}),"\n",(0,d.jsx)(n.h3,{id:"appendix-looking-at-the-generated-assembly",children:"Appendix: Looking at the generated assembly"}),"\n",(0,d.jsxs)(n.p,{children:["Just for fun I looked the generated assembly ",(0,d.jsx)(n.a,{href:"https://godbolt.org/z/WPz1cW98x",children:"(using clang x86-64 (trunk))"})]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"deleteNode(ListNode*):               # @deleteNode(ListNode*)\nmov     rax, qword ptr [rdi + 8]\nvmovups xmm0, xmmword ptr [rax]\nvmovups xmmword ptr [rdi], xmm0\nmov     rdi, rax\njmp     operator delete(void*)@PLT                      # TAILCALL\n"})}),"\n",(0,d.jsx)(n.p,{children:"Variant 2: Is exactly the same as Variant 1"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"deleteNode(ListNode*):               # @deleteNode(ListNode*)\n        mov     rax, qword ptr [rdi + 8]\n        vmovups xmm0, xmmword ptr [rax]\n        vmovups xmmword ptr [rdi], xmm0\n        mov     rdi, rax\n        jmp     operator delete(void*)@PLT                      # TAILCALL\n"})}),"\n",(0,d.jsx)(n.p,{children:"... and it looks like clang can see through all of this, and Variant 3 generates the same code as well:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"deleteNode(ListNode*):               # @deleteNode(ListNode*)\n        mov     rax, qword ptr [rdi + 8]\n        vmovups xmm0, xmmword ptr [rax]\n        vmovups xmmword ptr [rdi], xmm0\n        mov     rdi, rax\n        jmp     operator delete(void*)@PLT                      # TAILCALL\n"})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(h,{...e})}):h(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},40629:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var o=t(30758);const d={},i=o.createContext(d);function l(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:l(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);