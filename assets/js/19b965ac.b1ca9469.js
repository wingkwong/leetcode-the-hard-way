"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[23997],{55191(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>m});var a=n(9346),r=(n(37953),n(58860));const o={description:"Author: @wkw, @iraycd | https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/",tags:["Array","Stack","Greedy","Sorting","Monotonic Stack"]},s="1996 - The Number of Weak Characters in the Game (Medium)",i={unversionedId:"1900-1999/the-number-of-weak-characters-in-the-game-medium",id:"1900-1999/the-number-of-weak-characters-in-the-game-medium",title:"1996 - The Number of Weak Characters in the Game (Medium)",description:"Author: @wkw, @iraycd | https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/",source:"@site/solutions/1900-1999/1996-the-number-of-weak-characters-in-the-game-medium.md",sourceDirName:"1900-1999",slug:"/1900-1999/the-number-of-weak-characters-in-the-game-medium",permalink:"/solutions/1900-1999/the-number-of-weak-characters-in-the-game-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1900-1999/1996-the-number-of-weak-characters-in-the-game-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Stack",permalink:"/solutions/tags/stack"},{label:"Greedy",permalink:"/solutions/tags/greedy"},{label:"Sorting",permalink:"/solutions/tags/sorting"},{label:"Monotonic Stack",permalink:"/solutions/tags/monotonic-stack"}],version:"current",sidebarPosition:1996,frontMatter:{description:"Author: @wkw, @iraycd | https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/",tags:["Array","Stack","Greedy","Sorting","Monotonic Stack"]},sidebar:"tutorialSidebar",previous:{title:"1992 - Find All Groups of Farmland (Medium)",permalink:"/solutions/1900-1999/find-all-groups-of-farmland-medium"},next:{title:"2000 - 2099",permalink:"/solutions/category/2000---2099"}},c={},m=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Hash Map",id:"approach-1-hash-map",level:2},{value:"Approach 2: Sort with custom comparator",id:"approach-2-sort-with-custom-comparator",level:2}],p=(l="SolutionAuthor",function(e){return console.warn("Component "+l+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.yg)("div",e)});var l;const h={toc:m};function u({components:e,...t}){return(0,r.yg)("wrapper",(0,a.A)({},h,t,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"1996---the-number-of-weak-characters-in-the-game-medium"},"1996 - The Number of Weak Characters in the Game (Medium)"),(0,r.yg)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.yg)("p",null,"You are playing a game that contains multiple characters, and each of the characters has ",(0,r.yg)("strong",{parentName:"p"},"two")," main properties: ",(0,r.yg)("strong",{parentName:"p"},"attack")," and ",(0,r.yg)("strong",{parentName:"p"},"defense"),". You are given a 2D integer array ",(0,r.yg)("inlineCode",{parentName:"p"},"properties")," where ",(0,r.yg)("inlineCode",{parentName:"p"},"properties[i] = [attacki, defensei]")," represents the properties of the ",(0,r.yg)("inlineCode",{parentName:"p"},"ith")," character in the game."),(0,r.yg)("p",null,"A character is said to be ",(0,r.yg)("strong",{parentName:"p"},"weak")," if any other character has ",(0,r.yg)("strong",{parentName:"p"},"both")," attack and defense levels ",(0,r.yg)("strong",{parentName:"p"},"strictly greater")," than this character's attack and defense levels. More formally, a character ",(0,r.yg)("inlineCode",{parentName:"p"},"i")," is said to be ",(0,r.yg)("strong",{parentName:"p"},"weak")," if there exists another character ",(0,r.yg)("inlineCode",{parentName:"p"},"j")," where ",(0,r.yg)("inlineCode",{parentName:"p"},"attackj > attacki")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"defensej > defensei"),"."),(0,r.yg)("p",null,"Return ",(0,r.yg)("em",{parentName:"p"},"the number of ",(0,r.yg)("strong",{parentName:"em"},"weak")," characters"),"."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 1:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: properties = [[5,5],[6,3],[3,6]]\nOutput: 0\nExplanation: No character has strictly greater attack and defense than the other.\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 2:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: properties = [[2,2],[3,3]]\nOutput: 1\nExplanation: The first character is weak because the second character has a strictly greater attack and defense.\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 3:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: properties = [[1,5],[10,4],[4,3]]\nOutput: 1\nExplanation: The third character is weak because the second character has a strictly greater attack and defense.\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Constraints:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"2 <= properties.length <= 1e5")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"properties[i].length == 2")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"1 <= attacki, defensei <= 1e5"))),(0,r.yg)("h2",{id:"approach-1-hash-map"},"Approach 1: Hash Map"),(0,r.yg)(p,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    // the idea is to\n    // 1. rearrange the order of attack and defense\n    // 2. count weak characters (those defenses less than the current maximum defense)\n    // 3. update the maximum defense\n    int numberOfWeakCharacters(vector<vector<int>>& p) {\n        // the final answer to be returned\n        int weakCharacters = 0;\n        // record maximum defense. since 1 <= defense_i <= 10 ^ 5\n        // we can set the init value to x where x < 1\n        int maxDefense = 0;\n        // use a hash map to map the attack and defense with greater<int> as a key_compare\n        map<int, vector<int>, greater<int>> m;\n        for(auto x : p) m[x[0]].push_back(x[1]);\n        // for each attack\n        for(auto x : m) {\n            // we count the number of weak characters\n            // and add it to `weakCharacters`\n            weakCharacters += count_if(x.second.begin(), x.second.end(), [&](int curDefense){ return curDefense < maxDefense;});\n            // then update `maxDefense` which is the maximum value in current defenses\n            maxDefense = max(maxDefense, *max_element(x.second.begin(), x.second.end()));\n        }\n        return weakCharacters;\n    }\n};\n")),(0,r.yg)("h2",{id:"approach-2-sort-with-custom-comparator"},"Approach 2: Sort with custom comparator"),(0,r.yg)(p,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    // the idea is to\n    // 1. rearrange the order of attack and defense\n    // 2. count weak characters (those defenses less than the current maximum defense)\n    // 3. update the maximum defense\n    int numberOfWeakCharacters(vector<vector<int>>& p) {\n        // the final answer to be returned\n        int weakCharacters = 0;\n        // record maximum defense. since 1 <= defense_i <= 10 ^ 5\n        // we can set the init value to x where x < 1\n        int maxDefense = 0;\n        // sort properties with custom sort comparator\n        sort(p.begin(), p.end(), [](const vector<int>& x, const vector<int>& y) {\n            // if the attack is same, then sort defense in ascending order\n            // otherwise, sort attack in in descending order\n           return x[0] == y[0] ? x[1] < y[1] : x[0] > y[0];\n        });\n        // by doing so, we don't need to compare starting from the back\n        for (auto& x : p) {\n            // x[1] is defense of properties[i]\n            // if it is less than current maxDefense, then it means it is a weak character\n            weakCharacters += x[1] < maxDefense;\n            // update maxDefense\n            maxDefense = max(maxDefense, x[1]);\n        }\n        return weakCharacters;\n    }\n};\n")),(0,r.yg)(p,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    # the idea is to\n    # 1. rearrange the order of attack and defense\n    # 2. count weak characters (those defenses less than the current maximum defense)\n    # 3. update the maximum defense\n    def numberOfWeakCharacters(self, p: List[List[int]]) -> int:\n        # the final answer to be returned\n        weakCharacters = 0\n        # record maximum defense. since 1 <= defense_i <= 10 ^ 5\n        # we can set the init value to x where x < 1\n        maxDefense = 0\n        # sort properties with custom sort comparator\n        # if the attack is same, then sort defense in descending order\n        # otherwise, sort attack in in ascending order\n        p.sort(key = lambda x: (x[0], -x[1]), reverse = True)\n        # or we can do it like\n        # p.sort(key = lambda x: (-x[0], x[1]))\n        for _, defense in p:\n            # if it is less than current maxDefense, then it means it is a weak character\n            if defense < maxDefense: weakCharacters += 1\n            # update maxDefense\n            else: maxDefense = defense\n        return weakCharacters\n")),(0,r.yg)(p,{name:"@iraycd",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-golang"},"// the idea is to\n// 1. rearrange the order of attack and defense\n// 2. count weak characters (those defenses less than the current maximum defense)\n// 3. update the maximum defense\nfunc numberOfWeakCharacters(properties [][]int) int {\n\n    // Weak starts at 0, this is the variable which is going to be returned\n    weekCharacterCount := 0\n    maxDefence := 0\n\n    // Sorting the order of the desending order of the attack\n    sort.Sort(ByAttack(properties))\n    for _, elem := range properties {\n        // Appending the count if the current element is less than the max defense\n        // Else change the max defence\n        if(elem[1] < maxDefence){\n            weekCharacterCount++;\n        }else {\n            maxDefence = elem[1]\n        }\n    }\n    return weekCharacterCount\n}\n\n// Custom sorting Logic by attack\ntype ByAttack [][]int\nfunc (a ByAttack) Len() int           { return len(a) }\nfunc (a ByAttack) Less(i, j int) bool {\n    if(a[i][0] == a[j][0]){\n        return a[i][1] < a[j][1]\n    }\n    return a[i][0] > a[j][0]\n}\nfunc (a ByAttack) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\n")))}u.isMDXComponent=!0},58860(e,t,n){n.d(t,{xA:()=>p,yg:()=>u});var a=n(37953);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),m=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=m(e.components);return a.createElement(c.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef(function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),h=m(n),u=r,d=h["".concat(c,".").concat(u)]||h[u]||l[u]||o;return n?a.createElement(d,s(s({ref:t},p),{},{components:n})):a.createElement(d,s({ref:t},p))});function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var m=2;m<o;m++)s[m]=n[m];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);