"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[68328],{18062:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>h,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"1800-1899/minimum-interval-to-include-each-query-hard","title":"1851 - Minimum Interval to Include Each Query","description":"Author: @ColeB2 | https://leetcode.com/problems/minimum-interval-to-include-each-query/","source":"@site/solutions/1800-1899/1851-minimum-interval-to-include-each-query-hard.md","sourceDirName":"1800-1899","slug":"/1800-1899/minimum-interval-to-include-each-query-hard","permalink":"/solutions/1800-1899/minimum-interval-to-include-each-query-hard","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1800-1899/1851-minimum-interval-to-include-each-query-hard.md","tags":[{"inline":true,"label":"Array","permalink":"/solutions/tags/array"},{"inline":true,"label":"Binary Search","permalink":"/solutions/tags/binary-search"},{"inline":true,"label":"Line Sweep","permalink":"/solutions/tags/line-sweep"},{"inline":true,"label":"Sorting","permalink":"/solutions/tags/sorting"},{"inline":true,"label":"Heap (Priority Queue)","permalink":"/solutions/tags/heap-priority-queue"}],"version":"current","sidebarPosition":1851,"frontMatter":{"description":"Author: @ColeB2 | https://leetcode.com/problems/minimum-interval-to-include-each-query/","tags":["Array","Binary Search","Line Sweep","Sorting","Heap (Priority Queue)"]},"sidebar":"tutorialSidebar","previous":{"title":"1833 - Maximum Ice Cream Bars (Medium)","permalink":"/solutions/1800-1899/maximum-ice-cream-bars-medium"},"next":{"title":"1854 - Maximum Population Year (Easy)","permalink":"/solutions/1800-1899/maximum-population-year-easy"}}');var i=a(74848),t=a(28453);const r={description:"Author: @ColeB2 | https://leetcode.com/problems/minimum-interval-to-include-each-query/",tags:["Array","Binary Search","Line Sweep","Sorting","Heap (Priority Queue)"]},l="1851 - Minimum Interval to Include Each Query",h={},o=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Heap / Sorting",id:"approach-1-heap--sorting",level:2}];function m(e){const s={a:"a",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,t.R)(),...e.components},{SolutionAuthor:a,TabItem:n,Tabs:r}=s;return a||d("SolutionAuthor",!0),n||d("TabItem",!0),r||d("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"1851---minimum-interval-to-include-each-query",children:"1851 - Minimum Interval to Include Each Query"})}),"\n",(0,i.jsx)(s.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.a,{href:"https://leetcode.com/problems/minimum-interval-to-include-each-query/",children:"https://leetcode.com/problems/minimum-interval-to-include-each-query/"})}),"\n",(0,i.jsx)(s.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(s.p,{children:["You are given a 2D integer array ",(0,i.jsx)(s.code,{children:"intervals"}),", where ",(0,i.jsx)(s.code,{children:"intervals[i] = [lefti, righti]"})," describes the ",(0,i.jsx)(s.code,{children:"ith"})," interval starting at ",(0,i.jsx)(s.code,{children:"lefti"})," and ending at ",(0,i.jsx)(s.code,{children:"righti"})," (",(0,i.jsx)(s.strong,{children:"inclusive"}),"). The ",(0,i.jsx)(s.strong,{children:"size"})," of an interval is defined as the number of integers it contains, or more formally ",(0,i.jsx)(s.code,{children:"righti - lefti + 1"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["You are also given an integer array ",(0,i.jsx)(s.code,{children:"queries"}),". The answer to the ",(0,i.jsx)(s.code,{children:"jth"})," query is the ",(0,i.jsx)(s.strong,{children:"size of the smallest interval"})," ",(0,i.jsx)(s.code,{children:"i"})," such that ",(0,i.jsx)(s.code,{children:"lefti <= queries[j] <= righti"}),". If no such interval exists, the answer is ",(0,i.jsx)(s.code,{children:"-1"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Return ",(0,i.jsx)(s.em,{children:"an array containing the answers to the queries"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]\nOutput: [3,3,1,4]\nExplanation: The queries are processed as follows:\n- Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.\n- Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.\n- Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.\n- Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"Input: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]\nOutput: [2,-1,4,6]\nExplanation: The queries are processed as follows:\n- Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.\n- Query = 19: None of the intervals contain 19. The answer is -1.\n- Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.\n- Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"1 <= intervals.length <= 10^5"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"1 <= queries.length <= 10^5"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"intervals[i].length == 2"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"1 <= lefti <= righti <= 10^7"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"1 <= queries[j] <= 10^7"})}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"approach-1-heap--sorting",children:"Approach 1: Heap / Sorting"}),"\n",(0,i.jsx)(s.p,{children:"A heap combined with sorted queries will allow us to store intervals based on the size of the interval as well as discard intervals that no longer fit the query, and since the queries will be sorted, we know every subsequent query will also not fit that interval."}),"\n",(0,i.jsx)(s.p,{children:"If intervals are also sorted, we can also fill our heap up with intervals that only fit the current query, and only ever add to our heap, when the query we are looking at, fits inside the interval. This will minimize heap operation time as well."}),"\n",(0,i.jsx)(s.p,{children:"Finally, since we are going to look through our queries after we sort them, we will need a hash map to map our queries back to the proper index in the return array, otherwise, we will have the correct answer, but in the improper order."}),"\n",(0,i.jsxs)(s.p,{children:["Time Complexity: ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"O"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mi,{children:"N"}),(0,i.jsx)(s.mi,{children:"l"}),(0,i.jsx)(s.mi,{children:"o"}),(0,i.jsx)(s.mi,{children:"g"}),(0,i.jsx)(s.mi,{children:"N"}),(0,i.jsx)(s.mo,{children:"+"}),(0,i.jsx)(s.mi,{children:"Q"}),(0,i.jsx)(s.mi,{children:"l"}),(0,i.jsx)(s.mi,{children:"o"}),(0,i.jsx)(s.mi,{children:"g"}),(0,i.jsx)(s.mi,{children:"Q"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(NlogN + QlogQ)"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(s.span,{className:"mopen",children:"("}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"Nl"}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"o"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(s.span,{className:"mbin",children:"+"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"Ql"}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"o"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"Q"}),(0,i.jsx)(s.span,{className:"mclose",children:")"})]})]})]})," where ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsx)(s.mrow,{children:(0,i.jsx)(s.mi,{children:"N"})}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"N"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"})]})})]})," is intervals.length and ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsx)(s.mrow,{children:(0,i.jsx)(s.mi,{children:"Q"})}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"Q"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.8778em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"Q"})]})})]})," is queries.length. The sorting of the intervals and queries array will be the dominant time factor. Other than that we will loop through each query twice (once in our initial algorithm and again at the end to map our queries back to their proper index) and through our intervals array once. Our heap operations will happen in ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"l"}),(0,i.jsx)(s.mi,{children:"o"}),(0,i.jsx)(s.mi,{children:"g"}),(0,i.jsx)(s.mi,{children:"h"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"logh"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"o"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"h"})]})})]})," time, where h is the size of the heap, which will max out at ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"l"}),(0,i.jsx)(s.mi,{children:"o"}),(0,i.jsx)(s.mi,{children:"g"}),(0,i.jsx)(s.mi,{children:"N"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"logN"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"o"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"})]})})]})," time."]}),"\n",(0,i.jsxs)(s.p,{children:["Space Complexity: ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"O"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mi,{children:"N"}),(0,i.jsx)(s.mo,{children:"+"}),(0,i.jsx)(s.mi,{children:"Q"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(N + Q)"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(s.span,{className:"mopen",children:"("}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(s.span,{className:"mbin",children:"+"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"Q"}),(0,i.jsx)(s.span,{className:"mclose",children:")"})]})]})]}),". We are going to create a heap which will be of size ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsx)(s.mrow,{children:(0,i.jsx)(s.mi,{children:"N"})}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"N"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"})]})})]})," in the worst case. We are going to create a hash map, (",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsx)(s.mrow,{children:(0,i.jsx)(s.mi,{children:"Q"})}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"Q"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.8778em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"Q"})]})})]}),") to map our queries back to their proper position in the return array as well as loop through a sorted array of queries, ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsx)(s.mrow,{children:(0,i.jsx)(s.mi,{children:"Q"})}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"Q"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.8778em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"Q"})]})})]}),"."]}),"\n",(0,i.jsx)(r,{children:(0,i.jsxs)(n,{value:"python",label:"Python",children:[(0,i.jsx)(a,{name:"@ColeB2"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-py",children:"class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        # reverse sort our intervals, to simplify our loop, by allowing\n        # us to just pop the smallest intervals instead.\n        intervals.sort(reverse=True)\n        # initialize our heap and query map. The heap will contain our\n        # interval size, and the right boundary (right-left+ 1, right)\n        heap = []\n        # query map will map our queries to the size of the interval they\n        # fit inside. We need to map them, so when we loop back over\n        # queries at the end, we can get the answers in O(1) time and\n        # maintain the original order.\n        query_map = {}\n        # loop through all the queries in sorted order. sorted(queries)\n        # will create an array of queries that is sorted, and won't touch\n        # the original queries array.\n        for q in sorted(queries):\n            # while we still have intervals, and the smallest intervals\n            # left value is <= the current query.\n            while intervals and intervals[-1][0] <= q:\n                # pop this interval\n                left, right = intervals.pop()\n                # make sure that right is larger than the query. If it\n                # is smaller it won't fit, and since we are looping \n                # through the queries in sorted order, all subsequent\n                # queries won't fit this interval either.\n                if right >= q:\n                    # push the size and right boundary to the heap.\n                    heapq.heappush(heap, (right - left + 1, right))\n            # Pop all intervals that our query no longer fits inside. That\n            # is pop any interval where the query is larger than the right\n            # boundary.\n            while heap and heap[0][1] < q:\n                heapq.heappop(heap)\n            # Once we popped all smaller intervals, if the interval\n            # exists, we can map the query value to that interval size.\n            query_map[q] = heap[0][0] if heap else -1\n        # rebuild our answer array, our queries array is untouched, so by\n        # looping it, and getting the value we stored in our hash map for\n        # that query we can create out answer in O(Q) time.\n        return [query_map[q] for q in queries]\n"})})]})})]})}function c(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}function d(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453:(e,s,a)=>{a.d(s,{R:()=>r,x:()=>l});var n=a(96540);const i={},t=n.createContext(i);function r(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);