"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[72746],{34058:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"2400-2499/optimal-partition-of-string-medium","title":"2405 - Optimal Partition of String (Medium)","description":"Author: @wkw | https://leetcode.com/problems/optimal-partition-of-string/","source":"@site/solutions/2400-2499/2405-optimal-partition-of-string-medium.md","sourceDirName":"2400-2499","slug":"/2400-2499/optimal-partition-of-string-medium","permalink":"/solutions/2400-2499/optimal-partition-of-string-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2400-2499/2405-optimal-partition-of-string-medium.md","tags":[],"version":"current","sidebarPosition":2405,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/optimal-partition-of-string/"},"sidebar":"tutorialSidebar","previous":{"title":"2404 - Most Frequent Even Element (Easy)","permalink":"/solutions/2400-2499/most-frequent-even-element-easy"},"next":{"title":"2406 - Divide Intervals Into Minimum Number of Groups (Medium)","permalink":"/solutions/2400-2499/divide-intervals-into-minimum-number-of-groups-medium"}}');var r=t(86070),o=t(32790);const s={description:"Author: @wkw | https://leetcode.com/problems/optimal-partition-of-string/"},a="2405 - Optimal Partition of String (Medium)",c={},l=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Greedy",id:"approach-1-greedy",level:2}];function u(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{SolutionAuthor:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("SolutionAuthor",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"2405---optimal-partition-of-string-medium",children:"2405 - Optimal Partition of String (Medium)"})}),"\n",(0,r.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,r.jsxs)(n.p,{children:["Given a string ",(0,r.jsx)(n.code,{children:"s"}),", partition the string into one or more ",(0,r.jsx)(n.strong,{children:"substrings"})," such that the characters in each substring are ",(0,r.jsx)(n.strong,{children:"unique"}),". That is, no letter appears in a single substring more than ",(0,r.jsx)(n.strong,{children:"once"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Return ",(0,r.jsxs)(n.em,{children:["the ",(0,r.jsx)(n.strong,{children:"minimum"})," number of substrings in such a partition."]})]}),"\n",(0,r.jsx)(n.p,{children:"Note that each character should belong to exactly one substring in a partition."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Input: s = "abacaba"\nOutput: 4\nExplanation:\nTwo possible partitions are ("a","ba","cab","a") and ("ab","a","ca","ba").\nIt can be shown that 4 is the minimum number of substrings needed.\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Input: s = "ssssss"\nOutput: 6\nExplanation:\nThe only valid partition is ("s","s","s","s","s","s").\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"1 <= s.length <= 1e5"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"s"})," consists of only English lowercase letters."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"approach-1-greedy",children:"Approach 1: Greedy"}),"\n",(0,r.jsx)(t,{name:"@wkw"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    // the idea is to keep each partition as long as possible\n    // so that we could have the minimum number of substrings\n    int partitionString(string s) {\n        // the minimum number of substring is at least 1\n        // e.g. \"a\"\n        int ans = 1;\n        // cnt is used to count the frequency of each character\n        vector<int> cnt(26);\n        // for each character\n        for (auto& c : s) {\n            // we check if it exists before\n            // if so, then we should create a new partition\n            // because no letter appears in a single substring more than once\n            if (cnt[c - 'a']) {\n                // reset the counter\n                cnt = vector<int>(26);\n                // create a new partition\n                ans++;\n            }\n            // increase the frequency of the current character by 1\n            cnt[c - 'a']++;\n        }\n        return ans;\n    }\n};\n"})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},32790:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(30758);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);