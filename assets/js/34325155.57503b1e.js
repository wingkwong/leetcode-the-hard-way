"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[98585],{72082:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"0900-0999/subarray-sums-divisible-by-k-medium","title":"0974 - Subarray Sums Divisible by K (Medium)","description":"Author: @wingkwong | https://leetcode.com/problems/subarray-sums-divisible-by-k/","source":"@site/solutions/0900-0999/0974-subarray-sums-divisible-by-k-medium.md","sourceDirName":"0900-0999","slug":"/0900-0999/subarray-sums-divisible-by-k-medium","permalink":"/solutions/0900-0999/subarray-sums-divisible-by-k-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0974-subarray-sums-divisible-by-k-medium.md","tags":[{"inline":true,"label":"Array","permalink":"/solutions/tags/array"},{"inline":true,"label":"Hash Table","permalink":"/solutions/tags/hash-table"},{"inline":true,"label":"Prefix Sum","permalink":"/solutions/tags/prefix-sum"}],"version":"current","sidebarPosition":974,"frontMatter":{"description":"Author: @wingkwong | https://leetcode.com/problems/subarray-sums-divisible-by-k/","tags":["Array","Hash Table","Prefix Sum"]},"sidebar":"tutorialSidebar","previous":{"title":"0973 - K Closest Points to Origin (Medium)","permalink":"/solutions/0900-0999/k-closest-points-to-origin-medium"},"next":{"title":"0976 - Largest Perimeter Triangle (Easy)","permalink":"/solutions/0900-0999/largest-perimeter-triangle-easy"}}');var s=i(74848),t=i(28453);const a={description:"Author: @wingkwong | https://leetcode.com/problems/subarray-sums-divisible-by-k/",tags:["Array","Hash Table","Prefix Sum"]},o="0974 - Subarray Sums Divisible by K (Medium)",l={},u=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Hash Map + Prefix Sum",id:"approach-1-hash-map--prefix-sum",level:2}];function p(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components},{SolutionAuthor:i,TabItem:r,Tabs:a}=n;return i||c("SolutionAuthor",!0),r||c("TabItem",!0),a||c("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"0974---subarray-sums-divisible-by-k-medium",children:"0974 - Subarray Sums Divisible by K (Medium)"})}),"\n",(0,s.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,s.jsxs)(n.p,{children:["Given an integer array ",(0,s.jsx)(n.code,{children:"nums"})," and an integer ",(0,s.jsx)(n.code,{children:"k"}),", return ",(0,s.jsxs)(n.em,{children:["the number of non-empty ",(0,s.jsx)(n.strong,{children:"subarrays"})," that have a sum divisible by"]}),(0,s.jsx)(n.code,{children:"k"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"subarray"})," is a ",(0,s.jsx)(n.strong,{children:"contiguous"})," part of an array."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Input: nums = [4,5,0,-2,-3,1], k = 5\nOutput: 7\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Input: nums = [5], k = 9\nOutput: 0\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"1 <= nums.length <= 3 * 10^4"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"-10^4 <= nums[i] <= 10^4"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"2 <= k <= 10^4"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"approach-1-hash-map--prefix-sum",children:"Approach 1: Hash Map + Prefix Sum"}),"\n",(0,s.jsxs)(a,{children:[(0,s.jsxs)(r,{value:"cpp",label:"C++",children:[(0,s.jsx)(i,{name:"@wingkwong"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    vector<int> generatePrefixSum(vector<int>& a) {\n        int n = a.size();\n        vector<int> pref(n);\n        pref[0] = a[0];\n        for (int i = 1; i < n; i++) pref[i] = pref[i - 1] + a[i];\n        return pref;\n    }\n\n    int subarraysDivByK(vector<int>& nums, int k) {\n        // generate prefix sum\n        vector<int> pref = generatePrefixSum(nums);\n        // store the modular cnt\n        vector<int> m(k);\n        // base value\n        m[0] = 1;\n        // init ans\n        int ans = 0;\n        // iterate each sum\n        for (auto& x : pref) {\n            // if x is negative, turn it to positive modular equivalent\n            if (x < 0) x = (x % k + k) % k;\n            // we need to find pairs such that (pref[j] - pref[i]) % k == 0\n            // hence, we look for pref[j] % k == pref[i] % k\n            // why ..? \n            // pref[j] = a * k + x\n            // pref[i] = b * k + y\n            // pref[j] - pref[i] = (a * k + x) - (b * k + y)\n            // pref[j] - pref[i] = k * (a - b) + (x - y)\n            // -> (pref[j] - pref[i]) % k == 0 if & only if (x - y) == 0\n            m[x % k]++;\n        }\n        // n choose 2\n        for (auto& x : m) ans += x * (x - 1) / 2;\n        return ans;\n    }\n};\n"})})]}),(0,s.jsxs)(r,{value:"java",label:"Java",children:[(0,s.jsx)(i,{name:"@wingkwong"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"class Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        // generate prefix sum\n        int[] pref = new int[nums.length];\n        pref[0] = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            pref[i] = pref[i - 1] + nums[i];\n        }\n        // store the modular cnt\n        int[] m = new int[k];\n        // base value\n        m[0] = 1;\n        // init ans\n        int ans = 0;\n        // iterate each sum\n        for (int x : pref) {\n            // if x is negative, turn it to positive modular equivalent\n            if (x < 0) {\n                x = (x % k + k) % k;\n            }\n            // we need to find pairs such that (pref[j] - pref[i]) % k == 0\n            // hence, we look for pref[j] % k == pref[i] % k\n            // why ..? \n            // pref[j] = a * k + x\n            // pref[i] = b * k + y\n            // pref[j] - pref[i] = (a * k + x) - (b * k + y)\n            // pref[j] - pref[i] = k * (a - b) + (x - y)\n            // -> (pref[j] - pref[i]) % k == 0 if & only if (x - y) == 0\n            m[x % k]++;\n        }\n        // n choose 2\n        for (int x : m) {\n            ans += x * (x - 1) / 2;\n        }\n        return ans;\n    }\n}\n\n"})})]}),(0,s.jsxs)(r,{value:"py",label:"Python",children:[(0,s.jsx)(i,{name:"@wingkwong"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:"class Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        # generate prefix sum\n        pref = [0] * len(nums)\n        pref[0] = nums[0]\n        for i in range(1, len(nums)):\n            pref[i] = pref[i-1] + nums[i]\n        \n        # store the modular cnt\n        m = [0] * k\n        # base value\n        m[0] = 1\n        # init ans\n        ans = 0\n        # iterate each sum\n        for x in pref:\n            # we don't need the following logic as Python handles it internally \n            # if x is negative, turn it to positive modular equivalent\n            # if x < 0:\n            #     x = (x % k + k) % k\n            # we need to find pairs such that (pref[j] - pref[i]) % k == 0\n            # hence, we look for pref[j] % k == pref[i] % k\n            # why ..? \n            # pref[j] = a * k + x\n            # pref[i] = b * k + y\n            # pref[j] - pref[i] = (a * k + x) - (b * k + y)\n            # pref[j] - pref[i] = k * (a - b) + (x - y)\n            # -> (pref[j] - pref[i]) % k == 0 if & only if (x - y) == 0\n            m[x % k] += 1\n        # n choose 2\n        for x in m:\n            ans += x * (x - 1) // 2\n        return ans\n"})})]}),(0,s.jsxs)(r,{value:"rs",label:"Rust",children:[(0,s.jsx)(i,{name:"@wingkwong"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rs",children:"impl Solution {\n    pub fn subarrays_div_by_k(nums: Vec<i32>, k: i32) -> i32 {\n        // generate prefix sum\n        let mut pref = vec![0; nums.len()];\n        pref[0] = nums[0];\n        for i in 1 .. nums.len() {\n            pref[i] = pref[i - 1] + nums[i];\n        }\n        // store the modular cnt\n        let mut m = vec![0; k as usize];\n        // base value\n        m[0] = 1;\n        // init ans\n        let mut ans = 0;\n        // iterate each sum\n        for x in pref.iter_mut() {\n            // if x is negative, turn it to positive modular equivalent\n            if *x < 0 {\n                *x = (*x % k + k) % k;\n            }\n            // we need to find pairs such that (pref[j] - pref[i]) % k == 0\n            // hence, we look for pref[j] % k == pref[i] % k\n            // why ..? \n            // pref[j] = a * k + x\n            // pref[i] = b * k + y\n            // pref[j] - pref[i] = (a * k + x) - (b * k + y)\n            // pref[j] - pref[i] = k * (a - b) + (x - y)\n            // -> (pref[j] - pref[i]) % k == 0 if & only if (x - y) == 0\n            m[(*x % k) as usize] += 1;\n        }\n        // n choose 2\n        for x in m {\n            ans += x * (x - 1) / 2;\n        }\n        ans\n    }\n}\n\n"})})]})]})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}function c(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var r=i(96540);const s={},t=r.createContext(s);function a(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);