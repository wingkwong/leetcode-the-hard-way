"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[34587],{54678(e,t,n){n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>o,default:()=>N,frontMatter:()=>i,metadata:()=>s,suggestedProblems:()=>p,toc:()=>l});var a=n(9346),r=(n(37953),n(58860));const i={title:"Kruskal's Algorithm",description:"Kruskal's algorithm is a greedy algorithm used to find the minimum spanning tree of a connected, undirected graph.",keywords:["leetcode","tutorial","kruskals","algorithm"]},o=void 0,s={unversionedId:"graph-theory/kruskals-algorithm",id:"graph-theory/kruskals-algorithm",title:"Kruskal's Algorithm",description:"Kruskal's algorithm is a greedy algorithm used to find the minimum spanning tree of a connected, undirected graph.",source:"@site/tutorials/graph-theory/kruskals-algorithm.md",sourceDirName:"graph-theory",slug:"/graph-theory/kruskals-algorithm",permalink:"/tutorials/graph-theory/kruskals-algorithm",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/graph-theory/kruskals-algorithm.md",tags:[],version:"current",frontMatter:{title:"Kruskal's Algorithm",description:"Kruskal's algorithm is a greedy algorithm used to find the minimum spanning tree of a connected, undirected graph.",keywords:["leetcode","tutorial","kruskals","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Kahn's Algorithm",permalink:"/tutorials/graph-theory/kahns-algorithm"},next:{title:"Lowest Common Ancestor(LCA)",permalink:"/tutorials/graph-theory/lca"}},m={},l=[{value:"Overview",id:"overview",level:2},{value:"Implementation",id:"implementation",level:4}],p=[{problemName:"1135 - Connecting Cities With Minimum Cost",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/connecting-cities-with-minimum-cost/",solutionLink:"../../solutions/1100-1199/connecting-cities-with-minimum-cost-medium"},{problemName:"1168 - Optimize Water Distribution in a Village",difficulty:"Hard",leetCodeLink:"https://leetcode.com/problems/optimize-water-distribution-in-a-village/",solutionLink:"../../solutions/1100-1199/optimize-water-distribution-in-a-village-hard"}],g=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.yg)("div",t)},c=g("TutorialCredits"),h=g("Tabs"),u=g("TabItem"),d=g("SolutionAuthor"),y=g("Table"),f={toc:l,suggestedProblems:p};function N({components:e,...t}){return(0,r.yg)("wrapper",(0,a.A)({},f,t,{components:e,mdxType:"MDXLayout"}),(0,r.yg)(c,{authors:"@wkw",mdxType:"TutorialCredits"}),(0,r.yg)("h2",{id:"overview"},"Overview"),(0,r.yg)("p",null,"Kruskal's algorithm is a greedy algorithm used to find the minimum spanning tree of a connected, undirected graph. The algorithm starts with each vertex in its own separate connected component, and iteratively adds edges to the MST in increasing order of weight, while ensuring that adding the edge does not form a cycle."),(0,r.yg)("p",null,"Here are the steps to find the MST using Kruskal's algorithm:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Sort all the edges in non-decreasing order of their weight."),(0,r.yg)("li",{parentName:"ol"},"Initialize the MST as an empty set."),(0,r.yg)("li",{parentName:"ol"},"For each edge in the sorted list of edges:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"If adding the edge does not form a cycle in the MST, add the edge to the MST."),(0,r.yg)("li",{parentName:"ul"},"Otherwise, discard the edge."))),(0,r.yg)("li",{parentName:"ol"},"Repeat steps 3 until all the vertices are included in the MST.")),(0,r.yg)("p",null,"The time complexity of Kruskal's algorithm is ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"O"),(0,r.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.yg)("mi",{parentName:"mrow"},"E"),(0,r.yg)("mi",{parentName:"mrow"},"l"),(0,r.yg)("mi",{parentName:"mrow"},"o"),(0,r.yg)("mi",{parentName:"mrow"},"g"),(0,r.yg)("mi",{parentName:"mrow"},"E"),(0,r.yg)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(E log E)")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.yg)("span",{parentName:"span",className:"mopen"},"("),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"El"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"o"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"g"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05764em"}},"E"),(0,r.yg)("span",{parentName:"span",className:"mclose"},")")))))," where ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"E")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"E")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05764em"}},"E")))))," is the number of edges in the graph. It is more efficient than Prim's algorithm when the number of edges is much larger than the number of vertices."),(0,r.yg)("h4",{id:"implementation"},"Implementation"),(0,r.yg)("admonition",{title:"Prerequisite",type:"info"},(0,r.yg)("ul",{parentName:"admonition"},(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"../graph-theory/disjoint-set-union"},"Disjoint Set Union")))),(0,r.yg)(h,{mdxType:"Tabs"},(0,r.yg)(u,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.yg)(d,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},"class dsu {\n public:\n  vector<int> root, rank;\n  int n;\n  int cnt;\n\n  dsu(int _n) : n(_n) {\n    root.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; i++) {\n        root[i] = i;\n        rank[i] = 1;\n    }\n    cnt = n;\n  }\n\n  inline int getCount() { return cnt; }\n\n  inline int get(int x) { return (x == root[x] ? x : (root[x] = get(root[x]))); }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n        if (rank[x] > rank[y]) {\n            root[y] = x;\n        } else if (rank[x] < rank[y]) {\n            root[x] = y;\n        } else {\n            root[y] = x;\n            rank[x] += 1;\n        }\n        cnt--;\n      return true;\n    }\n    return false;\n  }\n};\n\nint mst(vector<vector<int>>& g) {\n    int n = (int) g.size();\n    vector<array<int, 3>> edges;\n    // g[i] = {from, to, weight}\n    for (auto x : g) edges.push_back({x[2], x[0], x[1]});\n    sort(edges.begin(), edges.end());\n    dsu d(n + 1);\n    int minimum_weight = 0;\n    for (auto x : edges) {\n        if (d.unite(x[1], x[2])) {\n            minimum_weight += x[0];\n        }\n    }\n    return minimum_weight;\n}\n")))),(0,r.yg)(y,{title:"Suggested Problems",data:p,mdxType:"Table"}))}N.isMDXComponent=!0},58860(e,t,n){n.d(t,{xA:()=>p,yg:()=>h});var a=n(37953);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var m=a.createContext({}),l=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(m.Provider,{value:t},e.children)},g={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef(function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,m=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=l(n),h=r,u=c["".concat(m,".").concat(h)]||c[h]||g[h]||i;return n?a.createElement(u,o(o({ref:t},p),{},{components:n})):a.createElement(u,o({ref:t},p))});function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var s={};for(var m in t)hasOwnProperty.call(t,m)&&(s[m]=t[m]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);