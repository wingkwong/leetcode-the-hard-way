"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[10810],{58860(e,a,t){t.d(a,{xA:()=>l,yg:()=>c});var n=t(37953);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),t.push.apply(t,n)}return t}function m(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach(function(a){r(e,a,t[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))})}return e}function p(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=n.createContext({}),o=function(e){var a=n.useContext(i),t=a;return e&&(t="function"==typeof e?e(a):m(m({},a),e)),t},l=function(e){var a=o(e.components);return n.createElement(i.Provider,{value:a},e.children)},g={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},h=n.forwardRef(function(e,a){var t=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),h=o(t),c=r,d=h["".concat(i,".").concat(c)]||h[c]||g[c]||s;return t?n.createElement(d,m(m({ref:a},l),{},{components:t})):n.createElement(d,m({ref:a},l))});function c(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var s=t.length,m=new Array(s);m[0]=h;var p={};for(var i in a)hasOwnProperty.call(a,i)&&(p[i]=a[i]);p.originalType=e,p.mdxType="string"==typeof e?e:r,m[1]=p;for(var o=2;o<s;o++)m[o]=t[o];return n.createElement.apply(null,m)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"},74684(e,a,t){t.r(a),t.d(a,{assets:()=>i,contentTitle:()=>m,default:()=>c,frontMatter:()=>s,metadata:()=>p,toc:()=>o});var n=t(9346),r=(t(37953),t(58860));const s={description:"Author: @wkw | https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/"},m="2203 - Minimum Weighted Subgraph With the Required Paths (Hard)",p={unversionedId:"2100-2199/minimum-weighted-subgraph-with-the-required-paths-hard",id:"2100-2199/minimum-weighted-subgraph-with-the-required-paths-hard",title:"2203 - Minimum Weighted Subgraph With the Required Paths (Hard)",description:"Author: @wkw | https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/",source:"@site/solutions/2100-2199/2203-minimum-weighted-subgraph-with-the-required-paths-hard.md",sourceDirName:"2100-2199",slug:"/2100-2199/minimum-weighted-subgraph-with-the-required-paths-hard",permalink:"/solutions/2100-2199/minimum-weighted-subgraph-with-the-required-paths-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2100-2199/2203-minimum-weighted-subgraph-with-the-required-paths-hard.md",tags:[],version:"current",sidebarPosition:2203,frontMatter:{description:"Author: @wkw | https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/"},sidebar:"tutorialSidebar",previous:{title:"2202 - Maximize the Topmost Element After K Moves (Medium)",permalink:"/solutions/2100-2199/maximize-the-topmost-element-after-k-moves-medium"},next:{title:"2206 - Divide Array Into Equal Pairs (Easy)",permalink:"/solutions/2100-2199/divide-array-into-equal-pairs-easy"}},i={},o=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dijkstra x 3",id:"approach-1-dijkstra-x-3",level:2}],l=(g="SolutionAuthor",function(e){return console.warn("Component "+g+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.yg)("div",e)});var g;const h={toc:o};function c({components:e,...a}){return(0,r.yg)("wrapper",(0,n.A)({},h,a,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"2203---minimum-weighted-subgraph-with-the-required-paths-hard"},"2203 - Minimum Weighted Subgraph With the Required Paths (Hard)"),(0,r.yg)("h2",{id:"problem-link"},"Problem Link"),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/"},"https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/")),(0,r.yg)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.yg)("p",null,"You are given an integer ",(0,r.yg)("inlineCode",{parentName:"p"},"n")," denoting the number of nodes of a ",(0,r.yg)("strong",{parentName:"p"},"weighted directed")," graph. The nodes are numbered from ",(0,r.yg)("inlineCode",{parentName:"p"},"0")," to ",(0,r.yg)("inlineCode",{parentName:"p"},"n - 1"),"."),(0,r.yg)("p",null,"You are also given a 2D integer array ",(0,r.yg)("inlineCode",{parentName:"p"},"edges")," where ",(0,r.yg)("inlineCode",{parentName:"p"},"edges[i] = [fromi, toi, weighti]")," denotes that there exists a ",(0,r.yg)("strong",{parentName:"p"},"directed")," edge from ",(0,r.yg)("inlineCode",{parentName:"p"},"fromi")," to ",(0,r.yg)("inlineCode",{parentName:"p"},"toi")," with weight ",(0,r.yg)("inlineCode",{parentName:"p"},"weighti"),"."),(0,r.yg)("p",null,"Lastly, you are given three ",(0,r.yg)("strong",{parentName:"p"},"distinct")," integers ",(0,r.yg)("inlineCode",{parentName:"p"},"src1"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"src2"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"dest")," denoting three distinct nodes of the graph."),(0,r.yg)("p",null,"Return ",(0,r.yg)("em",{parentName:"p"},"the ",(0,r.yg)("strong",{parentName:"em"},"minimum weight")," of a subgraph of the graph such that it is ",(0,r.yg)("strong",{parentName:"em"},"possible")," to reach")," ",(0,r.yg)("inlineCode",{parentName:"p"},"dest")," ",(0,r.yg)("em",{parentName:"p"},"from both")," ",(0,r.yg)("inlineCode",{parentName:"p"},"src1")," ",(0,r.yg)("em",{parentName:"p"},"and")," ",(0,r.yg)("inlineCode",{parentName:"p"},"src2")," ",(0,r.yg)("em",{parentName:"p"},"via a set of edges of this subgraph"),". In case such a subgraph does not exist, return ",(0,r.yg)("inlineCode",{parentName:"p"},"-1"),"."),(0,r.yg)("p",null,"A ",(0,r.yg)("strong",{parentName:"p"},"subgraph")," is a graph whose vertices and edges are subsets of the original graph. The ",(0,r.yg)("strong",{parentName:"p"},"weight")," of a subgraph is the sum of weights of its constituent edges."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 1:")),(0,r.yg)("p",null,(0,r.yg)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2022/02/17/example1drawio.png",alt:null})),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5\nOutput: 9\nExplanation:\nThe above figure represents the input graph.\nThe blue edges represent one of the subgraphs that yield the optimal answer.\nNote that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 2:")),(0,r.yg)("p",null,(0,r.yg)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2022/02/17/example2-1drawio.png",alt:null})),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2\nOutput: -1\nExplanation:\nThe above figure represents the input graph.\nIt can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Constraints:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"3 <= n <= 10^5")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"0 <= edges.length <= 10^5")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"edges[i].length == 3")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"0 <= fromi, toi, src1, src2, dest <= n - 1")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"fromi != toi")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"src1"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"src2"),", and ",(0,r.yg)("inlineCode",{parentName:"li"},"dest")," are pairwise distinct."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"1 <= weight[i] <= 10^5"))),(0,r.yg)("h2",{id:"approach-1-dijkstra-x-3"},"Approach 1: Dijkstra x 3"),(0,r.yg)("p",null,"We calculate the shortest paths for each node from ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"s"),(0,r.yg)("mi",{parentName:"mrow"},"r"),(0,r.yg)("mi",{parentName:"mrow"},"c"),(0,r.yg)("mn",{parentName:"mrow"},"1")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"src1")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"src"),(0,r.yg)("span",{parentName:"span",className:"mord"},"1"))))),", ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"s"),(0,r.yg)("mi",{parentName:"mrow"},"r"),(0,r.yg)("mi",{parentName:"mrow"},"c"),(0,r.yg)("mn",{parentName:"mrow"},"2")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"src2")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"src"),(0,r.yg)("span",{parentName:"span",className:"mord"},"2")))))," and ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"d"),(0,r.yg)("mi",{parentName:"mrow"},"e"),(0,r.yg)("mi",{parentName:"mrow"},"s"),(0,r.yg)("mi",{parentName:"mrow"},"t")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"dest")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"es"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"t"))))),". For ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"d"),(0,r.yg)("mi",{parentName:"mrow"},"e"),(0,r.yg)("mi",{parentName:"mrow"},"s"),(0,r.yg)("mi",{parentName:"mrow"},"t")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"dest")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"es"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"t"))))),", we need to do it in a reversed order. If we cannot reach ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"s"),(0,r.yg)("mi",{parentName:"mrow"},"r"),(0,r.yg)("mi",{parentName:"mrow"},"c"),(0,r.yg)("mn",{parentName:"mrow"},"1")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"src1")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"src"),(0,r.yg)("span",{parentName:"span",className:"mord"},"1")))))," or ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"s"),(0,r.yg)("mi",{parentName:"mrow"},"r"),(0,r.yg)("mi",{parentName:"mrow"},"c"),(0,r.yg)("mn",{parentName:"mrow"},"2")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"src2")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"src"),(0,r.yg)("span",{parentName:"span",className:"mord"},"2")))))," from ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"d"),(0,r.yg)("mi",{parentName:"mrow"},"e"),(0,r.yg)("mi",{parentName:"mrow"},"s"),(0,r.yg)("mi",{parentName:"mrow"},"t")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"dest")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"es"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"t"))))),", then the answer is ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mo",{parentName:"mrow"},"\u2212"),(0,r.yg)("mn",{parentName:"mrow"},"1")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"-1")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,r.yg)("span",{parentName:"span",className:"mord"},"\u2212"),(0,r.yg)("span",{parentName:"span",className:"mord"},"1"))))),". Otherwise, we iterate each node to find the distances and sum them together to take the minimal one."),(0,r.yg)(l,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},"using ll = long long;\n\nclass Solution {\npublic:\n    template<typename T_pair, typename T_vector>\n    void dijkstra(T_pair &g, T_vector &dist, ll start) {\n      priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;\n      dist[start] = 0;\n      pq.push({start, 0});\n      while (!pq.empty()) {\n        auto [u_node, u_cost] = pq.top(); pq.pop();\n        if (u_cost > dist[u_node]) continue;\n        for (auto [v_node, v_cost] : g[u_node]) {\n          if (dist[v_node] > dist[u_node] + v_cost) {\n            dist[v_node] = dist[u_node] + v_cost;\n            pq.push({v_node, dist[v_node]});\n          }\n        }\n      }\n    }\n\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\n        ll inf = 1e18;\n        vector<ll> d1(n, inf), d2(n, inf), d3(n, inf);\n        vector<vector<pair<ll, ll>>> g(n);\n        vector<vector<pair<ll, ll>>> rev_g(n);\n        for (auto x : edges) {\n            g[x[0]].push_back({x[1], x[2]});\n            // reversed order\n            rev_g[x[1]].push_back({x[0], x[2]});\n        }\n        // calculate shortest paths for each node from src1\n        dijkstra(g, d1, src1);\n        // calculate shortest paths for each node from src2\n        dijkstra(g, d2, src2);\n        // calculate shortest paths for each node from dest\n        dijkstra(rev_g, d3, dest);\n        // cannot reach src1 / src2 from dest\n        if (d3[src1] == inf || d3[src2] == inf) return -1;\n        ll ans = inf;\n        for (int i = 0; i < n; i++) {\n            ans = min(ans, d1[i] + d2[i] + d3[i]);\n        }\n        return ans;\n    }\n};\n")))}c.isMDXComponent=!0}}]);