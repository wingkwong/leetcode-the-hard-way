"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[30533],{30793:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"0100-0199/binary-tree-maximum-path-sum-hard","title":"0124 - Binary Tree Maximum Path Sum (Hard)","description":"Author: @ColeB2 | https://leetcode.com/problems/binary-tree-maximum-path-sum/","source":"@site/solutions/0100-0199/0124-binary-tree-maximum-path-sum-hard.md","sourceDirName":"0100-0199","slug":"/0100-0199/binary-tree-maximum-path-sum-hard","permalink":"/solutions/0100-0199/binary-tree-maximum-path-sum-hard","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0100-0199/0124-binary-tree-maximum-path-sum-hard.md","tags":[{"inline":true,"label":"Dynamic Programming","permalink":"/solutions/tags/dynamic-programming"},{"inline":true,"label":"Tree","permalink":"/solutions/tags/tree"},{"inline":true,"label":"Depth-First Search","permalink":"/solutions/tags/depth-first-search"},{"inline":true,"label":"Binary Tree","permalink":"/solutions/tags/binary-tree"}],"version":"current","sidebarPosition":124,"frontMatter":{"description":"Author: @ColeB2 | https://leetcode.com/problems/binary-tree-maximum-path-sum/","tags":["Dynamic Programming","Tree","Depth-First Search","Binary Tree"]},"sidebar":"tutorialSidebar","previous":{"title":"0121 - Best Time to Buy and Sell Stock (Easy)","permalink":"/solutions/0100-0199/best-time-to-buy-and-sell-stock-easy"},"next":{"title":"0125 - Valid Palindrome (Easy)","permalink":"/solutions/0100-0199/valid-palindrome"}}');var s=a(86070),r=a(68906);const i={description:"Author: @ColeB2 | https://leetcode.com/problems/binary-tree-maximum-path-sum/",tags:["Dynamic Programming","Tree","Depth-First Search","Binary Tree"]},l="0124 - Binary Tree Maximum Path Sum (Hard)",o={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Depth-First Search",id:"approach-1-depth-first-search",level:2}];function m(e){const t={a:"a",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{SolutionAuthor:a,TabItem:n,Tabs:i}=t;return a||d("SolutionAuthor",!0),n||d("TabItem",!0),i||d("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"0124---binary-tree-maximum-path-sum-hard",children:"0124 - Binary Tree Maximum Path Sum (Hard)"})}),"\n",(0,s.jsx)(t.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://leetcode.com/problems/binary-tree-maximum-path-sum/",children:"https://leetcode.com/problems/binary-tree-maximum-path-sum/"})}),"\n",(0,s.jsx)(t.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.strong,{children:"path"})," in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence ",(0,s.jsx)(t.strong,{children:"at most once"}),". Note that the path does not need to pass through the root."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.strong,{children:"path sum"})," of a path is the sum of the node's values in the path."]}),"\n",(0,s.jsxs)(t.p,{children:["Given the ",(0,s.jsx)(t.code,{children:"root"})," of a binary tree, return ",(0,s.jsxs)(t.em,{children:["the maximum ",(0,s.jsx)(t.strong,{children:"path sum"})," of any non-empty path"]}),"."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example 1:"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg",alt:""})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"Input: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example 2:"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg",alt:""})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"Input: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Constraints:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The number of nodes in the tree is in the range ",(0,s.jsx)(t.code,{children:"[1, 3 * 10^4]"}),"."]}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"-1000 <= Node.val <= 1000"})}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"approach-1-depth-first-search",children:"Approach 1: Depth-First Search"}),"\n",(0,s.jsx)(t.p,{children:"The easiest approach is going to be able to pass up values from the bottom up. That makes this a good reason to use a recursive depth-first search. We can reach the bottom of the tree, then pass up the max path from the left and right nodes."}),"\n",(0,s.jsx)(t.p,{children:"The only other little trick is knowing that the max path sum can only contain 2 edges means the path may not reach straight up to the root. So we must also update a global max with our local max. This would be the current node, plus both subtrees values. We won't pass this one up, but it may still possibly be the max path."}),"\n",(0,s.jsxs)(t.p,{children:["Time Complexity: ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsxs)(t.mrow,{children:[(0,s.jsx)(t.mi,{children:"O"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mi,{children:"n"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(t.span,{className:"mclose",children:")"})]})})]}),", we must process each node in the binary tree."]}),"\n",(0,s.jsxs)(t.p,{children:["Space Complexity: ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsxs)(t.mrow,{children:[(0,s.jsx)(t.mi,{children:"O"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mi,{children:"h"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"O(h)"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"h"}),(0,s.jsx)(t.span,{className:"mclose",children:")"})]})})]}),", we are using a recursive DFS, so it will scale with the high of the tree to track our recursive call stack. This means in the worst case ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"h"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"h"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.6944em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"h"})]})})]})," will be equal to ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"n"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"n"})]})})]}),"."]}),"\n",(0,s.jsx)(i,{children:(0,s.jsxs)(n,{value:"python",label:"Python",children:[(0,s.jsx)(a,{name:"@ColeB2"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-py",children:"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        # initialize a variable to track max path. We will start with our root\n        # value, as that is a possible path.\n        max_path_sum = root.val\n        def helper(node: Optional[TreeNode]) -> int:\n            #base case - reach null node, return 0.\n            if not node:\n                return 0\n            # nonlocal brings our max_path_sum variable into function\n            nonlocal max_path_sum\n            # recursively get max path of our left and right subtrees\n            left = helper(node.left)\n            right = helper(node.right)\n            # select the larger path of the left/right trees.\n            local_max_path = max(left, right)\n            # return path value --\x3e update it with our node value\n            # if and only if our local max is positive. Otherwise\n            # we will just use our node value as local max.\n            path = local_max_path + node.val if local_max_path > 0 else node.val\n            # Update our global max, we will use 3 parameters. Local max that we are\n            # going to pass up, the global max, and lastly, the path from the\n            # current node that goes both left and right.\n            max_path_sum = max(path, max_path_sum, (left+right+node.val))\n            # we can't pass up the value that goes both left and right,\n            # so we pass up our path variable which is the current node\n            # and/or the max path of the left/right trees, if non-negative.\n            return path\n        # call our helper function and return our answer.\n        helper(root)\n        return max_path_sum\n"})})]})})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}function d(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},68906:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>l});var n=a(30758);const s={},r=n.createContext(s);function i(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);