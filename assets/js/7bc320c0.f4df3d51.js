"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[75529],{20553:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"0900-0999/flip-string-to-monotone-increasing-medium","title":"0926 - Flip String to Monotone Increasing (Medium)","description":"Author: @wkw | https://leetcode.com/problems/flip-string-to-monotone-increasing/","source":"@site/solutions/0900-0999/0926-flip-string-to-monotone-increasing-medium.md","sourceDirName":"0900-0999","slug":"/0900-0999/flip-string-to-monotone-increasing-medium","permalink":"/solutions/0900-0999/flip-string-to-monotone-increasing-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0926-flip-string-to-monotone-increasing-medium.md","tags":[{"inline":true,"label":"String","permalink":"/solutions/tags/string"},{"inline":true,"label":"Dynamic Programming","permalink":"/solutions/tags/dynamic-programming"}],"version":"current","sidebarPosition":926,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/flip-string-to-monotone-increasing/","tags":["String","Dynamic Programming"]},"sidebar":"tutorialSidebar","previous":{"title":"0918 - Maximum Sum Circular Subarray (Medium)","permalink":"/solutions/0900-0999/maximum-sum-circular-subarray-medium"},"next":{"title":"0935 - Knight Dialer (Medium)","permalink":"/solutions/0900-0999/knight-dialer-medium"}}');var o=i(86070),r=i(40629);const s={description:"Author: @wkw | https://leetcode.com/problems/flip-string-to-monotone-increasing/",tags:["String","Dynamic Programming"]},c="0926 - Flip String to Monotone Increasing (Medium)",l={},a=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dynamic Programming",id:"approach-1-dynamic-programming",level:2}];function d(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components},{SolutionAuthor:i,TabItem:t,Tabs:s}=e;return i||m("SolutionAuthor",!0),t||m("TabItem",!0),s||m("Tabs",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"0926---flip-string-to-monotone-increasing-medium",children:"0926 - Flip String to Monotone Increasing (Medium)"})}),"\n",(0,o.jsx)(e.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.a,{href:"https://leetcode.com/problems/flip-string-to-monotone-increasing/",children:"https://leetcode.com/problems/flip-string-to-monotone-increasing/"})}),"\n",(0,o.jsx)(e.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,o.jsxs)(e.p,{children:["A binary string is monotone increasing if it consists of some number of ",(0,o.jsx)(e.code,{children:"0"}),"'s (possibly none), followed by some number of ",(0,o.jsx)(e.code,{children:"1"}),"'s (also possibly none)."]}),"\n",(0,o.jsxs)(e.p,{children:["You are given a binary string ",(0,o.jsx)(e.code,{children:"s"}),". You can flip ",(0,o.jsx)(e.code,{children:"s[i]"})," changing it from ",(0,o.jsx)(e.code,{children:"0"})," to ",(0,o.jsx)(e.code,{children:"1"})," or from ",(0,o.jsx)(e.code,{children:"1"})," to ",(0,o.jsx)(e.code,{children:"0"}),"."]}),"\n",(0,o.jsxs)(e.p,{children:["Return ",(0,o.jsx)(e.em,{children:"the minimum number of flips to make"}),(0,o.jsx)(e.code,{children:"s"}),(0,o.jsx)(e.em,{children:"monotone increasing"}),"."]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Example 1:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'Input: s = "00110"\nOutput: 1\nExplanation: We flip the last digit to get 00111.\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Example 2:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'Input: s = "010110"\nOutput: 2\nExplanation: We flip to get 011111, or alternatively 000111.\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Example 3:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'Input: s = "00011000"\nOutput: 2\nExplanation: We flip to get 00000000.\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Constraints:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.code,{children:"1 <= s.length <= 10^5"})}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"s[i]"})," is either ",(0,o.jsx)(e.code,{children:"'0'"})," or ",(0,o.jsx)(e.code,{children:"'1'"}),"."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"approach-1-dynamic-programming",children:"Approach 1: Dynamic Programming"}),"\n",(0,o.jsxs)(e.p,{children:["Let ",(0,o.jsx)(e.code,{children:"dp[i]"})," be the min flips to make ",(0,o.jsx)(e.code,{children:"[0, i)"})," monotone increasing. Starting from ",(0,o.jsx)(e.code,{children:"i = 1"}),", if ",(0,o.jsx)(e.code,{children:"s[i] = 1"}),", we check the previous character ",(0,o.jsx)(e.code,{children:"s[i - 1]"}),". If it is ",(0,o.jsx)(e.code,{children:"1"})," (e.g. ",(0,o.jsx)(e.code,{children:"11..."}),"), then it is monotone increasing already, so",(0,o.jsx)(e.code,{children:"dp[i] = dp[i - 1]"}),". However, if ",(0,o.jsx)(e.code,{children:"s[i - 1] = 0"})," (e.g. ",(0,o.jsx)(e.code,{children:"10..."}),"), then we have two choices - we either flip this zero to make like ",(0,o.jsx)(e.code,{children:"11..."})," or we flip all the ones before this zero (e.g. ",(0,o.jsx)(e.code,{children:"00..."}),"). Therefore, we can see the DP transition here."]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["if ",(0,o.jsx)(e.code,{children:"s[i - 1]"})," is ",(0,o.jsx)(e.code,{children:"1"}),", then ",(0,o.jsx)(e.code,{children:"dp[i] = dp[i - 1]"})]}),"\n",(0,o.jsxs)(e.li,{children:["else ",(0,o.jsx)(e.code,{children:"dp[i] = min(dp[i - 1] + 1, cnt1)"})]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["since ",(0,o.jsx)(e.code,{children:"dp[i]"})," is always based on ",(0,o.jsx)(e.code,{children:"dp[i - 1]"}),", we can space-optimize it using two variables - ",(0,o.jsx)(e.code,{children:"cnt0"})," and ",(0,o.jsx)(e.code,{children:"cnt1"})," where ",(0,o.jsx)(e.code,{children:"cnt0"})," is ",(0,o.jsx)(e.code,{children:"dp[i]"})," at index ",(0,o.jsx)(e.code,{children:"i"})," and ",(0,o.jsx)(e.code,{children:"cnt1"})," is the number of 1s."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"if (s[i] == 0) cnt0 = min(cnt0 + 1, cnt1);\nelse cnt1 += 1;\n"})}),"\n",(0,o.jsx)(e.p,{children:"which is essentially same as"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"if (s[i] == 0) cnt0 += 1;\nelse cnt1 += 1;\ncnt0 = min(cnt0, cnt1);\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Alternatively, we can count the max of ",(0,o.jsx)(e.code,{children:"cnt0"})," and ",(0,o.jsx)(e.code,{children:"cnt1"})," and return ",(0,o.jsx)(e.code,{children:"s.size() - cnt1"}),"."]}),"\n",(0,o.jsxs)(s,{children:[(0,o.jsxs)(t,{value:"cpp",label:"C++",children:[(0,o.jsx)(i,{name:"@wkw"}),(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:"class Solution {\npublic:\n    int minFlipsMonoIncr(string s) {\n        // counters to count numbers of 0s and 1s\n        int cnt0 = 0, cnt1 = 0;\n        // for each character\n        for(auto x : s) {\n            // we count the number of zeros\n            if (x == '0') cnt0++;\n            // or the number of ones\n            else cnt1++;\n            // we can either flip all ones to zeros\n            // e.g. [111]0000 -> [000]0000\n            // or we can just flip the current zero\n            // e.g. 001[0] -> 001[1]\n            cnt0 = min(cnt0, cnt1);\n        }\n        return cnt0;\n    }\n};\n"})})]}),(0,o.jsxs)(t,{value:"java",label:"Java",children:[(0,o.jsx)(i,{name:"@wkw"}),(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-java",children:"class Solution {\n    public int minFlipsMonoIncr(String s) {\n        // counters to count numbers of 0s and 1s\n        int cnt0 = 0, cnt1 = 0;\n        // for each character\n        for (char x : s.toCharArray()) {\n            // we count the number of zeros\n            if (x == '0') cnt0 += 1;\n            // of the number of ones\n            else cnt1 += 1;\n            // we can either flip all ones to zeros\n            // e.g. [111]0000 -> [000]0000\n            // or we can just flip the current zero\n            // e.g. 001[0] -> 001[1]\n            cnt0 = Math.min(cnt0, cnt1);\n        }\n        return cnt0;\n    }\n}\n\n"})})]}),(0,o.jsxs)(t,{value:"py",label:"Python",children:[(0,o.jsx)(i,{name:"@wkw"}),(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-py",children:"class Solution:\n    def minFlipsMonoIncr(self, s: str) -> int:\n        # counters to count numbers of 0s and 1s\n        cnt0, cnt1 = 0, 0\n        # for each character\n        for x in s:\n            # we count the number of zeros\n            if x == '0':\n                cnt0 += 1\n            # or the number of ones\n            else:\n                cnt1 += 1\n            # we can either flip all ones to zeros\n            # e.g. [111]0000 -> [000]0000\n            # or we can just flip the current zero\n            # e.g. 001[0] -> 001[1]\n            cnt0 = min(cnt0, cnt1)\n        return cnt0\n"})})]}),(0,o.jsxs)(t,{value:"rs",label:"Rust",children:[(0,o.jsx)(i,{name:"@wkw"}),(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-rs",children:"impl Solution {\n    pub fn min_flips_mono_incr(s: String) -> i32 {\n        // counters to count numbers of 0s and 1s\n        let mut cnt0 = 0;\n        let mut cnt1 = 0;\n        // for each character\n        for x in s.chars() {\n            // we count the number of zeros\n            if x == '0' {\n                cnt0 += 1;\n            }\n            // or the number of ones\n            else {\n                cnt1 += 1;\n            }\n            // we can either flip all ones to zeros\n            // e.g. [111]0000 -> [000]0000\n            // or we can just flip the current zero\n            // e.g. 001[0] -> 001[1]\n            cnt0 = cnt0.min(cnt1);\n        }\n        cnt0\n    }\n}\n"})})]})]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}function m(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}},40629:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>c});var t=i(30758);const o={},r=t.createContext(o);function s(n){const e=t.useContext(r);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);