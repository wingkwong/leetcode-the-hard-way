"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[28787],{87342:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"0700-0799/network-delay-time-medium","title":"0743 - Network Delay Time (Medium)","description":"Author: @wkw | https://leetcode.com/problems/network-delay-time/","source":"@site/solutions/0700-0799/0743-network-delay-time-medium.md","sourceDirName":"0700-0799","slug":"/0700-0799/network-delay-time-medium","permalink":"/solutions/0700-0799/network-delay-time-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0700-0799/0743-network-delay-time-medium.md","tags":[{"inline":true,"label":"Depth-First Search","permalink":"/solutions/tags/depth-first-search"},{"inline":true,"label":"Breadth-First Search","permalink":"/solutions/tags/breadth-first-search"},{"inline":true,"label":"Graph","permalink":"/solutions/tags/graph"},{"inline":true,"label":"Heap (Priority Queue)","permalink":"/solutions/tags/heap-priority-queue"},{"inline":true,"label":"Shortest Path","permalink":"/solutions/tags/shortest-path"}],"version":"current","sidebarPosition":743,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/network-delay-time/","tags":["Depth-First Search","Breadth-First Search","Graph","Heap (Priority Queue)","Shortest Path"]},"sidebar":"tutorialSidebar","previous":{"title":"0740 - Delete and Earn (Medium)","permalink":"/solutions/0700-0799/delete-and-earn-medium"},"next":{"title":"0744 - Find Smallest Letter Greater Than Target (Easy)","permalink":"/solutions/0700-0799/find-smallest-letter-greater-than-target-easy"}}');var i=t(86070),a=t(68906);const r={description:"Author: @wkw | https://leetcode.com/problems/network-delay-time/",tags:["Depth-First Search","Breadth-First Search","Graph","Heap (Priority Queue)","Shortest Path"]},l="0743 - Network Delay Time (Medium)",o={},d=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dijkstra",id:"approach-1-dijkstra",level:2},{value:"Approach 2: Bellman Ford",id:"approach-2-bellman-ford",level:2}];function c(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{SolutionAuthor:t,TabItem:s,Tabs:r}=n;return t||m("SolutionAuthor",!0),s||m("TabItem",!0),r||m("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"0743---network-delay-time-medium",children:"0743 - Network Delay Time (Medium)"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/network-delay-time/",children:"https://leetcode.com/problems/network-delay-time/"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(n.p,{children:["You are given a network of ",(0,i.jsx)(n.code,{children:"n"})," nodes, labeled from ",(0,i.jsx)(n.code,{children:"1"})," to ",(0,i.jsx)(n.code,{children:"n"}),". You are also given ",(0,i.jsx)(n.code,{children:"times"}),", a list of travel times as directed edges ",(0,i.jsx)(n.code,{children:"times[i] = (ui, vi, wi)"}),", where ",(0,i.jsx)(n.code,{children:"ui"})," is the source node, ",(0,i.jsx)(n.code,{children:"vi"})," is the target node, and ",(0,i.jsx)(n.code,{children:"wi"})," is the time it takes for a signal to travel from source to target."]}),"\n",(0,i.jsxs)(n.p,{children:["We will send a signal from a given node ",(0,i.jsx)(n.code,{children:"k"}),". Return the time it takes for all the ",(0,i.jsx)(n.code,{children:"n"})," nodes to receive the signal. If it is impossible for all the ",(0,i.jsx)(n.code,{children:"n"})," nodes to receive the signal, return ",(0,i.jsx)(n.code,{children:"-1"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png",alt:""})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\nOutput: 2\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: times = [[1,2,1]], n = 2, k = 1\nOutput: 1\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: times = [[1,2,1]], n = 2, k = 2\nOutput: -1\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= k <= n <= 100"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= times.length <= 6000"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"times[i].length == 3"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= ui, vi <= n"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"ui != vi"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"0 <= wi <= 100"})}),"\n",(0,i.jsxs)(n.li,{children:["All the pairs ",(0,i.jsx)(n.code,{children:"(ui, vi)"})," are ",(0,i.jsx)(n.strong,{children:"unique"}),". (i.e., no multiple edges.)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"approach-1-dijkstra",children:"Approach 1: Dijkstra"}),"\n",(0,i.jsx)(n.p,{children:"If we know the time between the starting node and other nodes, then the answer would be the max time. In example 1, if node 2 goes to node 4, it takes 2 seconds. If node 2 goes to to node 1, it takes 1 second. If we take the max time, then other cases would be covered as well."}),"\n",(0,i.jsxs)(n.p,{children:["Therefore, the problem is now asking to find out the max time it takes from the starting node to an arbitrary node. To calculate the shortest path from node A to node B, we can use Dijkstra. Let ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"d"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"["}),(0,i.jsx)(n.mi,{children:"i"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"]"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"d[i]"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"d"}),(0,i.jsx)(n.span,{className:"mopen",children:"["}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"i"}),(0,i.jsx)(n.span,{className:"mclose",children:"]"})]})})]})," be the time that is required to reach from the starting point to node ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mi,{children:"i"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"i"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6595em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"i"})]})})]}),". We initialise each time as ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mi,{children:"e"}),(0,i.jsx)(n.mn,{children:"9"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"1e9"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"e"}),(0,i.jsx)(n.span,{className:"mord",children:"9"})]})})]}),". After calling dijkstra function, if there is one node that need ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"t"}),(0,i.jsx)(n.mi,{children:"i"}),(0,i.jsx)(n.mi,{children:"m"}),(0,i.jsx)(n.mi,{children:"e"}),(0,i.jsx)(n.mo,{children:"="}),(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mi,{children:"e"}),(0,i.jsx)(n.mn,{children:"9"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"time = 1e9"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6595em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"im"}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"e"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"e"}),(0,i.jsx)(n.span,{className:"mord",children:"9"})]})]})]})," to reach, then it means this node is unreachable. We can return ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mo,{children:"\u2212"}),(0,i.jsx)(n.mn,{children:"1"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"-1"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(n.span,{className:"mord",children:"\u2212"}),(0,i.jsx)(n.span,{className:"mord",children:"1"})]})})]})," in this case. Otherwise, return the max one."]}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsxs)(s,{value:"cpp",label:"C++",children:[(0,i.jsx)(t,{name:"@wkw"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    template<typename T_pair, typename T_vector>\n    void dijkstra(T_pair &g, T_vector &dist, int start) {\n      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n      dist[start] = 0;\n      pq.push({start, 0});\n      while (!pq.empty()) {\n        auto [u_node, u_cost] = pq.top(); pq.pop();\n        if (u_cost > dist[u_node]) continue;\n        for (auto [v_node, v_cost] : g[u_node]) {\n          if (dist[v_node] > dist[u_node] + v_cost) {\n            dist[v_node] = dist[u_node] + v_cost;\n            pq.push({v_node, dist[v_node]});\n          }\n        }\n      }\n    }\n\n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        vector<vector<pair<int, int>>> g(n + 1);\n        for (auto x : times) g[x[0]].push_back({x[1], x[2]});\n        vector<int> d(n + 1, 1e9);\n        dijkstra(g, d, k);\n        int ans = *max_element(d.begin() + 1, d.end());\n        return ans == 1e9 ? -1 : ans;\n    }\n};\n"})})]}),(0,i.jsxs)(s,{value:"python",label:"Python",children:[(0,i.jsx)(t,{name:"@ColeB2"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"class Solution:\n    # Time: O(E log V) where E is the number of Edges and V is the\n    # number of vertices in the graph. We use a heap to maintain the\n    # shortest paths of each node, and each edge is added at most once.\n    # Results in O(E log E) operations, since E is at most O(V^2)\n    # we can simplify: ElogV^2 -> 2ElogV -> ElogV\n    # Space Complexity: O(V). Algorithm uses a set to track visited nodes\n    # Have at most V elements, and a heap to store distances, which can\n    # at most hold V elements.\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        # Build our adjacency list to traverse graph\n        adj_list = [[] for _ in range(n + 1)]\n        for (u,v,w) in times:\n            adj_list[u].append((v,w))\n        # initialize our heap, visited set.\n        # Heap items (time, node) Where time is current time.\n        heap = [(0,k)]\n        visited = set()\n        # Loop through all our values in the heap.\n        while heap:\n            # pop the current time and node\n            t, node = heapq.heappop(heap)\n            # Add node to our visited set, and check if we reached all\n            visited.add(node)\n            if len(visited) == n:\n                # reached all nodes, return the time.\n                return t\n            # Loop through all nodes neighbours.\n            for ni, ti in adj_list[node]:\n                # If we haven't processed node before.\n                if ni not in visited:\n                    # Push time and node to heap.\n                    # Times from our times list are times from previous\n                    # node to now, and time we track is global time.\n                    # So we add time to the node, with the global time.\n                    heapq.heappush(heap, (t + ti, ni))\n        # If we went through our whole heap without our visited ever\n        # reaching n, it means we can't visit all nodes, so return -1.\n        return -1\n"})})]})]}),"\n",(0,i.jsx)(n.h2,{id:"approach-2-bellman-ford",children:"Approach 2: Bellman Ford"}),"\n",(0,i.jsx)(r,{children:(0,i.jsxs)(s,{value:"cpp",label:"C++",children:[(0,i.jsx)(t,{name:"@wkw"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    template<typename T_a3, typename T_vector>\n    void bellman_ford(T_a3 &g, T_vector &dist, int src, int mx_edges) {\n        // dist[i] : dist to reach node j using at most i edges from src\n        dist[src] = 0;\n        for (int i = 0; i <= mx_edges; i++) {\n            T_vector ndist = dist;\n            for (auto x : g) {\n                auto [from, to, cost] = x;\n                ndist[to] = min(ndist[to], dist[from] + cost);\n            }\n            dist = ndist;\n        }\n    }\n\n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        vector<array<int, 3>> g;\n        vector<int> dist(n, 1e9);\n        for (auto x : times) g.push_back({x[0] - 1, x[1] - 1, x[2]});\n        bellman_ford(g, dist, k - 1, n);\n        int mx = *max_element(dist.begin(), dist.end());\n        return mx == 1e9 ? -1 : mx;\n    }\n};\n"})})]})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function m(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},68906:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(30758);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);