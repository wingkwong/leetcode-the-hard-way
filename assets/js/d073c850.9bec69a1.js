"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[98583],{96401:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"1000-1099/lexicographically-smallest-equivalent-string-medium","title":"1061 - Lexicographically Smallest Equivalent String (Medium)","description":"Author: @wkw | https://leetcode.com/problems/lexicographically-smallest-equivalent-string/","source":"@site/solutions/1000-1099/1061-lexicographically-smallest-equivalent-string-medium.md","sourceDirName":"1000-1099","slug":"/1000-1099/lexicographically-smallest-equivalent-string-medium","permalink":"/solutions/1000-1099/lexicographically-smallest-equivalent-string-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1000-1099/1061-lexicographically-smallest-equivalent-string-medium.md","tags":[{"inline":true,"label":"String","permalink":"/solutions/tags/string"},{"inline":true,"label":"Union Find","permalink":"/solutions/tags/union-find"}],"version":"current","sidebarPosition":1061,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/lexicographically-smallest-equivalent-string/","tags":["String","Union Find"]},"sidebar":"tutorialSidebar","previous":{"title":"1047 - Remove All Adjacent Duplicates In String (Easy)","permalink":"/solutions/1000-1099/remove-all-adjacent-duplicates-in-string-easy"},"next":{"title":"1066 - Campus Bikes II (Medium)","permalink":"/solutions/1000-1099/campus-bikes-ii-medium"}}');var s=t(86070),r=t(32790);const a={description:"Author: @wkw | https://leetcode.com/problems/lexicographically-smallest-equivalent-string/",tags:["String","Union Find"]},l="1061 - Lexicographically Smallest Equivalent String (Medium)",o={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DSU",id:"approach-1-dsu",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{SolutionAuthor:t,TabItem:i,Tabs:a}=n;return t||u("SolutionAuthor",!0),i||u("TabItem",!0),a||u("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"1061---lexicographically-smallest-equivalent-string-medium",children:"1061 - Lexicographically Smallest Equivalent String (Medium)"})}),"\n",(0,s.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/lexicographically-smallest-equivalent-string/",children:"https://leetcode.com/problems/lexicographically-smallest-equivalent-string/"})}),"\n",(0,s.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,s.jsxs)(n.p,{children:["You are given two strings of the same length ",(0,s.jsx)(n.code,{children:"s1"})," and ",(0,s.jsx)(n.code,{children:"s2"})," and a string ",(0,s.jsx)(n.code,{children:"baseStr"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We say ",(0,s.jsx)(n.code,{children:"s1[i]"})," and ",(0,s.jsx)(n.code,{children:"s2[i]"})," are equivalent characters."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For example, if ",(0,s.jsx)(n.code,{children:'s1 = "abc"'})," and ",(0,s.jsx)(n.code,{children:'s2 = "cde"'}),", then we have ",(0,s.jsx)(n.code,{children:"'a' == 'c'"}),", ",(0,s.jsx)(n.code,{children:"'b' == 'd'"}),", and ",(0,s.jsx)(n.code,{children:"'c' == 'e'"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Equivalent characters follow the usual rules of any equivalence relation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reflexivity:"})," ",(0,s.jsx)(n.code,{children:"'a' == 'a'"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Symmetry:"})," ",(0,s.jsx)(n.code,{children:"'a' == 'b'"})," implies ",(0,s.jsx)(n.code,{children:"'b' == 'a'"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transitivity:"})," ",(0,s.jsx)(n.code,{children:"'a' == 'b'"})," and ",(0,s.jsx)(n.code,{children:"'b' == 'c'"})," implies ",(0,s.jsx)(n.code,{children:"'a' == 'c'"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For example, given the equivalency information from ",(0,s.jsx)(n.code,{children:'s1 = "abc"'})," and ",(0,s.jsx)(n.code,{children:'s2 = "cde"'}),", ",(0,s.jsx)(n.code,{children:'"acd"'})," and ",(0,s.jsx)(n.code,{children:'"aab"'})," are equivalent strings of ",(0,s.jsx)(n.code,{children:'baseStr = "eed"'}),", and ",(0,s.jsx)(n.code,{children:'"aab"'})," is the lexicographically smallest equivalent string of ",(0,s.jsx)(n.code,{children:"baseStr"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Return ",(0,s.jsx)(n.em,{children:"the lexicographically smallest equivalent string of"}),(0,s.jsx)(n.code,{children:"baseStr"}),(0,s.jsx)(n.em,{children:"by using the equivalency information from"}),(0,s.jsx)(n.code,{children:"s1"}),(0,s.jsx)(n.em,{children:"and"}),(0,s.jsx)(n.code,{children:"s2"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'Input: s1 = "parker", s2 = "morris", baseStr = "parser"\nOutput: "makkek"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\nThe characters in each group are equivalent and sorted in lexicographical order.\nSo the answer is "makkek".\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'Input: s1 = "hello", s2 = "world", baseStr = "hold"\nOutput: "hdld"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r].\nSo only the second letter \'o\' in baseStr is changed to \'d\', the answer is "hdld".\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'Input: s1 = "leetcode", s2 = "programs", baseStr = "sourcecode"\nOutput: "aauaaaaada"\nExplanation: We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except \'u\' and \'d\' are transformed to \'a\', the answer is "aauaaaaada".\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"1 <= s1.length, s2.length, baseStr <= 1000"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"s1.length == s2.length"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"s1"}),", ",(0,s.jsx)(n.code,{children:"s2"}),", and ",(0,s.jsx)(n.code,{children:"baseStr"})," consist of lowercase English letters."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"approach-1-dsu",children:"Approach 1: DSU"}),"\n",(0,s.jsxs)(a,{children:[(0,s.jsxs)(i,{value:"cpp",label:"C++",children:[(0,s.jsx)(t,{name:"@wkw"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    int root[26];\n\n    // recursively get the root element\n    int get(int x) {\n        return x == root[x] ? x : (root[x] = get(root[x]));\n    }\n\n    // unite two elements\n    void unite(int x, int y) {\n        // find the root of x\n        x = get(x);\n        // find the root of y\n        y = get(y);\n        // if their roots are not same, we combine them\n        if (x != y) {\n            // smaller first\n            if (x < y)  root[y] = x;\n            else root[x] = y;\n        }\n        return;\n    }\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\n        // dsu\n        string ans;\n        // init root. initialy each element is in its own group.\n        for (int i = 0; i < 26; i++)  root[i] = i;\n        // unite each character\n        for (int i = 0; i < s1.size(); i++) unite(s1[i] - 'a', s2[i] - 'a');\n        // build the final answer from the root element (smallest)\n        for (auto x : baseStr) ans += (char)(get(x - 'a') + 'a');\n        return ans;\n    }\n};\n"})})]}),(0,s.jsxs)(i,{value:"java",label:"Java",children:[(0,s.jsx)(t,{name:"@wkw"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"class Solution {\n    int[] root = new int[26];\n\n    // recursively get the root element\n    int get(int x) {\n        return x == root[x] ? x : (root[x] = get(root[x]));\n    }\n\n    // unite two elements\n    void unite(int x, int y) {\n        // find the root of x\n        x = get(x);\n        // find the root of y\n        y = get(y);\n        // if their roots are not same, we combine them\n        if (x != y) {\n            // smaller first\n            if (x < y)  root[y] = x;\n            else root[x] = y;\n        }\n        return;\n    }\n\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        String ans = \"\";\n        // init root. initialy each element is in its own group.\n        for (int i = 0; i < 26; i++)  root[i] = i;\n        // unite each character\n        for (int i = 0; i < s1.length(); i++) unite(s1.charAt(i) - 'a', s2.charAt(i) - 'a');\n        // build the final answer from the root element (smallest)\n        for (int i = 0; i < baseStr.length(); i++) {\n            ans += (char)(get(baseStr.charAt(i) - 'a') + 'a');\n        }\n        return ans;\n    }\n}\n"})})]}),(0,s.jsxs)(i,{value:"py",label:"Python",children:[(0,s.jsx)(t,{name:"@wkw"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:"class Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        root = [i for i in range(26)]\n\n        def get(x):\n            # recursively get the root element\n            if x == root[x]:\n                return x\n            else:\n                return get(root[x])\n\n        # unite two elements\n        def unite(x, y):\n            # find the root of x and y,\n            x = get(x)\n            y = get(y)\n            # if their roots are not same, we combine them\n            if x != y:\n                if x < y:\n                    root[y] = x\n                else:\n                    root[x] = y\n            return\n\n        ans = \"\"\n        for i in range(len(s1)):\n            unite(ord(s1[i]) - ord('a'), ord(s2[i]) - ord('a'))\n        # dsu to build the final answer from the root element (smallest)\n        for x in baseStr:\n            ans += chr(get(ord(x) - ord('a')) + ord('a'))\n        return ans\n"})})]}),(0,s.jsxs)(i,{value:"rs",label:"Rust",children:[(0,s.jsx)(t,{name:"@wkw"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rs",children:"impl Solution {\n    pub fn smallest_equivalent_string(s1: String, s2: String, base_str: String) -> String {\n        let mut root: [i32; 26] = [i32::default(); 26];\n        // recursively get the root element\n        fn get(root: &mut [i32; 26], x: i32) -> i32 {\n            if x == root[x as usize] {\n                return x;\n            }\n            root[x as usize] = get(root, root[x as usize]);\n            root[x as usize]\n        }\n        // unite two elements\n        fn unite(root: &mut [i32; 26], x: i32, y: i32) {\n            // find the root of x\n            let x = get(root, x);\n            // find the root of y\n            let y = get(root, y);\n            // if their roots are not same, we combine them\n            if x != y {\n                // smaller first\n                if x < y {\n                    root[y as usize] = x;\n                } else {\n                    root[x as usize] = y;\n                }\n            }\n        }\n\n        let mut ans = String::new();\n        // init root. initialy each element is in its own group.\n        for i in 0..26 {\n            root[i] = i as i32;\n        }\n        for i in 0..s1.len() {\n            unite(&mut root, s1.as_bytes()[i] as i32 - 'a' as i32, s2.as_bytes()[i] as i32 - 'a' as i32);\n        }\n        // build the final answer from the root element (smallest)\n        for i in base_str.bytes() {\n            ans.push((get(&mut root, i as i32 - 'a' as i32) + 'a' as i32) as u8 as char);\n        }\n        ans\n    }\n}\n\n"})})]})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},32790:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(30758);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);