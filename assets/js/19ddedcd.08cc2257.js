"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[10539],{80857:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>o,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"0600-0699/design-circular-queue-medium","title":"0622 - Design Circular Queue (Medium)","description":"Author: @wkw | https://leetcode.com/problems/design-circular-queue/","source":"@site/solutions/0600-0699/0622-design-circular-queue-medium.md","sourceDirName":"0600-0699","slug":"/0600-0699/design-circular-queue-medium","permalink":"/solutions/0600-0699/design-circular-queue-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0600-0699/0622-design-circular-queue-medium.md","tags":[{"inline":true,"label":"Array","permalink":"/solutions/tags/array"},{"inline":true,"label":"Linked List","permalink":"/solutions/tags/linked-list"},{"inline":true,"label":"Design","permalink":"/solutions/tags/design"},{"inline":true,"label":"Queue","permalink":"/solutions/tags/queue"}],"version":"current","sidebarPosition":622,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/design-circular-queue/","tags":["Array","Linked List","Design","Queue"]},"sidebar":"tutorialSidebar","previous":{"title":"0621 - Task Scheduler (Medium)","permalink":"/solutions/0600-0699/task-scheduler-medium"},"next":{"title":"0623 - Add One Row to Tree (Medium)","permalink":"/solutions/0600-0699/add-one-row-to-tree-medium"}}');var u=t(86070),a=t(40629);const i={description:"Author: @wkw | https://leetcode.com/problems/design-circular-queue/",tags:["Array","Linked List","Design","Queue"]},s="0622 - Design Circular Queue (Medium)",l={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Array",id:"approach-1-array",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{SolutionAuthor:t,TabItem:r,Tabs:i}=n;return t||h("SolutionAuthor",!0),r||h("TabItem",!0),i||h("Tabs",!0),(0,u.jsxs)(u.Fragment,{children:[(0,u.jsx)(n.header,{children:(0,u.jsx)(n.h1,{id:"0622---design-circular-queue-medium",children:"0622 - Design Circular Queue (Medium)"})}),"\n",(0,u.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,u.jsx)(n.p,{children:(0,u.jsx)(n.a,{href:"https://leetcode.com/problems/design-circular-queue/",children:"https://leetcode.com/problems/design-circular-queue/"})}),"\n",(0,u.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,u.jsx)(n.p,{children:'Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called "Ring Buffer".'}),"\n",(0,u.jsx)(n.p,{children:"One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values."}),"\n",(0,u.jsxs)(n.p,{children:["Implementation the ",(0,u.jsx)(n.code,{children:"MyCircularQueue"})," class:"]}),"\n",(0,u.jsxs)(n.ul,{children:["\n",(0,u.jsxs)(n.li,{children:[(0,u.jsx)(n.code,{children:"MyCircularQueue(k)"})," Initializes the object with the size of the queue to be ",(0,u.jsx)(n.code,{children:"k"}),"."]}),"\n",(0,u.jsxs)(n.li,{children:[(0,u.jsx)(n.code,{children:"int Front()"})," Gets the front item from the queue. If the queue is empty, return ",(0,u.jsx)(n.code,{children:"-1"}),"."]}),"\n",(0,u.jsxs)(n.li,{children:[(0,u.jsx)(n.code,{children:"int Rear()"})," Gets the last item from the queue. If the queue is empty, return ",(0,u.jsx)(n.code,{children:"-1"}),"."]}),"\n",(0,u.jsxs)(n.li,{children:[(0,u.jsx)(n.code,{children:"boolean enQueue(int value)"})," Inserts an element into the circular queue. Return ",(0,u.jsx)(n.code,{children:"true"})," if the operation is successful."]}),"\n",(0,u.jsxs)(n.li,{children:[(0,u.jsx)(n.code,{children:"boolean deQueue()"})," Deletes an element from the circular queue. Return ",(0,u.jsx)(n.code,{children:"true"})," if the operation is successful."]}),"\n",(0,u.jsxs)(n.li,{children:[(0,u.jsx)(n.code,{children:"boolean isEmpty()"})," Checks whether the circular queue is empty or not."]}),"\n",(0,u.jsxs)(n.li,{children:[(0,u.jsx)(n.code,{children:"boolean isFull()"})," Checks whether the circular queue is full or not."]}),"\n"]}),"\n",(0,u.jsx)(n.p,{children:"You must solve the problem without using the built-in queue data structure in your programming language."}),"\n",(0,u.jsx)(n.p,{children:(0,u.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,u.jsx)(n.pre,{children:(0,u.jsx)(n.code,{children:'Input\n["MyCircularQueue", "enQueue", "enQueue", "enQueue", "enQueue", "Rear", "isFull", "deQueue", "enQueue", "Rear"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\nOutput\n[null, true, true, true, false, 3, true, true, true, 4]\n\nExplanation\nMyCircularQueue myCircularQueue = new MyCircularQueue(3);\nmyCircularQueue.enQueue(1); // return True\nmyCircularQueue.enQueue(2); // return True\nmyCircularQueue.enQueue(3); // return True\nmyCircularQueue.enQueue(4); // return False\nmyCircularQueue.Rear();     // return 3\nmyCircularQueue.isFull();   // return True\nmyCircularQueue.deQueue();  // return True\nmyCircularQueue.enQueue(4); // return True\nmyCircularQueue.Rear();     // return 4\n'})}),"\n",(0,u.jsx)(n.p,{children:(0,u.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,u.jsxs)(n.ul,{children:["\n",(0,u.jsx)(n.li,{children:(0,u.jsx)(n.code,{children:"1 <= k <= 1000"})}),"\n",(0,u.jsx)(n.li,{children:(0,u.jsx)(n.code,{children:"0 <= value <= 1000"})}),"\n",(0,u.jsxs)(n.li,{children:["At most ",(0,u.jsx)(n.code,{children:"3000"})," calls will be made to\xa0",(0,u.jsx)(n.code,{children:"enQueue"}),", ",(0,u.jsx)(n.code,{children:"deQueue"}),",\xa0",(0,u.jsx)(n.code,{children:"Front"}),",\xa0",(0,u.jsx)(n.code,{children:"Rear"}),",\xa0",(0,u.jsx)(n.code,{children:"isEmpty"}),", and\xa0",(0,u.jsx)(n.code,{children:"isFull"}),"."]}),"\n"]}),"\n",(0,u.jsx)(n.h2,{id:"approach-1-array",children:"Approach 1: Array"}),"\n",(0,u.jsxs)(i,{children:[(0,u.jsxs)(r,{value:"cpp",label:"C++",children:[(0,u.jsx)(t,{name:"@wkw"}),(0,u.jsx)(n.pre,{children:(0,u.jsx)(n.code,{className:"language-cpp",children:"// Time Complexity: O(1)\n// Space Complexity: O(N)\nclass MyCircularQueue {\npublic:\n    MyCircularQueue(int k) {\n        // the queue holding the elements for the circular queue\n        q.resize(k);\n        // the number of elements in the circular queue\n        cnt = 0;\n        // queue size\n        sz = k;\n        // the idx of the head element\n        headIdx = 0;\n    }\n\n    bool enQueue(int value) {\n        // handle full case\n        if (isFull()) return false;\n        // Given an array of size of 4, we can find the position to be inserted using the formula\n        // targetIdx = (headIdx + cnt) % sz\n        // e.g. [1, 2, 3, _]\n        // headIdx = 0, cnt = 3, sz = 4, targetIdx = (0 + 3) % 4 = 3\n        // e.g. [_, 2, 3, 4]\n        // headIdx = 1, cnt = 3, sz = 4, targetIdx = (1 + 3) % 4 = 0\n        q[(headIdx + cnt) % sz] = value;\n        // increase the number of elements by 1\n        cnt += 1;\n        return true;\n    }\n\n    bool deQueue() {\n        // handle empty case\n        if (isEmpty()) return false;\n        // update the head index\n        headIdx = (headIdx + 1) % sz;\n        // decrease the number of elements by 1\n        cnt -= 1;\n        return true;\n    }\n\n    int Front() {\n        // handle empty queue case\n        if (isEmpty()) return -1;\n        // return the head element\n        return q[headIdx];\n    }\n\n    int Rear() {\n        // handle empty queue case\n        if (isEmpty()) return -1;\n        // Given an array of size of 4, we can find the tailIdx using the formula\n        // tailIdx = (headIdx + cnt - 1) % sz\n        // e.g. [0 1 2] 3\n        // headIdx = 0, cnt = 3, sz = 4, tailIdx = (0 + 3 - 1) % 4 = 2\n        // e.g. 0 [1 2 3]\n        // headIdx = 1, cnt = 3, sz = 4, tailIdx = (1 + 3 - 1) % 4 = 3\n        // e.g. 0] 1 [2 3\n        // headIdx = 2, cnt = 3, sz = 4, tailIdx = (2 + 3 - 1) % 4 = 0\n        return q[(headIdx + cnt - 1) % sz];\n    }\n\n    bool isEmpty() {\n        // no element in the queue\n        return cnt == 0;\n    }\n\n    bool isFull() {\n        // return true if the count is equal to the queue size\n        // else return false\n        return cnt == sz;\n    }\n\nprivate:\n    int cnt, sz, headIdx;\n    vector<int> q;\n};\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * MyCircularQueue* obj = new MyCircularQueue(k);\n * bool param_1 = obj->enQueue(value);\n * bool param_2 = obj->deQueue();\n * int param_3 = obj->Front();\n * int param_4 = obj->Rear();\n * bool param_5 = obj->isEmpty();\n * bool param_6 = obj->isFull();\n */\n"})})]}),(0,u.jsxs)(r,{value:"java",label:"Java",children:[(0,u.jsx)(t,{name:"@wkw"}),(0,u.jsx)(n.pre,{children:(0,u.jsx)(n.code,{className:"language-java",children:"// Time Complexity: O(1)\n// Space Complexity: O(N)\nclass MyCircularQueue {\n\n    public MyCircularQueue(int k) {\n        // the queue holding the elements for the circular queue\n        q = new int[k];\n        // the number of elements in the circular queue\n        cnt = 0;\n        // queue size\n        sz = k;\n        // the idx of the head element\n        headIdx = 0;\n    }\n\n    public boolean enQueue(int value) {\n         // handle full case\n        if (isFull()) return false;\n        // set the value\n        // Given an array of size of 4, we can find the position to be inserted using the formula\n        // targetIdx = (headIdx + cnt) % sz\n        // e.g. [1, 2, 3, _]\n        // headIdx = 0, cnt = 3, sz = 4, targetIdx = (0 + 3) % 4 = 3\n        // e.g. [_, 2, 3, 4]\n        // headIdx = 1, cnt = 3, sz = 4, targetIdx = (1 + 3) % 4 = 0\n        q[(headIdx + cnt) % sz] = value;\n        // increase the number of elements by 1\n        cnt += 1;\n        return true;\n    }\n\n    public boolean deQueue() {\n        // handle empty case\n        if (isEmpty()) return false;\n        // update the head index\n        headIdx = (headIdx + 1) % sz;\n        // decrease the number of elements by 1\n        cnt -= 1;\n        return true;\n    }\n\n    public int Front() {\n        // handle empty queue case\n        if (isEmpty()) return -1;\n        // return the head element\n        return q[headIdx];\n    }\n\n    public int Rear() {\n        // handle empty queue case\n        if (isEmpty()) return -1;\n        // Given an array of size of 4, we can find the tailIdx using the formula\n        // tailIdx = (headIdx + cnt - 1) % sz\n        // e.g. [0 1 2] 3\n        // headIdx = 0, cnt = 3, sz = 4, tailIdx = (0 + 3 - 1) % 4 = 2\n        // e.g. 0 [1 2 3]\n        // headIdx = 1, cnt = 3, sz = 4, tailIdx = (1 + 3 - 1) % 4 = 3\n        // e.g. 0] 1 [2 3\n        // headIdx = 2, cnt = 3, sz = 4, tailIdx = (2 + 3 - 1) % 4 = 0\n        return q[(headIdx + cnt - 1) % sz];\n    }\n\n    public boolean isEmpty() {\n        // no element in the queue\n        return cnt == 0;\n    }\n\n    public boolean isFull() {\n        // return true if the count is equal to the queue size\n        // else return false\n        return cnt == sz;\n    }\n\n    private int[] q;\n    private int headIdx, cnt, sz;\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * MyCircularQueue obj = new MyCircularQueue(k);\n * boolean param_1 = obj.enQueue(value);\n * boolean param_2 = obj.deQueue();\n * int param_3 = obj.Front();\n * int param_4 = obj.Rear();\n * boolean param_5 = obj.isEmpty();\n * boolean param_6 = obj.isFull();\n */\n"})})]}),(0,u.jsxs)(r,{value:"py",label:"Python",children:[(0,u.jsx)(t,{name:"@wkw"}),(0,u.jsx)(n.pre,{children:(0,u.jsx)(n.code,{className:"language-py",children:"# Time Complexity: O(1)\n# Space Complexity: O(N)\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        # the queue holding the elements for the circular queue\n        self.q = [0] * k\n        # the number of elements in the circular queue\n        self.cnt = 0\n        # queue size\n        self.sz = k\n        # the idx of the head element\n        self.headIdx = 0\n\n\n    def enQueue(self, value: int) -> bool:\n        # handle full case\n        if self.isFull(): return False\n\t\t# Given an array of size of 4, we can find the position to be inserted using the formula\n\t\t# targetIdx = (headIdx + cnt) % sz\n\t\t# e.g. [1, 2, 3, _]\n\t\t# headIdx = 0, cnt = 3, sz = 4, targetIdx = (0 + 3) % 4 = 3\n\t\t# e.g. [_, 2, 3, 4]\n\t\t# headIdx = 1, cnt = 3, sz = 4, targetIdx = (1 + 3) % 4 = 0\n        self.q[(self.headIdx + self.cnt) % self.sz] = value\n        # increase the number of elements by 1\n        self.cnt += 1\n        return True\n\n    def deQueue(self) -> bool:\n        # handle empty case\n        if self.isEmpty(): return False\n        # update the head index\n        self.headIdx = (self.headIdx + 1) % self.sz\n        # decrease the number of elements by 1\n        self.cnt -= 1\n        return True\n\n    def Front(self) -> int:\n        # handle empty queue case\n        if self.isEmpty(): return -1\n        # return the head element\n        return self.q[self.headIdx]\n\n    def Rear(self) -> int:\n        # handle empty queue case\n        if self.isEmpty(): return -1\n        # Given an array of size of 4, we can find the tail using the formula\n        # tailIdx = (headIdx + cnt - 1) % sz\n        # e.g. [0 1 2] 3\n        # headIdx = 0, cnt = 3, sz = 4, tailIdx = (0 + 3 - 1) % 4 = 2\n        # e.g. 0 [1 2 3]\n        # headIdx = 1, cnt = 3, sz = 4, tailIdx = (1 + 3 - 1) % 4 = 3\n        # e.g. 0] 1 [2 3\n        # headIdx = 2, cnt = 3, sz = 4, tailIdx = (2 + 3 - 1) % 4 = 0\n        return self.q[(self.headIdx + self.cnt - 1) % self.sz]\n\n    def isEmpty(self) -> bool:\n        # no element in the queue\n        return self.cnt == 0\n\n    def isFull(self) -> bool:\n        # return True if the count is equal to the queue size\n        # else return False\n        return self.cnt == self.sz\n\n\n# Your MyCircularQueue object will be instantiated and called as such:\n# obj = MyCircularQueue(k)\n# param_1 = obj.enQueue(value)\n# param_2 = obj.deQueue()\n# param_3 = obj.Front()\n# param_4 = obj.Rear()\n# param_5 = obj.isEmpty()\n# param_6 = obj.isFull()\n"})})]}),(0,u.jsxs)(r,{value:"ts",label:"TypeScript",children:[(0,u.jsx)(t,{name:"@wkw"}),(0,u.jsx)(n.pre,{children:(0,u.jsx)(n.code,{className:"language-ts",children:"// Time Complexity: O(1)\n// Space Complexity: O(N)\nclass MyCircularQueue {\n  private q: number[];\n  private cnt: number;\n  private sz: number;\n  private headIdx: number;\n\n  constructor(k: number) {\n    // the queue holding the elements for the circular queue\n    this.q = [];\n    // the number of elements in the circular queue\n    this.cnt = 0;\n    // queue size\n    this.sz = k;\n    // the idx of the head element\n    this.headIdx = 0;\n  }\n\n  enQueue(value: number): boolean {\n    // handle full case\n    if (this.isFull()) return false;\n    // set the value\n    this.q[(this.headIdx + this.cnt) % this.sz] = value;\n    // increase the number of elements by 1\n    this.cnt += 1;\n    return true;\n  }\n\n  deQueue(): boolean {\n    // handle empty case\n    if (this.isEmpty()) return false;\n    // update the head index\n    this.headIdx = (this.headIdx + 1) % this.sz;\n    // decrease the number of elements by 1\n    this.cnt -= 1;\n    return true;\n  }\n\n  Front(): number {\n    // handle empty queue case\n    if (this.isEmpty()) return -1;\n    // return the head element\n    return this.q[this.headIdx];\n  }\n\n  Rear(): number {\n    // handle empty queue case\n    if (this.isEmpty()) return -1;\n    // Given an array of size of 4, we can find the tail using the formula\n    // tailIdx = (headIdx + cnt - 1) % sz\n    // e.g. [0 1 2] 3\n    // headIdx = 0, cnt = 3, sz = 4, tailIdx = (0 + 3 - 1) % 4 = 2\n    // e.g. 0 [1 2 3]\n    // headIdx = 1, cnt = 3, sz = 4, tailIdx = (1 + 3 - 1) % 4 = 3\n    // e.g. 0] 1 [2 3\n    // headIdx = 2, cnt = 3, sz = 4, tailIdx = (2 + 3 - 1) % 4 = 0\n    return this.q[(this.headIdx + this.cnt - 1) % this.sz];\n  }\n\n  isEmpty(): boolean {\n    // no element in the queue\n    return this.cnt == 0;\n  }\n\n  isFull(): boolean {\n    // return true if the count is equal to the queue size\n    // else return false\n    return this.cnt == this.sz;\n  }\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * var obj = new MyCircularQueue(k)\n * var param_1 = obj.enQueue(value)\n * var param_2 = obj.deQueue()\n * var param_3 = obj.Front()\n * var param_4 = obj.Rear()\n * var param_5 = obj.isEmpty()\n * var param_6 = obj.isFull()\n */\n"})})]}),(0,u.jsxs)(r,{value:"go",label:"Go",children:[(0,u.jsx)(t,{name:"@wkw"}),(0,u.jsx)(n.pre,{children:(0,u.jsx)(n.code,{className:"language-go",children:"// Time Complexity: O(1)\n// Space Complexity: O(N)\n\ntype MyCircularQueue struct {\n    q []int\n    cnt, sz, headIdx int\n}\n\n\nfunc Constructor(k int) MyCircularQueue {\n    return MyCircularQueue {\n        // the queue holding the elements for the circular queue\n        q: make([]int, k),\n        // the number of elements in the circular queue\n        cnt: 0,\n        // queue size\n        sz: k,\n        // the idx of the head element\n        headIdx: 0,\n    }\n}\n\n\nfunc (this *MyCircularQueue) EnQueue(value int) bool {\n     // handle full case\n    if this.IsFull() {\n        return false\n    }\n     // set the value\n    this.q[(this.headIdx + this.cnt) % this.sz] = value\n    // increase the number of elements by 1\n    this.cnt += 1\n    return true\n}\n\n\nfunc (this *MyCircularQueue) DeQueue() bool {\n    // handle empty case\n    if this.IsEmpty() {\n        return false\n    }\n    // update the head index\n    this.headIdx = (this.headIdx + 1) % this.sz\n    // decrease the number of elements by 1\n    this.cnt -= 1\n    return true\n}\n\n\nfunc (this *MyCircularQueue) Front() int {\n    // handle empty queue case\n    if this.IsEmpty() {\n        return -1\n    }\n    // return the head element\n    return this.q[this.headIdx]\n}\n\n\nfunc (this *MyCircularQueue) Rear() int {\n    // handle empty queue case\n    if this.IsEmpty() {\n        return -1\n    }\n    // Given an array of size of 4, we can find the tail using the formula\n    // tailIdx = (headIdx + cnt - 1) % sz\n    // e.g. [0 1 2] 3\n    // headIdx = 0, cnt = 3, sz = 4, tailIdx = (0 + 3 - 1) % 4 = 2\n    // e.g. 0 [1 2 3]\n    // headIdx = 1, cnt = 3, sz = 4, tailIdx = (1 + 3 - 1) % 4 = 3\n    // e.g. 0] 1 [2 3\n    // headIdx = 2, cnt = 3, sz = 4, tailIdx = (2 + 3 - 1) % 4 = 0\n    return this.q[(this.headIdx + this.cnt - 1) % this.sz]\n}\n\n\nfunc (this *MyCircularQueue) IsEmpty() bool {\n    // no element in the queue\n    return this.cnt == 0\n}\n\n\nfunc (this *MyCircularQueue) IsFull() bool {\n    // return true if the count is equal to the queue size\n    // else return false\n    return this.cnt == this.sz\n}\n\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * obj := Constructor(k);\n * param_1 := obj.EnQueue(value);\n * param_2 := obj.DeQueue();\n * param_3 := obj.Front();\n * param_4 := obj.Rear();\n * param_5 := obj.IsEmpty();\n * param_6 := obj.IsFull();\n */\n"})})]})]})]})}function o(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,u.jsx)(n,{...e,children:(0,u.jsx)(d,{...e})}):d(e)}function h(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},40629:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var r=t(30758);const u={},a=r.createContext(u);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(u):e.components||u:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);