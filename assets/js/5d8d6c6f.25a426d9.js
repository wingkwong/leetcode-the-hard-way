"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[58649],{47325(e,t,n){n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=n(9346),a=(n(37953),n(58860));const o={description:"Author: @kesava-karri | https://leetcode.com/problems/path-sum-iii/",tags:["Tree","Binary Tree","Depth-First Search","Breadth-First Search"]},i="0437 - Path Sum III (Medium)",l={unversionedId:"0400-0499/path-sum-iii-medium",id:"0400-0499/path-sum-iii-medium",title:"0437 - Path Sum III (Medium)",description:"Author: @kesava-karri | https://leetcode.com/problems/path-sum-iii/",source:"@site/solutions/0400-0499/0437-path-sum-iii-medium.md",sourceDirName:"0400-0499",slug:"/0400-0499/path-sum-iii-medium",permalink:"/solutions/0400-0499/path-sum-iii-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0400-0499/0437-path-sum-iii-medium.md",tags:[{label:"Tree",permalink:"/solutions/tags/tree"},{label:"Binary Tree",permalink:"/solutions/tags/binary-tree"},{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Breadth-First Search",permalink:"/solutions/tags/breadth-first-search"}],version:"current",sidebarPosition:437,frontMatter:{description:"Author: @kesava-karri | https://leetcode.com/problems/path-sum-iii/",tags:["Tree","Binary Tree","Depth-First Search","Breadth-First Search"]},sidebar:"tutorialSidebar",previous:{title:"0435 - Non-overlapping Intervals (Medium)",permalink:"/solutions/0400-0499/non-overlapping-intervals-medium"},next:{title:"0438 - Find All Anagrams in a String (Medium)",permalink:"/solutions/0400-0499/find-all-anagrams-in-a-string-medium"}},u={},s=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS + BFS",id:"approach-1-dfs--bfs",level:2}],p=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.yg)("div",t)},m=p("Tabs"),d=p("TabItem"),h=p("SolutionAuthor"),c={toc:s};function g({components:e,...t}){return(0,a.yg)("wrapper",(0,r.A)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"0437---path-sum-iii-medium"},"0437 - Path Sum III (Medium)"),(0,a.yg)("h2",{id:"problem-link"},"Problem Link"),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/path-sum-iii/"},"https://leetcode.com/problems/path-sum-iii/")),(0,a.yg)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.yg)("p",null,"Given the ",(0,a.yg)("inlineCode",{parentName:"p"},"root")," of a binary tree and an integer ",(0,a.yg)("inlineCode",{parentName:"p"},"targetSum"),", return the number of paths where the sum of the values along the path equals ",(0,a.yg)("inlineCode",{parentName:"p"},"targetSum"),"."),(0,a.yg)("p",null,"The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes)."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example 1:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\nOutput: 3\nExplanation: The paths that sum to 8 are shown.\n")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example 2:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: 3\n")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Constraints:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"The number of nodes in the tree is in the range ",(0,a.yg)("inlineCode",{parentName:"li"},"[0, 1000]"),"."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"-10^9 <= Node.val <= 10^9")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"-1000 <= targetSum <= 1000"))),(0,a.yg)("h2",{id:"approach-1-dfs--bfs"},"Approach 1: DFS + BFS"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Since the path can start from any node of the tree it felt like dfs needs to be done from every node which lead to the thought of accessing nodes using BFS and calculating the sum."),(0,a.yg)("li",{parentName:"ul"},"So we use a queue to reach each node & calculate the sum from that node (Similar to level order traversing (BFS))"),(0,a.yg)("li",{parentName:"ul"},"When the ",(0,a.yg)("inlineCode",{parentName:"li"},"remainingSum")," reaches the node whose difference makes it zero leads to the path we need."),(0,a.yg)("li",{parentName:"ul"},"So whenever such path exists we increment our answer"),(0,a.yg)("li",{parentName:"ul"},"Note:"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("ol",{parentName:"li"},(0,a.yg)("li",{parentName:"ol"},"The start node doesn't need to be the root node"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("ol",{parentName:"li",start:2},(0,a.yg)("li",{parentName:"ol"},"The end node doesn't have to be the leaf node"))),(0,a.yg)("li",{parentName:"ul"},"The 3 paths for example 1 equating to targetSum are: ","[5, 3]",", ","[5, 2, 1]",", ","[-3, 11]"),(0,a.yg)("li",{parentName:"ul"},"Check ",(0,a.yg)("a",{parentName:"li",href:"https://leetcode.com/problems/path-sum-ii/solutions/2615948/leetcode-the-hard-way-explained-line-by-line/remainingSum"},"this remainingSum example")," run thru by @wkw")),(0,a.yg)(m,{mdxType:"Tabs"},(0,a.yg)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.yg)(h,{name:"@kesava-karri",mdxType:"SolutionAuthor"}),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int ans;\n     /** @param root the TreeNode of binary tree\n     * @param targetSum to check if sum exists\n     * @return ans indicates the number of paths satisfying the given targetSum\n     */\n    public int pathSum(TreeNode root, int targetSum) {\n        if (root == null) return ans;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        // Since the path can start from any node, combining a BFS style approach w DFS\n        while (!q.isEmpty()) {\n            // get the first node in the queue\n            root = q.poll();\n            f(root, targetSum);\n            if (root.left != null) q.add(root.left);\n            if (root.right != null) q.add(root.right);\n        }\n        return ans;\n    }\n\n    private void f(TreeNode root, long remainingSum) {\n        if (root == null) return;\n        // indicates the sum upto current node is equal to target\n        if (remainingSum - root.val == 0) {\n            ans++;\n        }\n        f(root.left, remainingSum - root.val);\n        f(root.right, remainingSum - root.val);\n    }\n}\n")))))}g.isMDXComponent=!0},58860(e,t,n){n.d(t,{xA:()=>p,yg:()=>h});var r=n(37953);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach(function(t){a(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),s=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef(function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(n),h=a,c=d["".concat(u,".").concat(h)]||d[h]||m[h]||o;return n?r.createElement(c,i(i({ref:t},p),{},{components:n})):r.createElement(c,i({ref:t},p))});function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);