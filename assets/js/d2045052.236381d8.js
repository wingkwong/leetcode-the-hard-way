"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[3631],{91954:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"2000-2099/find-original-array-from-doubled-array-medium","title":"2007 - Find Original Array From Doubled Array (Medium)","description":"Author: @wingkwong, @iraycd | https://leetcode.com/problems/find-original-array-from-doubled-array/","source":"@site/solutions/2000-2099/2007-find-original-array-from-doubled-array-medium.md","sourceDirName":"2000-2099","slug":"/2000-2099/find-original-array-from-doubled-array-medium","permalink":"/solutions/2000-2099/find-original-array-from-doubled-array-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2000-2099/2007-find-original-array-from-doubled-array-medium.md","tags":[{"inline":true,"label":"Array","permalink":"/solutions/tags/array"},{"inline":true,"label":"Hash Table","permalink":"/solutions/tags/hash-table"},{"inline":true,"label":"Greedy","permalink":"/solutions/tags/greedy"},{"inline":true,"label":"Sorting","permalink":"/solutions/tags/sorting"}],"version":"current","sidebarPosition":2007,"frontMatter":{"description":"Author: @wingkwong, @iraycd | https://leetcode.com/problems/find-original-array-from-doubled-array/","tags":["Array","Hash Table","Greedy","Sorting"]},"sidebar":"tutorialSidebar","previous":{"title":"2000 - 2099","permalink":"/solutions/category/2000---2099"},"next":{"title":"2009 - Minimum Number of Operations to Make Array Continuous (Hard)","permalink":"/solutions/2000-2099/minimum-number-of-operations-to-make-array-continuous-hard"}}');var a=r(74848),i=r(28453);const o={description:"Author: @wingkwong, @iraycd | https://leetcode.com/problems/find-original-array-from-doubled-array/",tags:["Array","Hash Table","Greedy","Sorting"]},s="2007 - Find Original Array From Doubled Array (Medium)",l={},d=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Sorting + Hashmap",id:"approach-1-sorting--hashmap",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{SolutionAuthor:r,TabItem:t,Tabs:o}=n;return r||u("SolutionAuthor",!0),t||u("TabItem",!0),o||u("Tabs",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"2007---find-original-array-from-doubled-array-medium",children:"2007 - Find Original Array From Doubled Array (Medium)"})}),"\n",(0,a.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/find-original-array-from-doubled-array/",children:"https://leetcode.com/problems/find-original-array-from-doubled-array/"})}),"\n",(0,a.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,a.jsxs)(n.p,{children:["An integer array ",(0,a.jsx)(n.code,{children:"original"})," is transformed into a ",(0,a.jsx)(n.strong,{children:"doubled"})," array ",(0,a.jsx)(n.code,{children:"changed"})," by appending ",(0,a.jsx)(n.strong,{children:"twice the value"})," of every element in ",(0,a.jsx)(n.code,{children:"original"}),", and then randomly ",(0,a.jsx)(n.strong,{children:"shuffling"})," the resulting array."]}),"\n",(0,a.jsxs)(n.p,{children:["Given an array ",(0,a.jsx)(n.code,{children:"changed"}),", return ",(0,a.jsx)(n.code,{children:"original"}),(0,a.jsx)(n.em,{children:"if"}),(0,a.jsx)(n.code,{children:"changed"}),(0,a.jsxs)(n.em,{children:["is a ",(0,a.jsx)(n.strong,{children:"doubled"})," array. If"]}),(0,a.jsx)(n.code,{children:"changed"}),(0,a.jsxs)(n.em,{children:["is not a ",(0,a.jsx)(n.strong,{children:"doubled"})," array, return an empty array. The elements in"]})," ",(0,a.jsx)(n.code,{children:"original"})," ",(0,a.jsxs)(n.em,{children:["may be returned in ",(0,a.jsx)(n.strong,{children:"any"})," order"]}),"."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input: changed = [1,3,4,2,6,8]\nOutput: [1,3,4]\nExplanation: One possible original array could be [1,3,4]:\n- Twice the value of 1 is 1 * 2 = 2.\n- Twice the value of 3 is 3 * 2 = 6.\n- Twice the value of 4 is 4 * 2 = 8.\nOther original arrays could be [4,3,1] or [3,1,4].\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input: changed = [6,3,0,1]\nOutput: []\nExplanation: changed is not a doubled array.\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input: changed = [1]\nOutput: []\nExplanation: changed is not a doubled array.\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"1 <= changed.length <= 105"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"0 <= changed[i] <= 105"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"approach-1-sorting--hashmap",children:"Approach 1: Sorting + Hashmap"}),"\n",(0,a.jsxs)(o,{children:[(0,a.jsxs)(t,{value:"cpp",label:"C++",children:[(0,a.jsx)(r,{name:"@wingkwong"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// Time Complexity: O(N + NlogN)\n// Space Complexity: O(N)\n// where N is the number of elements in `changed` \nclass Solution {\npublic:\n    // hashmap approach\n    vector<int> findOriginalArray(vector<int>& changed) {\n        // if the length of the input is odd, then return {}\n        // because doubled array must have even length\n        if (changed.size() & 1) return {};\n        // count the frequency of each number\n        unordered_map<int, int> m;\n        for (auto x: changed) m[x]++;\n        vector<int> ans;\n        // sort in ascending order\n        sort(changed.begin(), changed.end());\n        // keep the unique elements only in changed\n        // think of test cases like [0,0,0,0]\n        // alternatively you can handle it like\n        // - check if the frequency of 0 is odd, if so, return {}\n        // - push `0` `m[0] / 2` times to ans\n        changed.erase(unique(changed.begin(), changed.end()), changed.end());\n        // so that we can iterate `changed` from smallest to largest\n        for (auto x : changed) {\n            // if the number of m[x] is greater than than m[x * 2]\n            // then there would be some m[x] left\n            // therefore, return {} here as changed is not a doubled array\n            if (m[x] > m[x * 2]) return {};\n            for (int i = 0; i < m[x]; i++) {\n                // otherwise, we put the element `x` `m[x]` times to ans\n                ans.push_back(x);\n                // at the same time we decrease the count of m[x * 2] by 1\n                // we don't need to decrease m[x] by 1 as we won't use it again\n                m[x * 2] -= 1;\n            }\n        }\n        return ans;\n    }\n};\n"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// Time Complexity: O(N + KlogK)\n// Space Complexity: O(N)\n// where N is the number of elements in `changed` \n// and K is the number of elements in `uniqueNumbers`\nclass Solution {\npublic:\n    // hashmap approach\n    vector<int> findOriginalArray(vector<int>& changed) {\n        // if the length of the input is odd, then return {}\n        // because doubled array must have even length\n        if (changed.size() & 1) return {};\n        // count the frequency of each number\n        unordered_map<int, int> m;\n        for (auto x: changed) m[x]++;\n        vector<int> ans;\n        vector<int> uniqueNumbers;\n\t\t// push all unuque numbers to `uniqueNumbers`\n        for (auto x : m) uniqueNumbers.push_back(x.first);\n        // sort in ascending order\n        sort(uniqueNumbers.begin(), uniqueNumbers.end());\n        // so that we can iterate `changed` from smallest to largest\n        for (auto x : uniqueNumbers) {\n            // if the number of m[x] is greater than than m[x * 2]\n            // then there would be some m[x] left\n            // therefore, return {} here as changed is not a doubled array\n            if (m[x] > m[x * 2]) return {};\n            for (int i = 0; i < m[x]; i++) {\n                // otherwise, we put the element `x` `m[x]` times to ans\n                ans.push_back(x);\n                // at the same time we decrease the count of m[x * 2] by 1\n                // we don't need to decrease m[x] by 1 as we won't use it again\n                m[x * 2] -= 1;\n            }\n        }\n        return ans;\n    }\n};\n"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// Time Complexity: O(NlogN)\n// Space Complexity: O(N)\n// where N is the number of elements in `changed` \nclass Solution {\npublic:\n    // multiset approach\n    vector<int> findOriginalArray(vector<int>& changed) {\n        // if the length of the input is odd, then return {}\n        // because doubled array must have even length\n        if (changed.size() & 1) return {};\n        vector<int> ans;\n        // put all the elements to a multiset\n        multiset<int> s(changed.begin(), changed.end());\n        // keep doing the following logic when there is an element in the multiset\n        while (s.size()) {\n            // get the smallest element\n            int smallest = *s.begin();\n            ans.push_back(smallest);\n            // remove the smallest element in multiset\n            s.erase(s.begin());\n            // if the doubled value of smallest doesn't exist in the multiset\n            // then return {}\n            if (s.find(smallest * 2) == s.end()) return {};\n            // otherwise we can remove its doubled element\n            else s.erase(s.find(smallest * 2));   \n        }\n        return ans;\n    }\n};\n"})})]}),(0,a.jsxs)(t,{value:"py",label:"Python",children:[(0,a.jsx)(r,{name:"@wingkwong"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Time Complexity: O(NlogN)\n# Space Complextiy O(N)\n# where N is the number of elements in `changed` \nclass Solution:\n    def findOriginalArray(self, changed):\n        # use Counter to count the frequency of each element in `changed`\n        cnt, ans = Counter(changed), []\n        # if the length of the input is odd, then return []\n        # because doubled array must have even length\n        if len(changed) % 2: return []\n        # sort in ascending order\n        for x in sorted(cnt.keys()):\n            # if the number of cnt[x] is greater than than cnt[x * 2]\n            # then there would be some cnt[x] left\n            # therefore, return [] here as changed is not a doubled array\n            if cnt[x] > cnt[x * 2]: return []\n            # handle cases like [0,0,0,0]\n            if x == 0:\n                # similarly, odd length -> return []\n                if cnt[x] % 2:\n                    return []\n                else: \n                    # add `0` `cnt[x] // 2` times \n                    ans += [0] * (cnt[x] // 2)\n            else:\n                # otherwise, we put the element `x` `cnt[x]` times to ans\n                ans += [x] * cnt[x]\n            cnt[2 * x] -= cnt[x]\n        return ans\n"})})]}),(0,a.jsxs)(t,{value:"java",label:"Java",children:[(0,a.jsx)(r,{name:"@wingkwong"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"class Solution {\n    // counting sort approach\n    public int[] findOriginalArray(int[] changed) {\n        int n = changed.length, j = 0;\n        // if the length of the input is odd, then return []\n        // because doubled array must have even length\n        if (n % 2 == 1) return new int[]{};\n        int[] ans = new int[n / 2];\n        // alternatively, you can find the max number in `changed`\n        // then use new int[2 * mx + 1]\n        int[] cnt = new int[200005];\n        // count the frequency of each number\n        for (int x : changed) cnt[x] += 1;\n        // iterate from 0 to max number\n        for (int i = 0; i < 200005; i++) {\n            // check if the count of number i is greater than 0\n            if (cnt[i] > 0) {\n                // number i exists, decrease by 1\n                cnt[i] -= 1;\n                // look for the doubled value\n                if (cnt[i * 2] > 0) {\n                    // doubled value exists, decrease by 1\n                    cnt[i * 2] -= 1;\n                    // add this number to ans\n                    ans[j++] = i--;\n                } else {\n                    // cannot pair up, return []\n                    return new int[]{};\n                }\n            }\n        }\n        return ans;\n    }\n}\n"})})]}),(0,a.jsxs)(t,{value:"go",label:"Go",children:[(0,a.jsx)(r,{name:"@iraycd"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"// 1. Mapping the numbers with repetitions.\n// 2. Sort them in ascending order\n// 3. Subtract the doubled from the maps and make the original item 0.\n// 4. Checking if everything is 0.\n\nfunc findOriginalArray(changed []int) []int {\n    // As every number has double, if it's odd, directly return empty.\n    isOdd := len(changed) & 1\n    if(isOdd == 1){\n        return []int{}\n    }\n    \n    // Converting everything to a map, counting the repetitions.\n    changedMap := make(map[int]int)\n    for _, elem := range changed {\n        if _, ok:= changedMap[elem]; ok {\n            changedMap[elem] = changedMap[elem] +1 \n        }else {\n            changedMap[elem] = 1;\n        }\n    }\n    \n    // Creating a unique set of all the repetitions.\n    // Sorting the set/unique array in ascending order as we can easily remove the elements.\n    var set []int\n    for key := range changedMap {\n        set = append(set, key)\n    }\n    sort.Ints(set)\n\n    \n    var original []int;\n    for _, elem := range set {\n        if _, ok:= changedMap[elem*2]; ok {\n            x := changedMap[elem]\n            y := changedMap[elem*2]\n            if(elem == 0){  // In the case of [0,0,0,0] the array has to be [0,0]\n                x = x/2\n            }\n            // We append by the repetitions.\n            for i := 0; i < x; i++ {\n               original = append(original, elem)\n            }\n            // In the case of [2,1,2,4,2,4] we have 2s more than 1s. so we subtract 2s from 1s.\n            changedMap[elem*2] = y - x; \n            changedMap[elem] = 0;\n        }\n    }\n    \n    // Only if all the changedMap has 0 elements in them we make we consider they are all doubled.\n    for _, elem := range changedMap {\n        if (elem != 0){\n            return []int{}\n        }\n    }\n    \n    return original\n}\n"})})]})]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var t=r(96540);const a={},i=t.createContext(a);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);