"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[90200],{60754:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"0100-0199/binary-tree-right-side-view-medium","title":"0199 - Binary Tree Right Side View (Medium)","description":"Author: @ganajayant, @ColeB2, @radojicic23 | https://leetcode.com/problems/binary-tree-right-side-view/","source":"@site/solutions/0100-0199/0199-binary-tree-right-side-view-medium.md","sourceDirName":"0100-0199","slug":"/0100-0199/binary-tree-right-side-view-medium","permalink":"/solutions/0100-0199/binary-tree-right-side-view-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0100-0199/0199-binary-tree-right-side-view-medium.md","tags":[],"version":"current","sidebarPosition":199,"frontMatter":{"description":"Author: @ganajayant, @ColeB2, @radojicic23 | https://leetcode.com/problems/binary-tree-right-side-view/"},"sidebar":"tutorialSidebar","previous":{"title":"0198 - House Robber (Medium)","permalink":"/solutions/0100-0199/house-robber-medium"},"next":{"title":"0200 - 0299","permalink":"/solutions/category/0200---0299"}}');var s=t(86070),i=t(40629);const a={description:"Author: @ganajayant, @ColeB2, @radojicic23 | https://leetcode.com/problems/binary-tree-right-side-view/"},l="0199 - Binary Tree Right Side View (Medium)",o={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS",id:"approach-1-dfs",level:2},{value:"Approach 2: Breadth-First Search",id:"approach-2-breadth-first-search",level:2}];function d(e){const n={a:"a",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{SolutionAuthor:t,TabItem:r,Tabs:a}=n;return t||m("SolutionAuthor",!0),r||m("TabItem",!0),a||m("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"0199---binary-tree-right-side-view-medium",children:"0199 - Binary Tree Right Side View (Medium)"})}),"\n",(0,s.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-right-side-view/",children:"https://leetcode.com/problems/binary-tree-right-side-view/"})}),"\n",(0,s.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,s.jsxs)(n.p,{children:["Given the ",(0,s.jsx)(n.code,{children:"root"})," of a binary tree, imagine yourself standing on the ",(0,s.jsx)(n.strong,{children:"right side"})," of it, return ",(0,s.jsx)(n.em,{children:"the values of the nodes you can see ordered from top to bottom"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg",alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Input: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Input: root = [1,null,3]\nOutput: [1,3]\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Input: root = []\nOutput: []\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The number of nodes in the tree is in the range ",(0,s.jsx)(n.code,{children:"[0, 100]"}),"."]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"-100 <= Node.val <= 100"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"approach-1-dfs",children:"Approach 1: DFS"}),"\n",(0,s.jsx)(n.p,{children:"Maintain an ArrayList. TRAVERSAL -> ROOT ->RIGHT -> LEFT This is the way traversal is done in array so that rightmost node at i level is visited first. When at i level, check in array/vector, if there is an element already present at indexi in the array. [ index represents the level in tree ]->[element at index i is rightmost node at level i] If at that level, element is present,, just continue the traversal. Else if no element is present at index i -> add that node to answer [res] at the i index."}),"\n",(0,s.jsxs)(a,{children:[(0,s.jsxs)(r,{value:"java",label:"Java",children:[(0,s.jsx)(t,{name:"@ganajayant"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        ArrayList<Integer> a = new ArrayList<Integer>();\n        traverse(root, a, 0);\n        return a;\n    }\n\n    private void traverse(TreeNode root, ArrayList<Integer> a, int c) {\n        if (root == null) {\n            return;\n        }\n        if (c == a.size()) {\n            a.add(root.val);\n        }\n        traverse(root.right, a, c + 1);\n        traverse(root.left, a, c + 1);\n    }\n}\n"})})]}),(0,s.jsxs)(r,{value:"py",label:"Python",children:[(0,s.jsx)(t,{name:"@kondekarshubham123"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:'\n"""\n\nbinary-tree-right-side-view\n\n    3       <-  3\n   / \\\n  9   20    <-  20\n     /  \\\n    15   7  <-  7\n\nOutput: [3, 20, 7]\n"""\nclass TreeNode:\n    def __init__(\n        self, val: int = 0, left: TreeNode | None = None, right: TreeNode | None = None\n    ) -> None:\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root: Optional[TreeNode], depth, right_view):\n            if not root:\n                return\n\n            if depth == len(right_view):\n                right_view.append(root.val)\n\n            dfs(root.right, depth + 1, right_view)\n            dfs(root.left, depth + 1, right_view)\n\n        right_view: list = []\n        if not root:\n            return right_view\n        dfs(root, 0, right_view)\n        return right_view\n\n'})})]}),(0,s.jsxs)(r,{value:"cpp",label:"C++",children:[(0,s.jsx)(t,{name:"@radojicic23"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        vector<int> ans;\n        dfs(root, 1, ans);\n        return ans;\n    }\n    void dfs(TreeNode* root, int level, vector<int>& ans) {\n        if (!root) return;\n        if (ans.size() < level) ans.push_back(root->val);\n        dfs(root->right, level + 1, ans);\n        dfs(root->left, level + 1, ans);\n    }\n};\n"})})]}),(0,s.jsxs)(r,{value:"js",label:"JavaScript",children:[(0,s.jsx)(t,{name:"@radojicic23"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar rightSideView = function (root) {\n  if (!root) return [];\n  let ans = [];\n  dfs(root, 0);\n  return ans;\n\n  function dfs(root, level) {\n    if (!root) return;\n    ans[level] = root.val;\n    dfs(root.left, level + 1);\n    dfs(root.right, level + 1);\n  }\n};\n"})})]})]}),"\n",(0,s.jsx)(n.h2,{id:"approach-2-breadth-first-search",children:"Approach 2: Breadth-First Search"}),"\n",(0,s.jsx)(n.p,{children:"A level order traversal, selecting the far right node in each level makes a lot of sense. We can perform a level order traversal using a queue and performing a breadth-first search."}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.a,{href:"https://leetcodethehardway.com/solutions/0100-0199/binary-tree-level-order-traversal-medium",children:"level order traversal"})," can be started by placing the root into the queue. Then for each iteration, we can loop over the length of the queue, ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"n"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})})]}),". By looping over ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"n"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})})]})," it means we only ever loop over the current level, meaning we can add nodes to the queue, and will never reach them as our for loop will stop, maintaining a perfect level order traversal."]}),"\n",(0,s.jsx)(n.p,{children:"We can place the nodes from left to right, or right to left. If we place nodes right first, then left. Then on each iteration, our rightmost node will be first in the queue. If we place them left to right, then on each iteration the rightmost node will be last in our queue."}),"\n",(0,s.jsxs)(n.p,{children:["Time Complexity: ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"O"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"("}),(0,s.jsx)(n.mi,{children:"n"}),(0,s.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(n.span,{className:"mopen",children:"("}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(n.span,{className:"mclose",children:")"})]})})]})," we have to process each node once. If we only tried to process the right node, and skip nodes when the rightmost node exists, we would be skipping nodes in the left subtree in the cases where the right subtree is shorter in height than the left subtree."]}),"\n",(0,s.jsxs)(n.p,{children:["Space Complexity: ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"O"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"("}),(0,s.jsx)(n.mi,{children:"n"}),(0,s.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(n.span,{className:"mopen",children:"("}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(n.span,{className:"mclose",children:")"})]})})]}),". In the worst case, that is a full binary tree, the last level of our traversal will fill our queue with ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"n"}),(0,s.jsx)(n.mi,{mathvariant:"normal",children:"/"}),(0,s.jsx)(n.mn,{children:"2"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n/2"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(n.span,{className:"mord",children:"/2"})]})})]})," nodes, leading us to a ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"O"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"("}),(0,s.jsx)(n.mi,{children:"n"}),(0,s.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(n.span,{className:"mopen",children:"("}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(n.span,{className:"mclose",children:")"})]})})]})," space complexity."]}),"\n",(0,s.jsx)(a,{children:(0,s.jsxs)(r,{value:"python",label:"Python",children:[(0,s.jsx)(t,{name:"@ColeB2"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        # Base case for early termination.\n        if not root:\n            return []\n        # Initialize our queue with the root node inside.\n        q = deque([root])\n        # initialize an empty list to return later.\n        right_view = []\n        # while the queue contains nodes.\n        while q:\n            # Since we are placing nodes inside the queue from right to left\n            # it means the first node will always be rightmost node.\n            # Note we could do it left to right, then the rightmost will always\n            # be the last node in the queue at position [-1]\n            right_view.append(q[0].val)\n            # loop through each node in the current level. By looping over len(q)\n            # it allows us to add children nodes, whilst also only processing\n            # the nodes in the current level.\n            for i in range(len(q)):\n                # pop the node.\n                node = q.popleft()\n                # if node has a right child, add it to the queue.\n                if node.right:\n                    q.append(node.right)\n                # if node has a left child, add it to the queue.\n                if node.left:\n                    q.append(node.left)\n        # return our answer.\n        return right_view\n"})})]})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function m(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},40629:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(30758);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);