"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[64110],{80346:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>h});var i=t(85893),o=t(11151);const s={description:"Author: @wingkwong | https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/",tags:["Math","Bit Manipulation","Simulation"]},a="1680 - Concatenation of Consecutive Binary Numbers (Medium)",r={id:"1600-1699/concatenation-of-consecutive-binary-numbers-medium",title:"1680 - Concatenation of Consecutive Binary Numbers (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/",source:"@site/solutions/1600-1699/1680-concatenation-of-consecutive-binary-numbers-medium.md",sourceDirName:"1600-1699",slug:"/1600-1699/concatenation-of-consecutive-binary-numbers-medium",permalink:"/solutions/1600-1699/concatenation-of-consecutive-binary-numbers-medium",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1600-1699/1680-concatenation-of-consecutive-binary-numbers-medium.md",tags:[{inline:!0,label:"Math",permalink:"/solutions/tags/math"},{inline:!0,label:"Bit Manipulation",permalink:"/solutions/tags/bit-manipulation"},{inline:!0,label:"Simulation",permalink:"/solutions/tags/simulation"}],version:"current",sidebarPosition:1680,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/",tags:["Math","Bit Manipulation","Simulation"]},sidebar:"tutorialSidebar",previous:{title:"1679 - Max Number of K-Sum Pairs (Medium)",permalink:"/solutions/1600-1699/max-number-of-k-sum-pairs-medium"},next:{title:"1685 - Sum of Absolute Differences in a Sorted Array (Medium)",permalink:"/solutions/1600-1699/sum-of-absolute-differences-in-a-sorted-array-medium"}},l={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Bit Manipulation",id:"approach-1-bit-manipulation",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components},{SolutionAuthor:t,TabItem:s,Tabs:a}=n;return t||u("SolutionAuthor",!0),s||u("TabItem",!0),a||u("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"1680---concatenation-of-consecutive-binary-numbers-medium",children:"1680 - Concatenation of Consecutive Binary Numbers (Medium)"}),"\n",(0,i.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/",children:"https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(n.p,{children:["Given an integer ",(0,i.jsx)(n.code,{children:"n"}),", return ",(0,i.jsxs)(n.em,{children:["the ",(0,i.jsx)(n.strong,{children:"decimal value"})," of the binary string formed by concatenating the binary representations of"]}),(0,i.jsx)(n.code,{children:"1"}),(0,i.jsx)(n.em,{children:"to"}),(0,i.jsx)(n.code,{children:"n"}),(0,i.jsxs)(n.em,{children:["in order, ",(0,i.jsx)(n.strong,{children:"modulo"})]}),(0,i.jsx)(n.code,{children:"109 + 7"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Input: n = 1\nOutput: 1\nExplanation: "1" in binary corresponds to the decimal value 1.\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Input: n = 3\nOutput: 27\nExplanation: In binary, 1, 2, and 3 corresponds to "1", "10", and "11".\nAfter concatenating them, we have "11011", which corresponds to the decimal value 27.\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Input: n = 12\nOutput: 505379714\nExplanation: The concatenation results in "1101110010111011110001001101010111100".\nThe decimal value of that is 118505380540.\nAfter modulo 109 + 7, the result is 505379714.\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= n <= 10^5"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"approach-1-bit-manipulation",children:"Approach 1: Bit Manipulation"}),"\n",(0,i.jsxs)(a,{children:[(0,i.jsxs)(s,{value:"cpp",label:"C++",children:[(0,i.jsx)(t,{name:"@wingkwong"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Time Complexity: O(N)\n// Space Complexity: O(1)\nclass Solution {\npublic:\n    // the idea is to use bit manipulation to set the current number based on the previous number\n    // for example, \n    // n = 1, ans = 0b1\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\n    // so now we can see a pattern here\n    // we need to shift `l` bits of the previous ans to the left and add the current `i` \n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\n    int concatenatedBinary(int n) {\n        // `l` is the bit length to be shifted\n        int M = 1e9 + 7, l = 0;\n        // use long here as it potentially could overflow for int\n        long ans = 0;\n        for (int i = 1; i <= n; i++) {\n            // i & (i - 1) means removing the rightmost set bit\n            // e.g. 100100 -> 100000\n            //      000001 -> 000000\n            //      000000 -> 000000\n            // after removal, if it is 0, then it means it is power of 2\n            // as all power of 2 only contains 1 set bit\n            // if it is power of 2, we increase the bit length `l`\n            if ((i & (i - 1)) == 0) l += 1;\n            // (ans << l) means shifting the orginal answer `l` bits to th left\n            // (x | i) means  using OR operation to set the bit\n            // e.g. 0001 << 3 = 0001000\n            // e.g. 0001000 | 0001111 = 0001111\n            ans = ((ans << l) | i) % M;\n        }\n        return ans;\n    }\n};\n"})})]}),(0,i.jsxs)(s,{value:"py",label:"Python",children:[(0,i.jsx)(t,{name:"@wingkwong"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"# Time Complexity: O(N)\n# Space Complexity: O(1)\nclass Solution:\n    # the idea is to use bit manipulation to set the current number based on the previous number\n    # for example, \n    # n = 1, ans = 0b1\n    # n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\n    # i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\n    # n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \n    # i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\n    # n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\n    # i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\n    # so now we can see a pattern here\n    # we need to shift `l` bits of the previous ans to the left and add the current `i` \n    # how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\n    def concatenatedBinary(self, n: int) -> int:\n        M = 10 ** 9 + 7\n        # `l` is the bit length to be shifted\n        l, ans = 0, 0\n        for i in range(1, n + 1):\n            # i & (i - 1) means removing the rightmost set bit\n            # e.g. 100100 -> 100000\n            #      000001 -> 000000\n            #      000000 -> 000000\n            # after removal, if it is 0, then it means it is power of 2\n            # as all power of 2 only contains 1 set bit\n            # if it is power of 2, we increase the bit length `l`\n            if i & (i - 1) == 0:\n                l += 1\n            # (ans << l) means shifting the orginal answer `l` bits to th left\n            # (x | i) means  using OR operation to set the bit\n            # e.g. 0001 << 3 = 0001000\n            # e.g. 0001000 | 0001111 = 0001111\n            ans = ((ans << l) | i) % M\n        return ans\n"})})]}),(0,i.jsxs)(s,{value:"java",label:"Java",children:[(0,i.jsx)(t,{name:"@wingkwong"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Time Complexity: O(N)\n// Space Complexity: O(1)\nclass Solution {\n    // the idea is to use bit manipulation to set the current number based on the previous number\n    // for example, \n    // n = 1, ans = 0b1\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\n    // so now we can see a pattern here\n    // we need to shift `l` bits of the previous ans to the left and add the current `i` \n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\n    public int concatenatedBinary(int n) {\n        // `l` is the bit length to be shifted\n        int M = 1000000007, l = 0;\n        // use long here as it potentially could overflow for int\n        long ans = 0;\n        for (int i = 1; i <= n; i++) {\n            // i & (i - 1) means removing the rightmost set bit\n            // e.g. 100100 -> 100000\n            //      000001 -> 000000\n            //      000000 -> 000000\n            // after removal, if it is 0, then it means it is power of 2\n            // as all power of 2 only contains 1 set bit\n            // if it is power of 2, we increase the bit length `l`\n            if ((i & (i - 1)) == 0) l += 1;\n            // (ans << l) means shifting the orginal answer `l` bits to th left\n            // (x | i) means  using OR operation to set the bit\n            // e.g. 0001 << 3 = 0001000\n            // e.g. 0001000 | 0001111 = 0001111\n            ans = ((ans << l) | i) % M;\n        }\n        return (int) ans;\n    }\n}\n"})})]}),(0,i.jsxs)(s,{value:"go",label:"Go",children:[(0,i.jsx)(t,{name:"@wingkwong"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// Time Complexity: O(N)\n// Space Complexity: O(1)\n\n// the idea is to use bit manipulation to set the current number based on the previous number\n// for example, \n// n = 1, ans = 0b1\n// n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\n// i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\n// n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \n// i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\n// n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\n// i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\n// so now we can see a pattern here\n// we need to shift `l` bits of the previous ans to the left and add the current `i` \n// how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\nfunc concatenatedBinary(n int) int {\n    // `l` is the bit length to be shifted\n    ans, l, M := 0, 0, 1_000_000_007\n    for i := 1; i <= n; i++ {\n        // i & (i - 1) means removing the rightmost set bit\n        // e.g. 100100 -> 100000\n        //      000001 -> 000000\n        //      000000 -> 000000\n        // after removal, if it is 0, then it means it is power of 2\n        // as all power of 2 only contains 1 set bit\n        // if it is power of 2, we increase the bit length `l`\n        if (i & (i - 1) == 0) {\n            l += 1\n        }\n        // (ans << l) means shifting the orginal answer `l` bits to th left\n        // (x | i) means  using OR operation to set the bit\n        // e.g. 0001 << 3 = 0001000\n        // e.g. 0001000 | 0001111 = 0001111\n        ans = ((ans << l) | i) % M\n    }   \n    return ans\n}\n\n"})})]})]})]})}function d(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var i=t(67294);const o={},s=i.createContext(o);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);