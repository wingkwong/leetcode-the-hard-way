"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[12423],{26188(e,n,o){o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>g,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var t=o(9346),r=(o(37953),o(58860));const i={description:"Author: @wkw, @radojicic23 | https://leetcode.com/problems/keys-and-rooms/",tags:["Depth-First Search","Breadth-First Search","Graph"]},a="0841 - Keys and Rooms (Medium)",s={unversionedId:"0800-0899/keys-and-rooms-medium",id:"0800-0899/keys-and-rooms-medium",title:"0841 - Keys and Rooms (Medium)",description:"Author: @wkw, @radojicic23 | https://leetcode.com/problems/keys-and-rooms/",source:"@site/solutions/0800-0899/0841-keys-and-rooms-medium.md",sourceDirName:"0800-0899",slug:"/0800-0899/keys-and-rooms-medium",permalink:"/solutions/0800-0899/keys-and-rooms-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0800-0899/0841-keys-and-rooms-medium.md",tags:[{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Breadth-First Search",permalink:"/solutions/tags/breadth-first-search"},{label:"Graph",permalink:"/solutions/tags/graph"}],version:"current",sidebarPosition:841,frontMatter:{description:"Author: @wkw, @radojicic23 | https://leetcode.com/problems/keys-and-rooms/",tags:["Depth-First Search","Breadth-First Search","Graph"]},sidebar:"tutorialSidebar",previous:{title:"0838 - Push Dominoes (Medium)",permalink:"/solutions/0800-0899/push-dominoes-medium"},next:{title:"0844 - Backspace String Compare (Easy)",permalink:"/solutions/0800-0899/backspace-string-compare-easy"}},l={},m=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS",id:"approach-1-dfs",level:2}],p=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.yg)("div",n)},u=p("Tabs"),c=p("TabItem"),d=p("SolutionAuthor"),y={toc:m};function g({components:e,...n}){return(0,r.yg)("wrapper",(0,t.A)({},y,n,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"0841---keys-and-rooms-medium"},"0841 - Keys and Rooms (Medium)"),(0,r.yg)("h2",{id:"problem-link"},"Problem Link"),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/keys-and-rooms/"},"https://leetcode.com/problems/keys-and-rooms/")),(0,r.yg)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.yg)("p",null,"There are ",(0,r.yg)("inlineCode",{parentName:"p"},"n")," rooms labeled from ",(0,r.yg)("inlineCode",{parentName:"p"},"0")," to ",(0,r.yg)("inlineCode",{parentName:"p"},"n - 1"),"\xa0and all the rooms are locked except for room ",(0,r.yg)("inlineCode",{parentName:"p"},"0"),". Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key."),(0,r.yg)("p",null,"When you visit a room, you may find a set of ",(0,r.yg)("strong",{parentName:"p"},"distinct keys")," in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms."),(0,r.yg)("p",null,"Given an array ",(0,r.yg)("inlineCode",{parentName:"p"},"rooms")," where ",(0,r.yg)("inlineCode",{parentName:"p"},"rooms[i]")," is the set of keys that you can obtain if you visited room ",(0,r.yg)("inlineCode",{parentName:"p"},"i"),", return ",(0,r.yg)("inlineCode",{parentName:"p"},"true")," ",(0,r.yg)("em",{parentName:"p"},"if you can visit ",(0,r.yg)("strong",{parentName:"em"},"all")," the rooms, or")," ",(0,r.yg)("inlineCode",{parentName:"p"},"false")," ",(0,r.yg)("em",{parentName:"p"},"otherwise"),"."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 1:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: rooms = [[1],[2],[3],[]]\nOutput: true\nExplanation:\nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 2:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: rooms = [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Constraints:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"n == rooms.length")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"2 <= n <= 1000")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"0 <= rooms[i].length <= 1000")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"1 <= sum(rooms[i].length) <= 3000")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"0 <= rooms[i][j] < n")),(0,r.yg)("li",{parentName:"ul"},"All the values of ",(0,r.yg)("inlineCode",{parentName:"li"},"rooms[i]")," are ",(0,r.yg)("strong",{parentName:"li"},"unique"),".")),(0,r.yg)("h2",{id:"approach-1-dfs"},"Approach 1: DFS"),(0,r.yg)("p",null,"We can use DFS to traverse from the first room and mark every room that we could visit. At the end, we check if all rooms have been visited or not."),(0,r.yg)(u,{mdxType:"Tabs"},(0,r.yg)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.yg)(d,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    void dfs(vector<vector<int>>& rooms, int i, vector<int>& vis) {\n        // mark the room i visited\n        vis[i] = 1;\n        // for each room we can go from the current room\n        for(auto r : rooms[i]) {\n            // if it is not visited\n            if(!vis[r]) {\n                // we go to that room\n                dfs(rooms, r, vis);\n            }\n        }\n    }\n\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\n        int n = (int) rooms.size();\n        vector<int> vis(n, 0);\n        dfs(rooms, 0, vis);\n        int ok = 1;\n        for(int i = 0; i < n; i++) ok &= vis[i];\n        return ok;\n    }\n};\n"))),(0,r.yg)(c,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,r.yg)(d,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rs"},"impl Solution {\n    fn dfs(i: usize, vis: &mut Vec<bool>, rooms: &Vec<Vec<i32>>) {\n        vis[i] = true;\n        for next in rooms[i].iter().map(|&next| next as usize) {\n            if !vis[next] {\n                Self::dfs(next, vis, rooms);\n            }\n        }\n    }\n\n    pub fn can_visit_all_rooms(rooms: Vec<Vec<i32>>) -> bool {\n        let mut vis = vec![false; rooms.len()];\n        Self::dfs(0, &mut vis, &rooms);\n        vis.iter().all(|&x| x)\n    }\n}\n"))),(0,r.yg)(c,{value:"javascript",label:"JavaScript",mdxType:"TabItem"},(0,r.yg)(d,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * @param {number[][]} rooms\n * @return {boolean}\n */\nvar canVisitAllRooms = function (rooms) {\n  let visited = new Set();\n  dfs(0);\n  return visited.size == rooms.length;\n\n  function dfs(room) {\n    if (!visited.has(room)) {\n      visited.add(room);\n      for (i of rooms[room]) {\n        dfs(i);\n      }\n    }\n  }\n};\n"))),(0,r.yg)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,r.yg)(d,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        visited = set()\n        def dfs(room):\n            if room not in visited:\n                visited.add(room)\n                for i in rooms[room]:\n                    dfs(i)\n        dfs(0)\n        return len(rooms) == len(visited)\n")))))}g.isMDXComponent=!0},58860(e,n,o){o.d(n,{xA:()=>p,yg:()=>d});var t=o(37953);function r(e,n,o){return n in e?Object.defineProperty(e,n,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[n]=o,e}function i(e,n){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),o.push.apply(o,t)}return o}function a(e){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?i(Object(o),!0).forEach(function(n){r(e,n,o[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))})}return e}function s(e,n){if(null==e)return{};var o,t,r=function(e,n){if(null==e)return{};var o,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)o=i[t],n.indexOf(o)>=0||(r[o]=e[o]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)o=i[t],n.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var l=t.createContext({}),m=function(e){var n=t.useContext(l),o=n;return e&&(o="function"==typeof e?e(n):a(a({},n),e)),o},p=function(e){var n=m(e.components);return t.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef(function(e,n){var o=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=m(o),d=r,y=c["".concat(l,".").concat(d)]||c[d]||u[d]||i;return o?t.createElement(y,a(a({ref:n},p),{},{components:o})):t.createElement(y,a({ref:n},p))});function d(e,n){var o=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=o.length,a=new Array(i);a[0]=c;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var m=2;m<i;m++)a[m]=o[m];return t.createElement.apply(null,a)}return t.createElement.apply(null,o)}c.displayName="MDXCreateElement"}}]);