"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[30304],{64689:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"1200-1299/shortest-path-in-a-grid-with-obstacles-elimination-hard","title":"1293 - Shortest Path in a Grid with Obstacles Elimination (Hard)","description":"Author: @wkw | https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/","source":"@site/solutions/1200-1299/1293-shortest-path-in-a-grid-with-obstacles-elimination-hard.md","sourceDirName":"1200-1299","slug":"/1200-1299/shortest-path-in-a-grid-with-obstacles-elimination-hard","permalink":"/solutions/1200-1299/shortest-path-in-a-grid-with-obstacles-elimination-hard","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1200-1299/1293-shortest-path-in-a-grid-with-obstacles-elimination-hard.md","tags":[{"inline":true,"label":"Array","permalink":"/solutions/tags/array"},{"inline":true,"label":"Breadth-First Search","permalink":"/solutions/tags/breadth-first-search"},{"inline":true,"label":"Matrix","permalink":"/solutions/tags/matrix"}],"version":"current","sidebarPosition":1293,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/","tags":["Array","Breadth-First Search","Matrix"]},"sidebar":"tutorialSidebar","previous":{"title":"1281 - Subtract the Product and Sum of Digits of an Integer (Easy)","permalink":"/solutions/1200-1299/subtract-the-product-and-sum-of-digits-of-an-integer-easy"},"next":{"title":"1299 - Replace Elements with Greatest Element on Right Side","permalink":"/solutions/1200-1299/replace-elements-with-greatest-element-on-right-side-easy"}}');var r=n(86070),s=n(32790);const o={description:"Author: @wkw | https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",tags:["Array","Breadth-First Search","Matrix"]},a="1293 - Shortest Path in a Grid with Obstacles Elimination (Hard)",l={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: BFS",id:"approach-1-bfs",level:2}];function c(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{SolutionAuthor:n,TabItem:i,Tabs:o}=t;return n||m("SolutionAuthor",!0),i||m("TabItem",!0),o||m("Tabs",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"1293---shortest-path-in-a-grid-with-obstacles-elimination-hard",children:"1293 - Shortest Path in a Grid with Obstacles Elimination (Hard)"})}),"\n",(0,r.jsx)(t.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",children:"https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/"})}),"\n",(0,r.jsx)(t.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,r.jsxs)(t.p,{children:["You are given an ",(0,r.jsx)(t.code,{children:"m x n"})," integer matrix ",(0,r.jsx)(t.code,{children:"grid"})," where each cell is either ",(0,r.jsx)(t.code,{children:"0"})," (empty) or ",(0,r.jsx)(t.code,{children:"1"})," (obstacle). You can move up, down, left, or right from and to an empty cell in ",(0,r.jsx)(t.strong,{children:"one step"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Return ",(0,r.jsxs)(t.em,{children:["the minimum number of ",(0,r.jsx)(t.strong,{children:"steps"})," to walk from the upper left corner"]}),(0,r.jsx)(t.code,{children:"(0, 0)"}),(0,r.jsx)(t.em,{children:"to the lower right corner"}),(0,r.jsx)(t.code,{children:"(m - 1, n - 1)"}),"*given that you can eliminate ",(0,r.jsx)(t.strong,{children:"at most*"}),(0,r.jsx)(t.code,{children:"k"}),(0,r.jsx)(t.em,{children:"obstacles"}),". If it is not possible to find such walk return ",(0,r.jsx)(t.code,{children:"-1"}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Example 1:"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1\nOutput: 6\nExplanation:\nThe shortest path without eliminating any obstacle is 10.\nThe shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Example 2:"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1\nOutput: -1\nExplanation: We need to eliminate at least two obstacles to find such a walk.\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Constraints:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"m == grid.length"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"n == grid[i].length"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"1 <= m, n <= 40"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"1 <= k <= m * n"})}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"grid[i][j]"})," is either ",(0,r.jsx)(t.code,{children:"0"})," ",(0,r.jsx)(t.strong,{children:"or"})," ",(0,r.jsx)(t.code,{children:"1"}),"."]}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"grid[0][0] == grid[m - 1][n - 1] == 0"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"approach-1-bfs",children:"Approach 1: BFS"}),"\n",(0,r.jsx)(o,{children:(0,r.jsxs)(i,{value:"cpp",label:"C++",children:[(0,r.jsx)(n,{name:"@wkw"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"class Solution {\npublic:\n    // 4 directions\n    const int dx[4] = { -1, 0, 0, 1 }, dy[4] = { 0, -1, 1, 0 };\n    // if you are working on 8 directions, then you can use\n    // const int dx[8]= { -1, 0, 0, 1, -1, -1, 1, 1 },\n    //           dy[8]= { 0, 1, -1, 0, -1, 1, -1, 1 };\n\n    int shortestPath(vector<vector<int>>& grid, int k) {\n        int m = grid.size(), n = grid[0].size(), steps = 0;\n        vector<vector<int>> remains(m, vector<int>(n, INT_MIN));\n        // we have a queue storing {x, y, k}\n        // where x and y are coordinate\n        // and r is remain number of obstacles you can remove\n        queue<array<int, 3>> q;\n        // we start at (0, 0) with k\n        q.push({0, 0, k});\n        // at the beginning, you can eliminate at most k obstacles\n        remains[0][0] = k;\n        // BFS\n        while (!q.empty()) {\n            for (int it = q.size(); it > 0; it--) {\n                auto cur = q.front(); q.pop();\n                // if we reach the lower right corner (m - 1, n - 1)\n                // then return the minimum number of steps\n                if (cur[0] == m - 1 && cur[1] == n - 1) return steps;\n                // otherwise we can try 4 directions (up, down, left and right)\n                for (int i = 0; i < 4; i++) {\n                    // given we have at (x, y), we can move to (next_x, next_y)\n                    int next_x = cur[0] + dx[i], next_y = cur[1] + dy[i];\n                    // however, first we need to make sure (next_x, next_y) is within the grid\n                    if(next_x < 0 || next_x >= m || next_y < 0 || next_y >= n) continue;\n                    // then, we check if we can eliminate an obstacle and move there\n                    int remain = cur[2] - grid[next_x][next_y];\n                    // we can only do that when `remain` is greater or equal to 0\n                    // and the target remaining k must be less than the current remaining k\n                    if(remain >= 0 && remains[next_x][next_y] < remain) {\n                        // push to the queue for further process\n                        q.push({next_x, next_y, remain});\n                        // update the remaining k\n                        remains[next_x][next_y] = remain;\n                    }\n                }\n            }\n            // increase step count\n            steps += 1;\n        }\n        // if we reach here,\n        // then it means it is not possible to find such walk\n        return -1;\n    }\n};\n\n"})})]})})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}function m(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},32790:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(30758);const r={},s=i.createContext(r);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);