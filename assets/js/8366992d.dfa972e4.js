"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[35693],{3905:function(e,t,a){a.d(t,{Zo:function(){return o},kt:function(){return h}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function m(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),l=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):m(m({},t),e)),a},o=function(e){var t=l(e.components);return n.createElement(i.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,o=p(e,["components","mdxType","originalType","parentName"]),u=l(a),h=r,d=u["".concat(i,".").concat(h)]||u[h]||c[h]||s;return a?n.createElement(d,m(m({ref:t},o),{},{components:a})):n.createElement(d,m({ref:t},o))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,m=new Array(s);m[0]=u;var p={};for(var i in t)hasOwnProperty.call(t,i)&&(p[i]=t[i]);p.originalType=e,p.mdxType="string"==typeof e?e:r,m[1]=p;for(var l=2;l<s;l++)m[l]=a[l];return n.createElement.apply(null,m)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},15686:function(e,t,a){a.r(t),a.d(t,{assets:function(){return o},contentTitle:function(){return i},default:function(){return f},frontMatter:function(){return p},metadata:function(){return l},toc:function(){return c}});var n=a(87462),r=a(63366),s=(a(67294),a(3905)),m=["components"],p={description:"Author: @wingkwong, @vigneshshiv, @radojicic23 |  https://leetcode.com/problems/find-the-duplicate-number/"},i="0287 - Find the Duplicate Number (Medium)",l={unversionedId:"0200-0299/find-the-duplicate-number-medium",id:"0200-0299/find-the-duplicate-number-medium",title:"0287 - Find the Duplicate Number (Medium)",description:"Author: @wingkwong, @vigneshshiv, @radojicic23 |  https://leetcode.com/problems/find-the-duplicate-number/",source:"@site/solutions/0200-0299/0287-find-the-duplicate-number-medium.md",sourceDirName:"0200-0299",slug:"/0200-0299/find-the-duplicate-number-medium",permalink:"/solutions/0200-0299/find-the-duplicate-number-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0200-0299/0287-find-the-duplicate-number-medium.md",tags:[],version:"current",sidebarPosition:287,frontMatter:{description:"Author: @wingkwong, @vigneshshiv, @radojicic23 |  https://leetcode.com/problems/find-the-duplicate-number/"},sidebar:"tutorialSidebar",previous:{title:"0286 - Walls and Gates (Medium)",permalink:"/solutions/0200-0299/walls-and-gates-medium"},next:{title:"0295 - Find Median from Data Stream (Hard)",permalink:"/solutions/0200-0299/find-median-from-data-stream-hard"}},o={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Bit Masking",id:"approach-1-bit-masking",level:2},{value:"Approach 2: Index based",id:"approach-2-index-based",level:2},{value:"Approach 3: Floyd&#39;s Tortoise and Hare (cycle detection)",id:"approach-3-floyds-tortoise-and-hare-cycle-detection",level:2}],u=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,s.kt)("div",t)}},h=u("Tabs"),d=u("TabItem"),k=u("SolutionAuthor"),N={toc:c};function f(e){var t=e.components,a=(0,r.Z)(e,m);return(0,s.kt)("wrapper",(0,n.Z)({},N,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"0287---find-the-duplicate-number-medium"},"0287 - Find the Duplicate Number (Medium)"),(0,s.kt)("h2",{id:"problem-link"},"Problem Link"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/find-the-duplicate-number/"},"https://leetcode.com/problems/find-the-duplicate-number/")),(0,s.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,s.kt)("p",null,"Given an array of integers ",(0,s.kt)("inlineCode",{parentName:"p"},"nums")," containing ",(0,s.kt)("inlineCode",{parentName:"p"},"n + 1")," integers where each integer is in the range ",(0,s.kt)("inlineCode",{parentName:"p"},"[1, n]")," inclusive."),(0,s.kt)("p",null,"There is only ",(0,s.kt)("strong",{parentName:"p"},"one repeated number")," in ",(0,s.kt)("inlineCode",{parentName:"p"},"nums"),", return ",(0,s.kt)("em",{parentName:"p"},"this repeated number"),"."),(0,s.kt)("p",null,"You must solve the problem ",(0,s.kt)("strong",{parentName:"p"},"without")," modifying the array ",(0,s.kt)("inlineCode",{parentName:"p"},"nums")," and uses only constant extra space."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 1:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: nums = [1,3,4,2,2]\nOutput: 2\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 2:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: nums = [3,1,3,4,2]\nOutput: 3\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Constraints:")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"1 <= n <= 10^5")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"nums.length == n + 1")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"1 <= nums[i] <= n")),(0,s.kt)("li",{parentName:"ul"},"All the integers in ",(0,s.kt)("inlineCode",{parentName:"li"},"nums")," appear only ",(0,s.kt)("strong",{parentName:"li"},"once")," except for ",(0,s.kt)("strong",{parentName:"li"},"precisely one integer")," which appears ",(0,s.kt)("strong",{parentName:"li"},"two or more")," times.")),(0,s.kt)("h2",{id:"approach-1-bit-masking"},"Approach 1: Bit Masking"),(0,s.kt)("p",null,"We iterate each bit one by one. We calculate the expected bit count and the actual bit count. If the actual one is greater than the expected one, then it means this bit is part of the duplicate number."),(0,s.kt)(h,{mdxType:"Tabs"},(0,s.kt)(d,{value:"c++",label:"C++",mdxType:"TabItem"},(0,s.kt)(k,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int duplicate = 0, n = nums.size() - 1;\n        // iterate each bit one by one\n        for(int i = 0; i < 31; i++) {\n            long expected = 0, actual = 0;\n            // the integer range [1, n] inclusive\n            // iterate each integer to calculate the expected bit count\n            for(int j = 1; j <= n; j++) expected += (1 << i) & j;\n            // iterate each number to calculate the actual bit count\n            for(int j : nums) actual += (1 << i) & j;\n            // if actual one is greater than the expected one\n            // then this bit is part of the duplicate number\n            if(actual > expected) duplicate |= (1 << i);\n        }\n        return duplicate;\n    }\n};\n")))),(0,s.kt)("h2",{id:"approach-2-index-based"},"Approach 2: Index based"),(0,s.kt)("p",null,"As per problem constraint, all numbers starting from ",(0,s.kt)("inlineCode",{parentName:"p"},"1 to N"),". So shift all numbers to the exact index (",(0,s.kt)("inlineCode",{parentName:"p"},"num - 1"),") positions and find the duplicate. Here, ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mn",{parentName:"mrow"},"1")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"1")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"1")))))," can be placed in index ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mn",{parentName:"mrow"},"0")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"0")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"0"))))),", like wise shift all the numbers one by one, at last, in the last index we will be having the duplicate number."),(0,s.kt)("p",null,"Time complexity: ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow"},"n"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"))))),", where n is the number of elements in the array"),(0,s.kt)("p",null,"Space complexity: ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mn",{parentName:"mrow"},"1"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(1)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,s.kt)(h,{mdxType:"Tabs"},(0,s.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,s.kt)(k,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public int findDuplicate(int[] nums) {\n        int i = 0;\n        while (i < arr.length) {\n            if (arr[i] != i + 1) {\n                if (arr[arr[i] - 1] != arr[i]) {\n                    int j = arr[i] - 1;\n                    int temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                } else {\n                    return arr[i];\n                }\n            } else {\n                i++;\n            }\n        }\n        return -1;\n    }\n}\n")))),(0,s.kt)("h2",{id:"approach-3-floyds-tortoise-and-hare-cycle-detection"},"Approach 3: Floyd's Tortoise and Hare (cycle detection)"),(0,s.kt)("p",null,"Solving this in linear time and constant space requires Floyd's Tortoise and Hare algorithm. "),(0,s.kt)("p",null,"It's a simple cycle detection algorithm, where one pointer traverses twice as fast as another, once two pointers meet, we can trace back to where the cycle begins."),(0,s.kt)("p",null,"Time complexity: ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow"},"n"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"))))),", where n is the number of elements in the array"),(0,s.kt)("p",null,"Space complexity: ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mn",{parentName:"mrow"},"1"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(1)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,s.kt)(h,{mdxType:"Tabs"},(0,s.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,s.kt)(k,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = nums[0];\n        int fast = nums[nums[0]];\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        }\n        fast = 0;\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        return slow;\n    }\n}\n"))),(0,s.kt)(d,{value:"javascript",label:"JavaScript",mdxType:"TabItem"},(0,s.kt)(k,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDuplicate = function(nums) {\n    let slow = 0;\n    let fast = 0;\n    while (true) {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n        if (slow == fast) break;\n    }\n    fast = 0;\n    while (true) {\n        slow = nums[slow];\n        fast = nums[fast];\n        if (slow == fast) return slow;\n    }\n};\n"))),(0,s.kt)(d,{value:"python",label:"Python",mdxType:"TabItem"},(0,s.kt)(k,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},"class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        slow, fast = 0, 0 \n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        \n        fast = 0\n        while True:\n            slow = nums[slow]\n            fast = nums[fast]\n            if slow == fast:\n                return slow \n")))))}f.isMDXComponent=!0}}]);