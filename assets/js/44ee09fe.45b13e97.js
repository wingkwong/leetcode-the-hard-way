"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[20979],{45866(e,n,o){o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>g,frontMatter:()=>i,metadata:()=>m,toc:()=>d});var t=o(9346),a=(o(37953),o(58860));const i={description:"Author: @wkw | https://leetcode.com/problems/minimum-time-to-make-rope-colorful/",tags:["Array","String","Dynamic Programming","Greedy"]},r="1578 - Minimum Time to Make Rope Colorful (Medium)",m={unversionedId:"1500-1599/minimum-time-to-make-rope-colorful-medium",id:"1500-1599/minimum-time-to-make-rope-colorful-medium",title:"1578 - Minimum Time to Make Rope Colorful (Medium)",description:"Author: @wkw | https://leetcode.com/problems/minimum-time-to-make-rope-colorful/",source:"@site/solutions/1500-1599/1578-minimum-time-to-make-rope-colorful-medium.md",sourceDirName:"1500-1599",slug:"/1500-1599/minimum-time-to-make-rope-colorful-medium",permalink:"/solutions/1500-1599/minimum-time-to-make-rope-colorful-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1500-1599/1578-minimum-time-to-make-rope-colorful-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"String",permalink:"/solutions/tags/string"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{label:"Greedy",permalink:"/solutions/tags/greedy"}],version:"current",sidebarPosition:1578,frontMatter:{description:"Author: @wkw | https://leetcode.com/problems/minimum-time-to-make-rope-colorful/",tags:["Array","String","Dynamic Programming","Greedy"]},sidebar:"tutorialSidebar",previous:{title:"1575 - Count All Possible Routes (Hard)",permalink:"/solutions/1500-1599/count-all-possible-routes-hard"},next:{title:"1584 - Min Cost to Connect All Points (Medium)",permalink:"/solutions/1500-1599/min-cost-to-connect-all-points-medium"}},l={},d=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Greedy",id:"approach-1-greedy",level:2}],s=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.yg)("div",n)},c=s("Tabs"),p=s("TabItem"),u=s("SolutionAuthor"),h={toc:d};function g({components:e,...n}){return(0,a.yg)("wrapper",(0,t.A)({},h,n,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"1578---minimum-time-to-make-rope-colorful-medium"},"1578 - Minimum Time to Make Rope Colorful (Medium)"),(0,a.yg)("h2",{id:"problem-link"},"Problem Link"),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/minimum-time-to-make-rope-colorful/"},"https://leetcode.com/problems/minimum-time-to-make-rope-colorful/")),(0,a.yg)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.yg)("p",null,"Alice has ",(0,a.yg)("inlineCode",{parentName:"p"},"n")," balloons arranged on a rope. You are given a ",(0,a.yg)("strong",{parentName:"p"},"0-indexed")," string ",(0,a.yg)("inlineCode",{parentName:"p"},"colors")," where ",(0,a.yg)("inlineCode",{parentName:"p"},"colors[i]")," is the color of the ",(0,a.yg)("inlineCode",{parentName:"p"},"ith")," balloon."),(0,a.yg)("p",null,"Alice wants the rope to be ",(0,a.yg)("strong",{parentName:"p"},"colorful"),". She does not want ",(0,a.yg)("strong",{parentName:"p"},"two consecutive balloons")," to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it ",(0,a.yg)("strong",{parentName:"p"},"colorful"),". You are given a ",(0,a.yg)("strong",{parentName:"p"},"0-indexed")," integer array ",(0,a.yg)("inlineCode",{parentName:"p"},"neededTime")," where ",(0,a.yg)("inlineCode",{parentName:"p"},"neededTime[i]")," is the time (in seconds) that Bob needs to remove the ",(0,a.yg)("inlineCode",{parentName:"p"},"ith")," balloon from the rope."),(0,a.yg)("p",null,"Return ","*","the ",(0,a.yg)("strong",{parentName:"p"},"minimum time")," Bob needs to make the rope ",(0,a.yg)("strong",{parentName:"p"},"colorful","*"),"."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example 1:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"Input: colors = \"abaac\", neededTime = [1,2,3,4,5]\nOutput: 3\nExplanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.\nBob can remove the blue balloon at index 2. This takes 3 seconds.\nThere are no longer two consecutive balloons of the same color. Total time = 3.\n")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example 2:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'Input: colors = "abc", neededTime = [1,2,3]\nOutput: 0\nExplanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.\n')),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example 3:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'Input: colors = "aabaa", neededTime = [1,2,3,4,1]\nOutput: 2\nExplanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.\nThere are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.\n')),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Constraints:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"n == colors.length == neededTime.length")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"1 <= n <= 10^5")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"1 <= neededTime[i] <= 10^4")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"colors")," contains only lowercase English letters.")),(0,a.yg)("h2",{id:"approach-1-greedy"},"Approach 1: Greedy"),(0,a.yg)(c,{mdxType:"Tabs"},(0,a.yg)(p,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.yg)(u,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'// Time Complexity: O(n)\n// Space Complexity: O(1)\nclass Solution {\npublic:\n    // intuition:\n    // ---------------\n    // if there are consecutive balloons with the same color,\n    // we want to keep the one with maximum neededTime and remove others\n\n    // if there are 2 balloons with different colors, ans = 0 as it is colorful\n    // if there are 2 balloons with same color, ans = min(neededTime[0], neededTime[1])\n    // if there are 3 consecutive balloons with same color, ans = sum(neededTime[0 .. 2]) - max(neededTime[0 .. 2])\n    // if there are N consecutive balloons with same color, ans = sum(neededTime[0 .. n - 1]) - max(neededTime[0 .. n - 1])\n    // we don\'t need to calculate the sum and subtract the max though. instead, we can either\n    // 1. update neededTime in place to the max of neededTime[i] and neededTime[i - 1] (shown in below solution) or\n    // 2. store the current max time in a variable\n    // why? let\'s say colors = "aaa" and neededTime = [1,2,1]\n    // we first compare neededTime[0] and neededTime[1] and decide to remove the first balloon (neededTime[0] < neededTime[1])\n    // now colors = "_aa" and neededTime = [_,2,1] and the current max time is 2\n    // then compare neededTime[1] and neededTime[2] and decide to remove the last balloon, (neededTime[2] < neededTime[1])\n    // now colors = "_a_" and neededTime = [_,2,_]. we remove all balloons but the one with maximum neededTime\n    int minCost(string colors, vector<int>& neededTime) {\n        int ans = 0, n = colors.size();\n        for (int i = 1; i < n; i++) {\n            // if the i-th balloon has the same color as (i - 1)th one\n            // e.g. aba[a]c and i = 3 (0-based)\n            if (colors[i] == colors[i - 1]) {\n                // then we remove the one with less time\n                // e.g. in above example, we remove the balloon at index 2\n                // with neededTime[2] since neededTime[2] < neededTime[3]\n                ans += min(neededTime[i], neededTime[i - 1]);\n                // update the max neededTime inplace\n                // or alternatively you can store it in a variable\n                neededTime[i] = max(neededTime[i], neededTime[i - 1]);\n            }\n        }\n        return ans;\n    }\n};\n'))),(0,a.yg)(p,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.yg)(u,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-py"},'# Time Complexity: O(n)\n# Space Complexity: O(1)\nclass Solution:\n    # intuition:\n    # ---------------\n    # if there are consecutive balloons with the same color,\n    # we want to keep the one with maximum neededTime and remove others\n\n    # if there are 2 balloons with different colors, ans = 0 as it is colorful\n    # if there are 2 balloons with same color, ans = min(neededTime[0], neededTime[1])\n    # if there are 3 consecutive balloons with same color, ans = sum(neededTime[0 .. 2]) - max(neededTime[0 .. 2])\n    # if there are N consecutive balloons with same color, ans = sum(neededTime[0 .. n - 1]) - max(neededTime[0 .. n - 1])\n    # we don\'t need to calculate the sum and subtract the max though. instead, we can either\n    # 1. update neededTime in place to the max of neededTime[i] and neededTime[i - 1] (shown in below solution) or\n    # 2. store the current max time in a variable\n    # why? let\'s say colors = "aaa" and neededTime = [1,2,1]\n    # we first compare neededTime[0] and neededTime[1] and decide to remove the first balloon (neededTime[0] < neededTime[1])\n    # now colors = "_aa" and neededTime = [_,2,1] and the current max time is 2\n    # then compare neededTime[1] and neededTime[2] and decide to remove the last balloon, (neededTime[2] < neededTime[1])\n    # now colors = "_a_" and neededTime = [_,2,_]. we remove all balloons but the one with maximum neededTime\n    def minCost(self, colors: str, neededTime: List[int]) -> int:\n        ans = 0\n        for i in range(1, len(colors)):\n            # if the i-th balloon has the same color as (i - 1)th one\n            # e.g. aba[a]c and i = 3 (0-based)\n            if colors[i] == colors[i - 1]:\n                # then we remove the one with less time\n                # e.g. in above example, we remove the balloon at index 2\n                # with neededTime[2] since neededTime[2] < neededTime[3]\n                ans += min(neededTime[i], neededTime[i - 1])\n                # update the max neededTime inplace\n                # or alternatively you can store it in a variable\n                neededTime[i] = max(neededTime[i], neededTime[i - 1])\n        return ans\n'))),(0,a.yg)(p,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.yg)(u,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'// Time Complexity: O(n)\n// Space Complexity: O(1)\nclass Solution {\n    // intuition:\n    // ---------------\n    // if there are consecutive balloons with the same color,\n    // we want to keep the one with maximum neededTime and remove others\n\n    // if there are 2 balloons with different colors, ans = 0 as it is colorful\n    // if there are 2 balloons with same color, ans = min(neededTime[0], neededTime[1])\n    // if there are 3 consecutive balloons with same color, ans = sum(neededTime[0 .. 2]) - max(neededTime[0 .. 2])\n    // if there are N consecutive balloons with same color, ans = sum(neededTime[0 .. n - 1]) - max(neededTime[0 .. n - 1])\n    // we don\'t need to calculate the sum and subtract the max though. instead, we can either\n    // 1. update neededTime in place to the max of neededTime[i] and neededTime[i - 1] (shown in below solution) or\n    // 2. store the current max time in a variable\n    // why? let\'s say colors = "aaa" and neededTime = [1,2,1]\n    // we first compare neededTime[0] and neededTime[1] and decide to remove the first balloon (neededTime[0] < neededTime[1])\n    // now colors = "_aa" and neededTime = [_,2,1] and the current max time is 2\n    // then compare neededTime[1] and neededTime[2] and decide to remove the last balloon, (neededTime[2] < neededTime[1])\n    // now colors = "_a_" and neededTime = [_,2,_]. we remove all balloons but the one with maximum neededTime\n    public int minCost(String colors, int[] neededTime) {\n        int ans = 0, n = colors.length();\n        for (int i = 1; i < n; i++) {\n            // if the i-th balloon has the same color as (i - 1)th one\n            // e.g. aba[a]c and i = 3 (0-based)\n            if (colors.charAt(i) == colors.charAt(i - 1)) {\n                // then we remove the one with less time\n                // e.g. in above example, we remove the balloon at index 2\n                // with neededTime[2] since neededTime[2] < neededTime[3]\n                ans += Math.min(neededTime[i], neededTime[i - 1]);\n                // update the max neededTime inplace\n                // or alternatively you can store it in a variable\n                neededTime[i] = Math.max(neededTime[i], neededTime[i - 1]);\n            }\n        }\n        return ans;\n    }\n}\n')))))}g.isMDXComponent=!0},58860(e,n,o){o.d(n,{xA:()=>s,yg:()=>u});var t=o(37953);function a(e,n,o){return n in e?Object.defineProperty(e,n,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[n]=o,e}function i(e,n){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),o.push.apply(o,t)}return o}function r(e){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?i(Object(o),!0).forEach(function(n){a(e,n,o[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))})}return e}function m(e,n){if(null==e)return{};var o,t,a=function(e,n){if(null==e)return{};var o,t,a={},i=Object.keys(e);for(t=0;t<i.length;t++)o=i[t],n.indexOf(o)>=0||(a[o]=e[o]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)o=i[t],n.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(a[o]=e[o])}return a}var l=t.createContext({}),d=function(e){var n=t.useContext(l),o=n;return e&&(o="function"==typeof e?e(n):r(r({},n),e)),o},s=function(e){var n=d(e.components);return t.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},p=t.forwardRef(function(e,n){var o=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,s=m(e,["components","mdxType","originalType","parentName"]),p=d(o),u=a,h=p["".concat(l,".").concat(u)]||p[u]||c[u]||i;return o?t.createElement(h,r(r({ref:n},s),{},{components:o})):t.createElement(h,r({ref:n},s))});function u(e,n){var o=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=o.length,r=new Array(i);r[0]=p;var m={};for(var l in n)hasOwnProperty.call(n,l)&&(m[l]=n[l]);m.originalType=e,m.mdxType="string"==typeof e?e:a,r[1]=m;for(var d=2;d<i;d++)r[d]=o[d];return t.createElement.apply(null,r)}return t.createElement.apply(null,o)}p.displayName="MDXCreateElement"}}]);