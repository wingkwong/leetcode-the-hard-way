"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[1636],{58860(e,n,t){t.d(n,{xA:()=>m,yg:()=>u});var i=t(37953);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach(function(n){a(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function o(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},l=Object.keys(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),p=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},m=function(e){var n=p(e.components);return i.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},g=i.forwardRef(function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),g=p(t),u=a,f=g["".concat(s,".").concat(u)]||g[u]||d[u]||l;return t?i.createElement(f,r(r({ref:n},m),{},{components:t})):i.createElement(f,r({ref:n},m))});function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,r=new Array(l);r[0]=g;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var p=2;p<l;p++)r[p]=t[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}g.displayName="MDXCreateElement"},97007(e,n,t){t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var i=t(9346),a=(t(37953),t(58860));const l={description:"Author: @heiheihang | https://leetcode.com/problems/design-bitset/"},r="2166 - Design Bitset (Medium)",o={unversionedId:"2100-2199/design-bitset-medium",id:"2100-2199/design-bitset-medium",title:"2166 - Design Bitset (Medium)",description:"Author: @heiheihang | https://leetcode.com/problems/design-bitset/",source:"@site/solutions/2100-2199/2166-design-bitset-medium.md",sourceDirName:"2100-2199",slug:"/2100-2199/design-bitset-medium",permalink:"/solutions/2100-2199/design-bitset-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2100-2199/2166-design-bitset-medium.md",tags:[],version:"current",sidebarPosition:2166,frontMatter:{description:"Author: @heiheihang | https://leetcode.com/problems/design-bitset/"},sidebar:"tutorialSidebar",previous:{title:"2165 - Smallest Value of the Rearranged Number (Medium)",permalink:"/solutions/2100-2199/smallest-value-of-the-rearranged-number-medium"},next:{title:"2167 - Minimum Time to Remove All Cars Containing Illegal Goods (Hard)",permalink:"/solutions/2100-2199/minimum-time-to-remove-all-cars-containing-illegal-goods-hard"}},s={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Class Implementation",id:"approach-1-class-implementation",level:2}],m=(d="SolutionAuthor",function(e){return console.warn("Component "+d+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.yg)("div",e)});var d;const g={toc:p};function u({components:e,...n}){return(0,a.yg)("wrapper",(0,i.A)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"2166---design-bitset-medium"},"2166 - Design Bitset (Medium)"),(0,a.yg)("h2",{id:"problem-link"},"Problem Link"),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/design-bitset/"},"https://leetcode.com/problems/design-bitset/")),(0,a.yg)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.yg)("p",null,"A ",(0,a.yg)("strong",{parentName:"p"},"Bitset")," is a data structure that compactly stores bits."),(0,a.yg)("p",null,"Implement the ",(0,a.yg)("inlineCode",{parentName:"p"},"Bitset")," class:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"Bitset(int size)")," Initializes the Bitset with ",(0,a.yg)("inlineCode",{parentName:"li"},"size")," bits, all of which are ",(0,a.yg)("inlineCode",{parentName:"li"},"0"),"."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"void fix(int idx)")," Updates the value of the bit at the index ",(0,a.yg)("inlineCode",{parentName:"li"},"idx")," to ",(0,a.yg)("inlineCode",{parentName:"li"},"1"),". If the value was already ",(0,a.yg)("inlineCode",{parentName:"li"},"1"),", no change occurs."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"void unfix(int idx)")," Updates the value of the bit at the index ",(0,a.yg)("inlineCode",{parentName:"li"},"idx")," to ",(0,a.yg)("inlineCode",{parentName:"li"},"0"),". If the value was already ",(0,a.yg)("inlineCode",{parentName:"li"},"0"),", no change occurs."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"void flip()")," Flips the values of each bit in the Bitset. In other words, all bits with value ",(0,a.yg)("inlineCode",{parentName:"li"},"0")," will now have value ",(0,a.yg)("inlineCode",{parentName:"li"},"1")," and vice versa."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"boolean all()")," Checks if the value of ",(0,a.yg)("strong",{parentName:"li"},"each")," bit in the Bitset is ",(0,a.yg)("inlineCode",{parentName:"li"},"1"),". Returns ",(0,a.yg)("inlineCode",{parentName:"li"},"true")," if it satisfies the condition, ",(0,a.yg)("inlineCode",{parentName:"li"},"false")," otherwise."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"boolean one()")," Checks if there is ",(0,a.yg)("strong",{parentName:"li"},"at least one")," bit in the Bitset with value ",(0,a.yg)("inlineCode",{parentName:"li"},"1"),". Returns ",(0,a.yg)("inlineCode",{parentName:"li"},"true")," if it satisfies the condition, ",(0,a.yg)("inlineCode",{parentName:"li"},"false")," otherwise."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"int count()")," Returns the ",(0,a.yg)("strong",{parentName:"li"},"total number")," of bits in the Bitset which have value ",(0,a.yg)("inlineCode",{parentName:"li"},"1"),"."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"String toString()")," Returns the current composition of the Bitset. Note that in the resultant string, the character at the ",(0,a.yg)("inlineCode",{parentName:"li"},"ith")," index should coincide with the value at the ",(0,a.yg)("inlineCode",{parentName:"li"},"ith")," bit of the Bitset.")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example 1:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'Input\n["Bitset", "fix", "fix", "flip", "all", "unfix", "flip", "one", "unfix", "count", "toString"]\n[[5], [3], [1], [], [], [0], [], [], [0], [], []]\nOutput\n[null, null, null, null, false, null, null, true, null, 2, "01010"]\n\nExplanation\nBitset bs = new Bitset(5); // bitset = "00000".\nbs.fix(3);     // the value at idx = 3 is updated to 1, so bitset = "00010".\nbs.fix(1);     // the value at idx = 1 is updated to 1, so bitset = "01010".\nbs.flip();     // the value of each bit is flipped, so bitset = "10101".\nbs.all();      // return False, as not all values of the bitset are 1.\nbs.unfix(0);   // the value at idx = 0 is updated to 0, so bitset = "00101".\nbs.flip();     // the value of each bit is flipped, so bitset = "11010".\nbs.one();      // return True, as there is at least 1 index with value 1.\nbs.unfix(0);   // the value at idx = 0 is updated to 0, so bitset = "01010".\nbs.count();    // return 2, as there are 2 bits with value 1.\nbs.toString(); // return "01010", which is the composition of bitset.\n')),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Constraints:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"1 <= size <= 1e5")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"0 <= idx <= size - 1")),(0,a.yg)("li",{parentName:"ul"},"At most ",(0,a.yg)("inlineCode",{parentName:"li"},"1e5")," calls will be made ",(0,a.yg)("strong",{parentName:"li"},"in total")," to ",(0,a.yg)("inlineCode",{parentName:"li"},"fix"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"unfix"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"flip"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"all"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"one"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"count"),", and ",(0,a.yg)("inlineCode",{parentName:"li"},"toString"),"."),(0,a.yg)("li",{parentName:"ul"},"At least one call will be made to ",(0,a.yg)("inlineCode",{parentName:"li"},"all"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"one"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"count"),", or ",(0,a.yg)("inlineCode",{parentName:"li"},"toString"),"."),(0,a.yg)("li",{parentName:"ul"},"At most ",(0,a.yg)("inlineCode",{parentName:"li"},"5")," calls will be made to ",(0,a.yg)("inlineCode",{parentName:"li"},"toString"),".")),(0,a.yg)("h2",{id:"approach-1-class-implementation"},"Approach 1: Class Implementation"),(0,a.yg)("p",null,"In general, we need to keep track of 3 things:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"The state of the bits"),(0,a.yg)("li",{parentName:"ul"},"The number of 1s"),(0,a.yg)("li",{parentName:"ul"},"Flipped or not")),(0,a.yg)("p",null,"We first consider the ",(0,a.yg)("inlineCode",{parentName:"p"},"flip")," function first. The naive way to perform ",(0,a.yg)("inlineCode",{parentName:"p"},"flip")," is to iterate over the ",(0,a.yg)("inlineCode",{parentName:"p"},"bits")," and change all the bits. This takes ",(0,a.yg)("span",{parentName:"p",className:"math math-inline"},(0,a.yg)("span",{parentName:"span",className:"katex"},(0,a.yg)("span",{parentName:"span",className:"katex-mathml"},(0,a.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,a.yg)("semantics",{parentName:"math"},(0,a.yg)("mrow",{parentName:"semantics"},(0,a.yg)("mi",{parentName:"mrow"},"O"),(0,a.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,a.yg)("mi",{parentName:"mrow"},"N"),(0,a.yg)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,a.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N)")))),(0,a.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,a.yg)("span",{parentName:"span",className:"base"},(0,a.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,a.yg)("span",{parentName:"span",className:"mopen"},"("),(0,a.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"),(0,a.yg)("span",{parentName:"span",className:"mclose"},")")))))," time and is too slow. We instead use a state called ",(0,a.yg)("inlineCode",{parentName:"p"},"flipped")," to store the state whether the ",(0,a.yg)("inlineCode",{parentName:"p"},"bits")," are flipped or not. When we call ",(0,a.yg)("inlineCode",{parentName:"p"},"flip"),", the new number of 1s in ",(0,a.yg)("inlineCode",{parentName:"p"},"bits")," becomes the old number of 0s in ",(0,a.yg)("inlineCode",{parentName:"p"},"bits"),", which can be calculated by ",(0,a.yg)("inlineCode",{parentName:"p"},"len(bits) - ones"),"."),(0,a.yg)("p",null,"We then consider ",(0,a.yg)("inlineCode",{parentName:"p"},"fix")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"unfix"),". These two functions require certain condition of the target bit to activate. If we want to check a bit is ",(0,a.yg)("inlineCode",{parentName:"p"},"1")," or not, we have two possibilities"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"target bit is ",(0,a.yg)("inlineCode",{parentName:"li"},"0"),", and ",(0,a.yg)("inlineCode",{parentName:"li"},"flipped = True")),(0,a.yg)("li",{parentName:"ul"},"target bit is ",(0,a.yg)("inlineCode",{parentName:"li"},"1"),", and ",(0,a.yg)("inlineCode",{parentName:"li"},"flipped = False"))),(0,a.yg)("p",null,"Then we update the target bit and ",(0,a.yg)("inlineCode",{parentName:"p"},"ones")," accordingly."),(0,a.yg)("p",null,"Similar logic applies to ",(0,a.yg)("inlineCode",{parentName:"p"},"toString")," that we need to accommodate the state of ",(0,a.yg)("inlineCode",{parentName:"p"},"flipped")),(0,a.yg)(m,{name:"@heiheihang",mdxType:"SolutionAuthor"}),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-python"},'class Bitset:\n\n    def __init__(self, size: int):\n\n        #record the state of the bit\n        self.bits = [0] * size\n\n        #record the number of ones\n        self.ones = 0\n\n        #record if flip is called\n        self.flipped = False\n\n\n    def fix(self, idx: int) -> None:\n\n        #we need to check if the target bit is 0 (if not flipped -> 0) or 1 (if flipped -> 0)\n        if(self.bits[idx] == 0 and not self.flipped or self.bits[idx] == 1 and self.flipped):\n\n            #add 1 to ones if it is 0 (after considering flip)\n            self.ones += 1\n\n            #change its state\n            self.bits[idx] = (self.bits[idx] + 1) % 2\n\n\n    def unfix(self, idx: int) -> None:\n\n        #we need to check if the target bit is 1 (if not flipped -> 1) or 0 (if flipped -> 1)\n        if(self.bits[idx] == 1 and not self.flipped or self.bits[idx] == 0 and self.flipped):\n\n            #decrease 1 to ones if it is 1 (after considering flip)\n            self.ones -= 1\n\n            #change its state\n            self.bits[idx] = (self.bits[idx] + 1) % 2\n\n    #this needs to be O(1)!\n    def flip(self) -> None:\n\n        #we reverse the number of ones after flip\n        self.ones = len(self.bits) - self.ones\n\n        #update the state of flipped\n        if(self.flipped):\n            self.flipped = False\n        else:\n            self.flipped = True\n\n    def all(self) -> bool:\n\n        #check if number of ones equals to the length of bits\n        if(self.ones == len(self.bits)):\n            return True\n        return False\n\n    def one(self) -> bool:\n\n        #check if there is at least one 1\n        if(self.ones > 0):\n            return True\n        return False\n\n    def count(self) -> int:\n\n        #return the number of ones\n        return self.ones\n\n    def toString(self) -> str:\n\n        #initialize the result\n        res = []\n\n        if(self.flipped):\n\n            for i in range(len(self.bits)):\n\n                #if flipped, we need to put the reverse of the bit to result\n                res.append(str((self.bits[i] + 1) % 2))\n        else:\n            for i in range(len(self.bits)):\n\n                #put the bit to result\n                res.append(str(self.bits[i]))\n\n        #return the string of list\n        return "".join(res)\n')))}u.isMDXComponent=!0}}]);