"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[88137],{42962(e,t,r){r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>v,frontMatter:()=>o,metadata:()=>s,suggestedProblems:()=>u,toc:()=>m});var n=r(9346),i=(r(37953),r(58860));const o={title:"Sieve of Eratosthenes",description:"Sieve of Eratosthenes is a way of finding all prime numbers up to N (inclusive).",hide_table_of_contents:!0,keywords:["leetcode","tutorial","sieve of eratosthenes","algorithm"]},a=void 0,s={unversionedId:"math/number-theory/sieve-of-eratosthenes",id:"math/number-theory/sieve-of-eratosthenes",title:"Sieve of Eratosthenes",description:"Sieve of Eratosthenes is a way of finding all prime numbers up to N (inclusive).",source:"@site/tutorials/math/number-theory/sieve-of-eratosthenes.md",sourceDirName:"math/number-theory",slug:"/math/number-theory/sieve-of-eratosthenes",permalink:"/tutorials/math/number-theory/sieve-of-eratosthenes",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/math/number-theory/sieve-of-eratosthenes.md",tags:[],version:"current",frontMatter:{title:"Sieve of Eratosthenes",description:"Sieve of Eratosthenes is a way of finding all prime numbers up to N (inclusive).",hide_table_of_contents:!0,keywords:["leetcode","tutorial","sieve of eratosthenes","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Binary Exponentiation",permalink:"/tutorials/math/number-theory/binary-exponentiation"},next:{title:"Bit Manipulation",permalink:"/tutorials/math/bit-manipulation"}},l={},m=[{value:"Overview",id:"overview",level:2},{value:"Implementation",id:"implementation",level:2}],u=[{problemName:"0204 - Count Primes",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/count-primes/",solutionLink:"../../../solutions/0200-0299/count-primes"}],p=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.yg)("div",t)},c=p("TutorialCredits"),h=p("Tabs"),f=p("TabItem"),d=p("SolutionAuthor"),y=p("Table"),b={toc:m,suggestedProblems:u};function v({components:e,...t}){return(0,i.yg)("wrapper",(0,n.A)({},b,t,{components:e,mdxType:"MDXLayout"}),(0,i.yg)(c,{authors:"@wkw",mdxType:"TutorialCredits"}),(0,i.yg)("h2",{id:"overview"},"Overview"),(0,i.yg)("p",null,"The Sieve of Eratosthenes is an algorithm used to find all prime numbers up to a given limit. It works by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with 2. The algorithm starts by creating a list of all integers from 2 to the limit. It then marks the first number, 2, as prime and removes all multiples of 2 from the list. The next unmarked number in the list is 3, which is also prime, so it marks it and removes all multiples of 3 from the list. This process continues until all numbers in the list have been marked as prime or composite. The remaining unmarked numbers are the prime numbers up to the given limit."),(0,i.yg)("h2",{id:"implementation"},"Implementation"),(0,i.yg)(h,{mdxType:"Tabs"},(0,i.yg)(f,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.yg)(d,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"vector<bool> sieveOfEratosthenes(const int n) {\n  vector<bool> isPrime(n + 1, true);\n  isPrime[0] = isPrime[1] = false;\n  for (int i = 2; i * i <= n; i++) {\n    if (isPrime[i]) {\n      for (int j = i * i; j <= n; j += i) {\n        isPrime[j] = false;\n      }\n    }\n  }\n  return isPrime;\n}\n")))),(0,i.yg)(y,{title:"Suggested Problems",data:u,mdxType:"Table"}))}v.isMDXComponent=!0},58860(e,t,r){r.d(t,{xA:()=>u,yg:()=>h});var n=r(37953);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach(function(t){i(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),m=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},u=function(e){var t=m(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef(function(e,t){var r=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=m(r),h=i,f=c["".concat(l,".").concat(h)]||c[h]||p[h]||o;return r?n.createElement(f,a(a({ref:t},u),{},{components:r})):n.createElement(f,a({ref:t},u))});function h(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=r.length,a=new Array(o);a[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var m=2;m<o;m++)a[m]=r[m];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}c.displayName="MDXCreateElement"}}]);