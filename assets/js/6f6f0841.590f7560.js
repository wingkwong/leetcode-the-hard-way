"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[71826],{91276:i=>{i.exports=JSON.parse('{"version":{"pluginId":"tutorials","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"Basic Topics","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Arrays","href":"/tutorials/basic-topics/arrays","docId":"basic-topics/arrays","unlisted":false},{"type":"link","label":"Backtracking","href":"/tutorials/basic-topics/backtracking","docId":"basic-topics/backtracking","unlisted":false},{"type":"link","label":"Binary Search","href":"/tutorials/basic-topics/binary-search","docId":"basic-topics/binary-search","unlisted":false},{"type":"link","label":"Brute Force","href":"/tutorials/basic-topics/brute-force","docId":"basic-topics/brute-force","unlisted":false},{"type":"link","label":"Greedy","href":"/tutorials/basic-topics/greedy","docId":"basic-topics/greedy","unlisted":false},{"type":"link","label":"Hash Map","href":"/tutorials/basic-topics/hash-map","docId":"basic-topics/hash-map","unlisted":false},{"type":"link","label":"Heap (Priority Queue)","href":"/tutorials/basic-topics/heap","docId":"basic-topics/heap","unlisted":false},{"type":"link","label":"Kadane Algorithm","href":"/tutorials/basic-topics/kadane","docId":"basic-topics/kadane","unlisted":false},{"type":"link","label":"Linear Search","href":"/tutorials/basic-topics/linear-search","docId":"basic-topics/linear-search","unlisted":false},{"type":"link","label":"Linked List","href":"/tutorials/basic-topics/linked-list","docId":"basic-topics/linked-list","unlisted":false},{"type":"link","label":"MOD (1e9 + 7)","href":"/tutorials/basic-topics/mod","docId":"basic-topics/mod","unlisted":false},{"type":"link","label":"Prefix Sum","href":"/tutorials/basic-topics/prefix-sum","docId":"basic-topics/prefix-sum","unlisted":false},{"type":"link","label":"Queue & Stack","href":"/tutorials/basic-topics/queue-and-stack","docId":"basic-topics/queue-and-stack","unlisted":false},{"type":"link","label":"Sliding Window","href":"/tutorials/basic-topics/sliding-window","docId":"basic-topics/sliding-window","unlisted":false},{"type":"category","label":"Sorting","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/tutorials/basic-topics/sorting/introduction","docId":"basic-topics/sorting/introduction","unlisted":false},{"type":"link","label":"Bubble Sort","href":"/tutorials/basic-topics/sorting/bubble-sort","docId":"basic-topics/sorting/bubble-sort","unlisted":false},{"type":"link","label":"Cyclic Sort","href":"/tutorials/basic-topics/sorting/cyclic-sort","docId":"basic-topics/sorting/cyclic-sort","unlisted":false},{"type":"link","label":"Insertion Sort","href":"/tutorials/basic-topics/sorting/insertion-sort","docId":"basic-topics/sorting/insertion-sort","unlisted":false},{"type":"link","label":"Merge Sort","href":"/tutorials/basic-topics/sorting/merge-sort","docId":"basic-topics/sorting/merge-sort","unlisted":false},{"type":"link","label":"Selection Sort","href":"/tutorials/basic-topics/sorting/selection-sort","docId":"basic-topics/sorting/selection-sort","unlisted":false},{"type":"link","label":"Shell Sort","href":"/tutorials/basic-topics/sorting/shell-sort","docId":"basic-topics/sorting/shell-sort","unlisted":false},{"type":"link","label":"Tim Sort","href":"/tutorials/basic-topics/sorting/tim-sort","docId":"basic-topics/sorting/tim-sort","unlisted":false}],"href":"/tutorials/category/sorting"},{"type":"link","label":"Time Complexity","href":"/tutorials/basic-topics/time-complexity","docId":"basic-topics/time-complexity","unlisted":false},{"type":"link","label":"Trie","href":"/tutorials/basic-topics/trie","docId":"basic-topics/trie","unlisted":false},{"type":"link","label":"Two Pointers","href":"/tutorials/basic-topics/two-pointers","docId":"basic-topics/two-pointers","unlisted":false}],"href":"/tutorials/category/basic-topics"},{"type":"category","label":"Graph Theory","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/tutorials/graph-theory/introduction","docId":"graph-theory/introduction","unlisted":false},{"type":"link","label":"Bellman Ford Algorithm","href":"/tutorials/graph-theory/bellman-ford-algorithm","docId":"graph-theory/bellman-ford-algorithm","unlisted":false},{"type":"link","label":"Binary Search Tree","href":"/tutorials/graph-theory/binary-search-tree","docId":"graph-theory/binary-search-tree","unlisted":false},{"type":"link","label":"Binary Tree","href":"/tutorials/graph-theory/binary-tree","docId":"graph-theory/binary-tree","unlisted":false},{"type":"link","label":"Breadth First Search (BFS)","href":"/tutorials/graph-theory/breadth-first-search","docId":"graph-theory/breadth-first-search","unlisted":false},{"type":"link","label":"Depth First Search (DFS)","href":"/tutorials/graph-theory/depth-first-search","docId":"graph-theory/depth-first-search","unlisted":false},{"type":"link","label":"Dijkstra\'s Algorithm","href":"/tutorials/graph-theory/dijkstra","docId":"graph-theory/dijkstra","unlisted":false},{"type":"link","label":"Disjoint Set Union (DSU)","href":"/tutorials/graph-theory/disjoint-set-union","docId":"graph-theory/disjoint-set-union","unlisted":false},{"type":"link","label":"Kahn\'s Algorithm","href":"/tutorials/graph-theory/kahns-algorithm","docId":"graph-theory/kahns-algorithm","unlisted":false},{"type":"link","label":"Kruskal\'s Algorithm","href":"/tutorials/graph-theory/kruskals-algorithm","docId":"graph-theory/kruskals-algorithm","unlisted":false},{"type":"link","label":"Lowest Common Ancestor(LCA)","href":"/tutorials/graph-theory/lca","docId":"graph-theory/lca","unlisted":false},{"type":"link","label":"Minimum Spanning Tree","href":"/tutorials/graph-theory/minimum-spanning-tree","docId":"graph-theory/minimum-spanning-tree","unlisted":false},{"type":"link","label":"Tarjan\'s Algorithm","href":"/tutorials/graph-theory/tarjans-algorithm","docId":"graph-theory/tarjans-algorithm","unlisted":false},{"type":"link","label":"Topological Sorting","href":"/tutorials/graph-theory/topological-sorting","docId":"graph-theory/topological-sorting","unlisted":false}],"href":"/tutorials/category/graph-theory"},{"type":"category","label":"Math","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"Number Theory","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Binary Exponentiation","href":"/tutorials/math/number-theory/binary-exponentiation","docId":"math/number-theory/binary-exponentiation","unlisted":false},{"type":"link","label":"Sieve of Eratosthenes","href":"/tutorials/math/number-theory/sieve-of-eratosthenes","docId":"math/number-theory/sieve-of-eratosthenes","unlisted":false}],"href":"/tutorials/category/number-theory"},{"type":"link","label":"Bit Manipulation","href":"/tutorials/math/bit-manipulation","docId":"math/bit-manipulation","unlisted":false},{"type":"link","label":"Combinatorics","href":"/tutorials/math/combinatorics","docId":"math/combinatorics","unlisted":false},{"type":"link","label":"Matrix Exponentiation","href":"/tutorials/math/matrix-exponentiation","docId":"math/matrix-exponentiation","unlisted":false},{"type":"link","label":"Prime Factors","href":"/tutorials/math/prime-factors","docId":"math/prime-factors","unlisted":false}],"href":"/tutorials/category/math"},{"type":"category","label":"Strings","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Manacher\'s Algorithm","href":"/tutorials/strings/manachers-algorithm","docId":"strings/manachers-algorithm","unlisted":false},{"type":"link","label":"Palindrome","href":"/tutorials/strings/palindrome","docId":"strings/palindrome","unlisted":false},{"type":"link","label":"Z Algorithm","href":"/tutorials/strings/z-algorithm","docId":"strings/z-algorithm","unlisted":false}],"href":"/tutorials/category/strings"}]},"docs":{"basic-topics/arrays":{"id":"basic-topics/arrays","title":"Arrays","description":"An array is a data structure consisting of a collection of elements.","sidebar":"tutorialSidebar"},"basic-topics/backtracking":{"id":"basic-topics/backtracking","title":"Backtracking","description":"A backtracking algorithm is used to construct a solution recursively by starting with an empty solution and adding solution one by one.","sidebar":"tutorialSidebar"},"basic-topics/binary-search":{"id":"basic-topics/binary-search","title":"Binary Search","description":"Binary search is the searching strategy that reduces the search space by half every iteration until you have found the target.","sidebar":"tutorialSidebar"},"basic-topics/brute-force":{"id":"basic-topics/brute-force","title":"Brute Force","description":"Brute Force is used when the problem size is limited","sidebar":"tutorialSidebar"},"basic-topics/greedy":{"id":"basic-topics/greedy","title":"Greedy","description":"Designing greedy algorithms to find a greedy strategy that produces an optimal solution to the problem","sidebar":"tutorialSidebar"},"basic-topics/hash-map":{"id":"basic-topics/hash-map","title":"Hash Map","description":"Hash Map provides quick lookup of certain values in O(1) time.","sidebar":"tutorialSidebar"},"basic-topics/heap":{"id":"basic-topics/heap","title":"Heap (Priority Queue)","description":"A heap, or a priority queue, is a data structure that efficiently stores elements in a particular order.","sidebar":"tutorialSidebar"},"basic-topics/kadane":{"id":"basic-topics/kadane","title":"Kadane Algorithm","description":"Kadane 1D algorithm finds the maximum sum subarray in an array of integers. Kadane 2D algorithm finds the maximum sum subarray in a 2D array of integers.","sidebar":"tutorialSidebar"},"basic-topics/linear-search":{"id":"basic-topics/linear-search","title":"Linear Search","description":"Linear search is a searching technique that works in a linear / sequential fashion. It traverses whole of the data structure and returns the position(s) where the value is found. If not found then it simple returns nothing.","sidebar":"tutorialSidebar"},"basic-topics/linked-list":{"id":"basic-topics/linked-list","title":"Linked List","description":"A linked list is a linear data structure that consists of nodes. Each node stores some data as well as the address of the next node.","sidebar":"tutorialSidebar"},"basic-topics/mod":{"id":"basic-topics/mod","title":"MOD (1e9 + 7)","description":"Mod 1e9+7","sidebar":"tutorialSidebar"},"basic-topics/prefix-sum":{"id":"basic-topics/prefix-sum","title":"Prefix Sum","description":"Prefix Sum is the sums of prefixes of the input sequence","sidebar":"tutorialSidebar"},"basic-topics/queue-and-stack":{"id":"basic-topics/queue-and-stack","title":"Queue & Stack","description":"Stack is the data structure The first item that comes in will be the first to go out.","sidebar":"tutorialSidebar"},"basic-topics/sliding-window":{"id":"basic-topics/sliding-window","title":"Sliding Window","description":"Sliding window is a technique used to solve problems in array or string.","sidebar":"tutorialSidebar"},"basic-topics/sorting/bubble-sort":{"id":"basic-topics/sorting/bubble-sort","title":"Bubble Sort","description":"It is sorting algorithm based on the idea of repeatedly comparing pairs of adjacent elements and then swapping their positions if they exist in the wrong order.","sidebar":"tutorialSidebar"},"basic-topics/sorting/cyclic-sort":{"id":"basic-topics/sorting/cyclic-sort","title":"Cyclic Sort","description":"Cyclic Sort is a comparison sort algorithm that is theoretically optimal in terms of the total number of writes to the original array.","sidebar":"tutorialSidebar"},"basic-topics/sorting/insertion-sort":{"id":"basic-topics/sorting/insertion-sort","title":"Insertion Sort","description":"An sorting algorithm based on picking one element at a time and inserting it in sorted order.","sidebar":"tutorialSidebar"},"basic-topics/sorting/introduction":{"id":"basic-topics/sorting/introduction","title":"Introduction","description":"Introduction and overview of sorting","sidebar":"tutorialSidebar"},"basic-topics/sorting/merge-sort":{"id":"basic-topics/sorting/merge-sort","title":"Merge Sort","description":"A sorting algorithm based on divide-and-conquer strategy","sidebar":"tutorialSidebar"},"basic-topics/sorting/selection-sort":{"id":"basic-topics/sorting/selection-sort","title":"Selection Sort","description":"Selection sort is an comparison sorting algorithm that finds the minimum value each time.","sidebar":"tutorialSidebar"},"basic-topics/sorting/shell-sort":{"id":"basic-topics/sorting/shell-sort","title":"Shell Sort","description":"Sorting algorithm using a gap-based strategy to improve efficiency of sorting process","sidebar":"tutorialSidebar"},"basic-topics/sorting/tim-sort":{"id":"basic-topics/sorting/tim-sort","title":"Tim Sort","description":"Timsort is a fast stable sorting algorithm based upon insertion sort and merge sort.","sidebar":"tutorialSidebar"},"basic-topics/time-complexity":{"id":"basic-topics/time-complexity","title":"Time Complexity","description":"Time Complexity is one of the important measurements when it comes to writing an efficient solution.","sidebar":"tutorialSidebar"},"basic-topics/trie":{"id":"basic-topics/trie","title":"Trie","description":"A trie or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings.","sidebar":"tutorialSidebar"},"basic-topics/two-pointers":{"id":"basic-topics/two-pointers","title":"Two Pointers","description":"Two Pointers is an effective technique used for searching pairs in a sorted array.","sidebar":"tutorialSidebar"},"graph-theory/bellman-ford-algorithm":{"id":"graph-theory/bellman-ford-algorithm","title":"Bellman Ford Algorithm","description":"Bellman Ford Algorithm computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph","sidebar":"tutorialSidebar"},"graph-theory/binary-search-tree":{"id":"graph-theory/binary-search-tree","title":"Binary Search Tree","description":"A binary tree where left child is less than or equal to the parent, while the right child is greater","sidebar":"tutorialSidebar"},"graph-theory/binary-tree":{"id":"graph-theory/binary-tree","title":"Binary Tree","description":"Binary Tree is a tree structure in which eacho node only contains at most two children","sidebar":"tutorialSidebar"},"graph-theory/breadth-first-search":{"id":"graph-theory/breadth-first-search","title":"Breadth First Search (BFS)","description":"In BFS, we explore all the closest nodes first before going one step further.","sidebar":"tutorialSidebar"},"graph-theory/depth-first-search":{"id":"graph-theory/depth-first-search","title":"Depth First Search (DFS)","description":"In DFS, we aim to finish one branch before looking at other branches.","sidebar":"tutorialSidebar"},"graph-theory/dijkstra":{"id":"graph-theory/dijkstra","title":"Dijkstra\'s Algorithm","description":"Dijkstra\'s Algorithm is used to find the shortest paths between nodes in a graph.","sidebar":"tutorialSidebar"},"graph-theory/disjoint-set-union":{"id":"graph-theory/disjoint-set-union","title":"Disjoint Set Union (DSU)","description":"Disjoint Set Union is a data structure that allows us to combine any two sets into one.","sidebar":"tutorialSidebar"},"graph-theory/introduction":{"id":"graph-theory/introduction","title":"Introduction","description":"Graphs can solve a plethora of interesting problems!","sidebar":"tutorialSidebar"},"graph-theory/kahns-algorithm":{"id":"graph-theory/kahns-algorithm","title":"Kahn\'s Algorithm","description":"Kahn\'s Algorithm is a classical algorithm in computer science that is used for topological sorting of directed acyclic graphs (DAGs)","sidebar":"tutorialSidebar"},"graph-theory/kruskals-algorithm":{"id":"graph-theory/kruskals-algorithm","title":"Kruskal\'s Algorithm","description":"Kruskal\'s algorithm is a greedy algorithm used to find the minimum spanning tree of a connected, undirected graph.","sidebar":"tutorialSidebar"},"graph-theory/lca":{"id":"graph-theory/lca","title":"Lowest Common Ancestor(LCA)","description":"Lowest common ancestor (LCA) of two nodes x and y is the deepest(lowest) node that has both x and y as descendants","sidebar":"tutorialSidebar"},"graph-theory/minimum-spanning-tree":{"id":"graph-theory/minimum-spanning-tree","title":"Minimum Spanning Tree","description":"A minimum spanning tree is a subset of the edges of a connected undirected graph with the minimum possible total edge weight and it does not contain any cycles.","sidebar":"tutorialSidebar"},"graph-theory/tarjans-algorithm":{"id":"graph-theory/tarjans-algorithm","title":"Tarjan\'s Algorithm","description":"Tarjan\'s algorithm can be used to determine the Strongly Connected Components of a directed graph.","sidebar":"tutorialSidebar"},"graph-theory/topological-sorting":{"id":"graph-theory/topological-sorting","title":"Topological Sorting","description":"Topological Sorting is a linear ordering of its vertices such that for every directed edge (u, v) from vertex u to vertex v, u comes before v in the ordering.","sidebar":"tutorialSidebar"},"math/bit-manipulation":{"id":"math/bit-manipulation","title":"Bit Manipulation","description":"Bit Manipulation utilises different bitwise operations to manipulate bits","sidebar":"tutorialSidebar"},"math/combinatorics":{"id":"math/combinatorics","title":"Combinatorics","description":"Combinatorics is the branch of mathematics dealing with counting and enumerating the possibilities for a certain event to occur. It is heavily used as it enables us to find very short and concise answers to many problems.","sidebar":"tutorialSidebar"},"math/matrix-exponentiation":{"id":"math/matrix-exponentiation","title":"Matrix Exponentiation","description":"Binary Exponentiation but it involves matrices.","sidebar":"tutorialSidebar"},"math/number-theory/binary-exponentiation":{"id":"math/number-theory/binary-exponentiation","title":"Binary Exponentiation","description":"Binary Exponentiation is also known as Exponentiation by Squaring.","sidebar":"tutorialSidebar"},"math/number-theory/sieve-of-eratosthenes":{"id":"math/number-theory/sieve-of-eratosthenes","title":"Sieve of Eratosthenes","description":"Sieve of Eratosthenes is a way of finding all prime numbers up to N (inclusive).","sidebar":"tutorialSidebar"},"math/prime-factors":{"id":"math/prime-factors","title":"Prime Factors","description":"Factor of a given number which is a prime number.","sidebar":"tutorialSidebar"},"strings/manachers-algorithm":{"id":"strings/manachers-algorithm","title":"Manacher\'s Algorithm","description":"A famous algorithm and the fastest known technique to find palindromic substrings of even or odd length.","sidebar":"tutorialSidebar"},"strings/palindrome":{"id":"strings/palindrome","title":"Palindrome","description":"A palindrome is a word, number, phrase, or other sequence of characters which reads the same backward as forward.","sidebar":"tutorialSidebar"},"strings/z-algorithm":{"id":"strings/z-algorithm","title":"Z Algorithm","description":"Z Algorithm is a string matching algorithm with O(n) complexity","sidebar":"tutorialSidebar"}}}}')}}]);