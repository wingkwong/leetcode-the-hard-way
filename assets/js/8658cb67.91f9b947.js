"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[67708],{3226(e,a,n){n.r(a),n.d(a,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>m,toc:()=>i});var t=n(9346),r=(n(37953),n(58860));const s={title:"Topological Sorting",description:"Topological Sorting is a linear ordering of its vertices such that for every directed edge (u, v) from vertex u to vertex v, u comes before v in the ordering.",keywords:["leetcode","tutorial","topological sorting","algorithm"]},o=void 0,m={unversionedId:"graph-theory/topological-sorting",id:"graph-theory/topological-sorting",title:"Topological Sorting",description:"Topological Sorting is a linear ordering of its vertices such that for every directed edge (u, v) from vertex u to vertex v, u comes before v in the ordering.",source:"@site/tutorials/graph-theory/topological-sorting.md",sourceDirName:"graph-theory",slug:"/graph-theory/topological-sorting",permalink:"/tutorials/graph-theory/topological-sorting",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/graph-theory/topological-sorting.md",tags:[],version:"current",frontMatter:{title:"Topological Sorting",description:"Topological Sorting is a linear ordering of its vertices such that for every directed edge (u, v) from vertex u to vertex v, u comes before v in the ordering.",keywords:["leetcode","tutorial","topological sorting","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Tarjan's Algorithm",permalink:"/tutorials/graph-theory/tarjans-algorithm"},next:{title:"Math",permalink:"/tutorials/category/math"}},p={},i=[{value:"Overview",id:"overview",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Example 1: 0207 - Course Schedule",id:"example-1-0207---course-schedule",level:2},{value:"Example 2: 0210 - Course Schedule II",id:"example-2-0210---course-schedule-ii",level:2},{value:"Example 3: 1136. Parallel Courses",id:"example-3-1136-parallel-courses",level:2}],l=e=>function(a){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.yg)("div",a)},g=l("TutorialCredits"),c=l("Tabs"),h=l("TabItem"),y=l("SolutionAuthor"),d={toc:i};function u({components:e,...a}){return(0,r.yg)("wrapper",(0,t.A)({},d,a,{components:e,mdxType:"MDXLayout"}),(0,r.yg)(g,{authors:"@wkw",mdxType:"TutorialCredits"}),(0,r.yg)("h2",{id:"overview"},"Overview"),(0,r.yg)("p",null,"Topological Sorting is a linear ordering of its vertices such that for every directed edge ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.yg)("mi",{parentName:"mrow"},"u"),(0,r.yg)("mo",{parentName:"mrow",separator:"true"},","),(0,r.yg)("mi",{parentName:"mrow"},"v"),(0,r.yg)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"(u, v)")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.yg)("span",{parentName:"span",className:"mopen"},"("),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"u"),(0,r.yg)("span",{parentName:"span",className:"mpunct"},","),(0,r.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"v"),(0,r.yg)("span",{parentName:"span",className:"mclose"},")")))))," from vertex ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"u")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"u")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"u")))))," to vertex ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"v")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"v")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"v"))))),", ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"u")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"u")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"u")))))," comes before ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"v")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"v")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"v")))))," in the ordering."),(0,r.yg)("p",null,"In order to find the order, we start from those nodes which do not have any prerequisites / dependencies. In other word, those nodes with indegree ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mn",{parentName:"mrow"},"0")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"0")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.yg)("span",{parentName:"span",className:"mord"},"0"))))),". Then we incrementally add the nodes to the order following the given prerequisites. For each node with an edge, we remove the edge from the graph. By doing so, there would be more nodes without dependency. At the end, there is no edges that can be removed, which gives two possible results. The first one is a cycle is form which cannot remove in above steps. The second one is all the edges from the graph have been removed and we got the topological order of the graph."),(0,r.yg)("p",null,"The time complexity would be ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"O"),(0,r.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.yg)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.yg)("mi",{parentName:"mrow"},"E"),(0,r.yg)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.yg)("mo",{parentName:"mrow"},"+"),(0,r.yg)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.yg)("mi",{parentName:"mrow"},"V"),(0,r.yg)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.yg)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(|E| + |V|)")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.yg)("span",{parentName:"span",className:"mopen"},"("),(0,r.yg)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05764em"}},"E"),(0,r.yg)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.yg)("span",{parentName:"span",className:"mbin"},"+"),(0,r.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.yg)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V"),(0,r.yg)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.yg)("span",{parentName:"span",className:"mclose"},")"))))),"."),(0,r.yg)("h2",{id:"implementation"},"Implementation"),(0,r.yg)("p",null,"The following implementation is using BFS."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"G")," is the graph built with the dependencies"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"indegree")," is used to record the indegree of given node"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"orders")," is the topologically sorted order"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"isTopologicalSorted")," is used to determine if the graph can be topologically sorted or not")),(0,r.yg)(c,{mdxType:"Tabs"},(0,r.yg)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.yg)(y,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},"struct TopologicalSort {\n    int n;\n    vector<int> indegree;\n    vector<int> orders;\n    vector<vector<int>> G;\n    bool isTopologicalSorted = false;\n    int steps = 0;\n    int nodes = 0;\n\n    TopologicalSort(vector<vector<int>>& g, vector<int>& in) {\n        G = g;\n        n = (int) G.size();\n        indegree = in;\n\n        int res = 0;\n        queue<int> q;\n        for(int i = 0; i < n; i++) {\n            if(indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n        while(!q.empty()) {\n            int sz = q.size();\n            steps += 1;\n            nodes += q.size();\n            for (int i = 0; i < sz; i++) {\n                auto u = q.front(); q.pop();\n                orders.push_back(u);\n                for(auto v : G[u]) {\n                    if(--indegree[v] == 0) {\n                        q.push(v);\n                    }\n                }\n            }\n        }\n        isTopologicalSorted = nodes == n;\n    }\n};\n")))),(0,r.yg)("h2",{id:"example-1-0207---course-schedule"},"Example 1: ",(0,r.yg)("a",{parentName:"h2",href:"https://leetcode.com/problems/course-schedule/"},"0207 - Course Schedule")),(0,r.yg)(c,{mdxType:"Tabs"},(0,r.yg)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.yg)(y,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},"// ...\n// TopologicalSort implementation here\n// ...\n\nclass Solution {\npublic:\n    bool canFinish(int n, vector<vector<int>>& prerequisites) {\n        // define the graph\n        vector<vector<int>> g(n);\n        // define indegree\n        vector<int> indegree(n);\n        // build the graph\n        for(auto p : prerequisites) {\n            // we have to take p[1] in order to take p[0]\n            g[p[1]].push_back(p[0]);\n            // increase indegree by 1 for p[0]\n            indegree[p[0]]++;\n        }\n        // init topological sort\n        TopologicalSort ts(g, indegree);\n        // we can finish all courses only if we can topologically sort\n        return ts.isTopologicalSorted;\n    }\n};\n")))),(0,r.yg)("h2",{id:"example-2-0210---course-schedule-ii"},"Example 2: ",(0,r.yg)("a",{parentName:"h2",href:"https://leetcode.com/problems/course-schedule-ii/"},"0210 - Course Schedule II")),(0,r.yg)(c,{mdxType:"Tabs"},(0,r.yg)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.yg)(y,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},"// ...\n// TopologicalSort implementation here\n// ...\n\nclass Solution {\npublic:\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\n        // define the graph\n        vector<vector<int>> g(n);\n        // define indegree\n        vector<int> indegree(n);\n        // build the graph\n        for(auto p : prerequisites) {\n            // we have to take p[1] in order to take p[0]\n            g[p[1]].push_back(p[0]);\n            // increase indegree by 1 for p[0]\n            indegree[p[0]]++;\n        }\n        // init topological sort\n        TopologicalSort ts(g, indegree);\n        // we can finish all courses only if we can topologically sort\n        // hence, return an empty array if it cannot be sorted\n        if (!ts.isTopologicalSorted) return {};\n        // else return the order\n        return ts.orders;\n    }\n};\n")))),(0,r.yg)("h2",{id:"example-3-1136-parallel-courses"},"Example 3: ",(0,r.yg)("a",{parentName:"h2",href:"https://leetcode.com/problems/parallel-courses/"},"1136. Parallel Courses")),(0,r.yg)(c,{mdxType:"Tabs"},(0,r.yg)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.yg)(y,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},"// ...\n// TopologicalSort implementation here\n// ...\n\nclass Solution {\npublic:\n    int minimumSemesters(int n, vector<vector<int>>& relations) {\n        vector<vector<int>> g(n);\n        vector<int> in(n);\n        for (auto x : relations) {\n            --x[0], --x[1];\n            g[x[0]].push_back(x[1]);\n            in[x[1]]++;\n        }\n        TopologicalSort ts(g, in);\n        return ts.isTopologicalSorted ? ts.steps : -1;\n    }\n};\n")))))}u.isMDXComponent=!0},58860(e,a,n){n.d(a,{xA:()=>l,yg:()=>h});var t=n(37953);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function s(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),n.push.apply(n,t)}return n}function o(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?s(Object(n),!0).forEach(function(a){r(e,a,n[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))})}return e}function m(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},s=Object.keys(e);for(t=0;t<s.length;t++)n=s[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(t=0;t<s.length;t++)n=s[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=t.createContext({}),i=function(e){var a=t.useContext(p),n=a;return e&&(n="function"==typeof e?e(a):o(o({},a),e)),n},l=function(e){var a=i(e.components);return t.createElement(p.Provider,{value:a},e.children)},g={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},c=t.forwardRef(function(e,a){var n=e.components,r=e.mdxType,s=e.originalType,p=e.parentName,l=m(e,["components","mdxType","originalType","parentName"]),c=i(n),h=r,y=c["".concat(p,".").concat(h)]||c[h]||g[h]||s;return n?t.createElement(y,o(o({ref:a},l),{},{components:n})):t.createElement(y,o({ref:a},l))});function h(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=c;var m={};for(var p in a)hasOwnProperty.call(a,p)&&(m[p]=a[p]);m.originalType=e,m.mdxType="string"==typeof e?e:r,o[1]=m;for(var i=2;i<s;i++)o[i]=n[i];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);