"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[3681],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),c=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(p.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=c(n),u=a,y=m["".concat(p,".").concat(u)]||m[u]||s[u]||i;return n?r.createElement(y,o(o({ref:t},d),{},{components:n})):r.createElement(y,o({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},46:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return p},default:function(){return u},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return s}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],l={description:"Author: @wingkwong | https://leetcode.com/problems/encrypt-and-decrypt-strings"},p="2227 - Encrypt and Decrypt Strings (Hard)",c={unversionedId:"2100-2199/encrypt-and-decrypt-strings-hard",id:"2100-2199/encrypt-and-decrypt-strings-hard",title:"2227 - Encrypt and Decrypt Strings (Hard)",description:"Author: @wingkwong | https://leetcode.com/problems/encrypt-and-decrypt-strings",source:"@site/solutions/2100-2199/2227-encrypt-and-decrypt-strings-hard.md",sourceDirName:"2100-2199",slug:"/2100-2199/encrypt-and-decrypt-strings-hard",permalink:"/leetcode-the-hard-way/solutions/2100-2199/encrypt-and-decrypt-strings-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/solutions/2100-2199/2227-encrypt-and-decrypt-strings-hard.md",tags:[],version:"current",lastUpdatedBy:"Wing-Kam Wong",lastUpdatedAt:1652854619,formattedLastUpdatedAt:"5/18/2022",sidebarPosition:2227,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/encrypt-and-decrypt-strings"},sidebar:"tutorialSidebar",previous:{title:"2226 - Maximum Candies Allocated to K Children (Medium)",permalink:"/leetcode-the-hard-way/solutions/2100-2199/maximum-candies-allocated-to-k-children-medium"},next:{title:"2200 - 2299",permalink:"/leetcode-the-hard-way/solutions/category/2200---2299"}},d={},s=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Hash Map",id:"approach-1-hash-map",level:2}],m={toc:s};function u(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"2227---encrypt-and-decrypt-strings-hard"},"2227 - Encrypt and Decrypt Strings (Hard)"),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"You are given a character array ",(0,i.kt)("inlineCode",{parentName:"p"},"keys")," containing ",(0,i.kt)("strong",{parentName:"p"},"unique")," characters and a string array ",(0,i.kt)("inlineCode",{parentName:"p"},"values")," containing strings of length 2. You are also given another string array ",(0,i.kt)("inlineCode",{parentName:"p"},"dictionary")," that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a ",(0,i.kt)("strong",{parentName:"p"},"0-indexed")," string."),(0,i.kt)("p",null,"A string is ",(0,i.kt)("strong",{parentName:"p"},"encrypted")," with the following process:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"For each character ",(0,i.kt)("inlineCode",{parentName:"li"},"c")," in the string, we find the index ",(0,i.kt)("inlineCode",{parentName:"li"},"i")," satisfying ",(0,i.kt)("inlineCode",{parentName:"li"},"keys[i] == c")," in ",(0,i.kt)("inlineCode",{parentName:"li"},"keys"),"."),(0,i.kt)("li",{parentName:"ol"},"Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"c")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"values[i]")," in the string.")),(0,i.kt)("p",null,"A string is ",(0,i.kt)("strong",{parentName:"p"},"decrypted")," with the following process:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"For each substring ",(0,i.kt)("inlineCode",{parentName:"li"},"s")," of length 2 occurring at an even index in the string, we find an ",(0,i.kt)("inlineCode",{parentName:"li"},"i")," such that ",(0,i.kt)("inlineCode",{parentName:"li"},"values[i] == s"),". If there are multiple valid ",(0,i.kt)("inlineCode",{parentName:"li"},"i"),", we choose ",(0,i.kt)("strong",{parentName:"li"},"any")," one of them. This means a string could have multiple possible strings it can decrypt to."),(0,i.kt)("li",{parentName:"ol"},"Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"s")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"keys[i]")," in the string.")),(0,i.kt)("p",null,"Implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Encrypter")," class:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Encrypter(char[] keys, String[] values, String[] dictionary)")," Initializes the ",(0,i.kt)("inlineCode",{parentName:"li"},"Encrypter")," class with ",(0,i.kt)("inlineCode",{parentName:"li"},"keys, values"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"dictionary"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"String encrypt(String word1)")," Encrypts ",(0,i.kt)("inlineCode",{parentName:"li"},"word1")," with the encryption process described above and returns the encrypted string."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"int decrypt(String word2)")," Returns the number of possible strings ",(0,i.kt)("inlineCode",{parentName:"li"},"word2")," could decrypt to that also appear in ",(0,i.kt)("inlineCode",{parentName:"li"},"dictionary"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input\n["Encrypter", "encrypt", "decrypt"]\n[[[\'a\', \'b\', \'c\', \'d\'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]], ["abcd"], ["eizfeiam"]]\nOutput\n[null, "eizfeiam", 2]\n\nExplanation\nEncrypter encrypter = new Encrypter([[\'a\', \'b\', \'c\', \'d\'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]);\nencrypter.encrypt("abcd"); // return "eizfeiam". \n                           // \'a\' maps to "ei", \'b\' maps to "zf", \'c\' maps to "ei", and \'d\' maps to "am".\nencrypter.decrypt("eizfeiam"); // return 2. \n                              // "ei" can map to \'a\' or \'c\', "zf" maps to \'b\', and "am" maps to \'d\'. \n                              // Thus, the possible strings after decryption are "abad", "cbad", "abcd", and "cbcd". \n                              // 2 of those strings, "abad" and "abcd", appear in dictionary, so the answer is 2.\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= keys.length == values.length <= 26")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"values[i].length == 2")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= dictionary.length <= 100")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= dictionary[i].length <= 100")),(0,i.kt)("li",{parentName:"ul"},"All ",(0,i.kt)("inlineCode",{parentName:"li"},"keys[i]")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"dictionary[i]")," are ",(0,i.kt)("strong",{parentName:"li"},"unique"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= word1.length <= 2000")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= word2.length <= 200")),(0,i.kt)("li",{parentName:"ul"},"All ",(0,i.kt)("inlineCode",{parentName:"li"},"word1[i]")," appear in ",(0,i.kt)("inlineCode",{parentName:"li"},"keys"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"word2.length")," is even."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"keys"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"values[i]"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"dictionary[i]"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"word1"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"word2")," only contain lowercase English letters."),(0,i.kt)("li",{parentName:"ul"},"At most ",(0,i.kt)("inlineCode",{parentName:"li"},"200")," calls will be made to ",(0,i.kt)("inlineCode",{parentName:"li"},"encrypt")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"decrypt")," ",(0,i.kt)("strong",{parentName:"li"},"in total"),".")),(0,i.kt)("h2",{id:"approach-1-hash-map"},"Approach 1: Hash Map"),(0,i.kt)("p",null,"No Tries is required. We can use hash map to store the frequency of the encrypted string. To decrypt, we simply return the count of the target word. To encrypt, we find the corresponding keys to map to the returned string."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Encrypter {\npublic:\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\n        k = keys, v = values;\n        for (auto x : dictionary) m[encrypt(x)]++;\n    }\n    \n    string encrypt(string word1) {\n        string res;\n        for (auto x : word1) {\n            for(int i = 0; i < k.size(); i++) {\n                if (k[i] == x) {\n                    res += v[i];\n                }\n            }\n        }\n        return res;\n    }\n    \n    int decrypt(string word2) {\n        return m[word2];\n    }\nprivate:\n    vector<char> k;\n    vector<string> v;\n    map<string, int> m;\n};\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\n * string param_1 = obj->encrypt(word1);\n * int param_2 = obj->decrypt(word2);\n */\n")))}u.isMDXComponent=!0}}]);