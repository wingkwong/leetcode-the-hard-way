"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[29352],{6238:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"0000-0099/reverse-nodes-in-k-group-hard","title":"0025 - Reverse Nodes in k-Group (Hard)","description":"Author: @ColeB2 | https://leetcode.com/problems/reverse-nodes-in-k-group/","source":"@site/solutions/0000-0099/0025-reverse-nodes-in-k-group-hard.md","sourceDirName":"0000-0099","slug":"/0000-0099/reverse-nodes-in-k-group-hard","permalink":"/solutions/0000-0099/reverse-nodes-in-k-group-hard","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0000-0099/0025-reverse-nodes-in-k-group-hard.md","tags":[{"inline":true,"label":"Linked List","permalink":"/solutions/tags/linked-list"},{"inline":true,"label":"Recursion","permalink":"/solutions/tags/recursion"}],"version":"current","sidebarPosition":25,"frontMatter":{"description":"Author: @ColeB2 | https://leetcode.com/problems/reverse-nodes-in-k-group/","tags":["Linked List","Recursion"]},"sidebar":"tutorialSidebar","previous":{"title":"0024 - Swap Nodes in Pairs (Medium)","permalink":"/solutions/0000-0099/swap-nodes-in-pairs-medium"},"next":{"title":"0026 - Remove Duplicates from Sorted Array (Easy)","permalink":"/solutions/0000-0099/Remove-Duplicates-from-Sorted-Array-easy"}}');var i=s(86070),r=s(32790);const a={description:"Author: @ColeB2 | https://leetcode.com/problems/reverse-nodes-in-k-group/",tags:["Linked List","Recursion"]},o="0025 - Reverse Nodes in k-Group (Hard)",l={},d=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Iterative",id:"approach-1-iterative",level:2}];function h(e){const n={a:"a",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{SolutionAuthor:s,TabItem:t,Tabs:a}=n;return s||m("SolutionAuthor",!0),t||m("TabItem",!0),a||m("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"0025---reverse-nodes-in-k-group-hard",children:"0025 - Reverse Nodes in k-Group (Hard)"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/reverse-nodes-in-k-group/",children:"https://leetcode.com/problems/reverse-nodes-in-k-group/"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(n.p,{children:["Given the ",(0,i.jsx)(n.code,{children:"head"})," of a linked list, reverse the nodes of the list ",(0,i.jsx)(n.code,{children:"k"})," at a time, and return ",(0,i.jsx)(n.em,{children:"the modified list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"k"})," is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of ",(0,i.jsx)(n.code,{children:"k"})," then left-out nodes, in the end, should remain as it is."]}),"\n",(0,i.jsx)(n.p,{children:"You may not alter the values in the list's nodes, only nodes themselves may be changed."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg",alt:""})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg",alt:""})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The number of nodes in the list is ",(0,i.jsx)(n.code,{children:"n"}),"."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= k <= n <= 5000"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"0 <= Node.val <= 1000"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Follow-up:"})," Can you solve the problem in ",(0,i.jsx)(n.code,{children:"O(1)"})," extra memory space?"]}),"\n",(0,i.jsx)(n.h2,{id:"approach-1-iterative",children:"Approach 1: Iterative"}),"\n",(0,i.jsxs)(n.p,{children:["A hard question, but if we break it down, it is made up of a bunch of fairly easy linked list ideas, just used all at once. The first and most obvious one is to ",(0,i.jsx)(n.a,{href:"https://leetcodethehardway.com/solutions/0200-0299/reverse-linked-list-easy#problem-link",children:"reverse a linked list"}),". Secondly, we can use a bunch of other simple linked list tricks, that is using pointers to track interesting nodes, and a dummy head to simplify the code and basic linked list traversal."]}),"\n",(0,i.jsxs)(n.p,{children:["So first, ",(0,i.jsx)(n.a,{href:"https://leetcodethehardway.com/solutions/0200-0299/reverse-linked-list-easy#problem-link",children:"reversing"})," a linked list. I recommend you check the link to get a more in-depth answer. But simply we need to track previous and next pointers for each node to adjust the pointers and not lose track of where we are inside the linked list."]}),"\n",(0,i.jsx)(n.p,{children:"Secondly, we need a bunch of pointers:"}),"\n",(0,i.jsxs)(n.p,{children:["One will be a ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"d"}),(0,i.jsx)(n.mi,{children:"u"}),(0,i.jsx)(n.mi,{children:"m"}),(0,i.jsx)(n.mi,{children:"m"}),(0,i.jsx)(n.mi,{children:"y"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"dummy"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"d"}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"u"}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"mm"}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"})]})})]})," head that will point to the head of the linked list. This simplifies our return clause, as we know the head of the linked list won't be the return node, as the first k-group tail node will become the new head. It will also help us simplify by giving us a ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"t"}),(0,i.jsx)(n.mi,{children:"a"}),(0,i.jsx)(n.mi,{children:"i"}),(0,i.jsx)(n.mi,{children:"l"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"tail"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6944em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"ai"}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"})]})})]})," that isn't null for our first iteration."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"t"}),(0,i.jsx)(n.mi,{children:"a"}),(0,i.jsx)(n.mi,{children:"i"}),(0,i.jsx)(n.mi,{children:"l"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"tail"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6944em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"ai"}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"})]})})]})," pointer will be used for tracking the previous k-group tail node, so we can point it to the current group's head node after the reversal process."]}),"\n",(0,i.jsx)(n.p,{children:"We will also use pointers to track our current place while tracing through the linked list, as well as a pointer to point to the head of the current kgroup- linked list so we don't lose where it is."}),"\n",(0,i.jsx)(n.p,{children:"With those pointers, we can traverse through the list, counting until our counter reaches k. This gives us a tail of the current linked list group, which we will track with a pointer. From their we need to track the head of the remaining linked list, so we don't lose it, and then sever the current linked list, reverse it, and then re-attach the pointers of the previous group tail to the new head, as well as the new tail to the next groups head."}),"\n",(0,i.jsxs)(n.p,{children:["Time Complexity: ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"O"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsx)(n.mi,{children:"n"}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})})]}),". We will be touching each node twice, once while counting out nodes, and a second time during the reversal process."]}),"\n",(0,i.jsxs)(n.p,{children:["Space Complexity: ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"O"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})})]}),". We will only be using pointers and a dummy head, and nothing else to help us with our algorithm."]}),"\n",(0,i.jsx)(a,{children:(0,i.jsxs)(t,{value:"python",label:"Python",children:[(0,i.jsx)(s,{name:"@ColeB2"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseLinkedList(self, head: ListNode) -> Tuple[ListNode, ListNode]:\n        # track prev node so we can point our next pointer to it.\n        prev = None\n        # tracking node to loop through linked list.\n        node = head\n        while node:\n            # track the next node so as not to lose it while adjusting pointers.\n            nxt = node.next\n            # set next pointer to the node behind it, prev.\n            node.next = prev\n            # adjust the new prev node to be current node for subsequent loops.\n            prev = node\n            # move our node pointer up to the next node in front of it.\n            node = nxt\n        # return the new tail of the k-group which is our head.\n        return head\n\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # base case, if k == 1, skip doing all work below and just return.\n        if k == 1:\n            return head\n        # dummy node to simplify return\n        dummy = ListNode(None, head)\n        # tail of prev k-group to fix our linked lists pointers.\n        tail = dummy\n        # set a tracking node, node, to cycle through linked list and a\n        # head of current linked list, cur_head.\n        node, cur_head = head, head\n        # while tracking node is tracking a node and hasn't reached end.\n        while node:\n            # set count of current group, we start with a head so count = 1.\n            count = 1\n            # loop until count reachs k nodes.\n            while count < k:\n                # check that node is a node, and hasn't reached end of list.\n                if node:\n                    # move tracking node up, and increment counter.\n                    node = node.next\n                    count += 1\n                else:\n                    # reached end without enough nodes, return early.\n                    return dummy.next\n            # Only do below if we have enough nodes inside k-group and haven't reached end.\n            # Node is currently at the tail of the k-group After reversal\n            # it will be the head of the k-group\n            if node:\n                # track head of the next k-group.\n                nxt = node.next if node else None\n                # sever list so we can reverse it.\n                node.next = None\n                # reverse list, which will return new tail\n                new_tail = self.reverseLinkedList(cur_head)\n                # reattach our new tail back to the remaining linked list.\n                new_tail.next = nxt\n                # set prev linked lists to node, which was once the k-group's tail,\n                # but after reversal became the k-group's head\n                tail.next = node\n                # update previous k-group tail to be the current groups tail.\n                tail = new_tail\n                # set node tracker and head of next k-group linked list for next loop.\n                node, cur_head = nxt, nxt\n        # return return_head\n        return dummy.next\n\n"})})]})})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}function m(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},32790:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(30758);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);