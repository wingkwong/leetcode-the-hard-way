"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[61431],{70500:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>x,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"0300-0399/utf-8-validation-medium","title":"0393 - UTF-8 Validation (Medium)","description":"Author: @wkw | https://leetcode.com/problems/utf-8-validation/","source":"@site/solutions/0300-0399/0393-utf-8-validation-medium.md","sourceDirName":"0300-0399","slug":"/0300-0399/utf-8-validation-medium","permalink":"/solutions/0300-0399/utf-8-validation-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0300-0399/0393-utf-8-validation-medium.md","tags":[{"inline":true,"label":"Array","permalink":"/solutions/tags/array"},{"inline":true,"label":"Bit Manipulation","permalink":"/solutions/tags/bit-manipulation"}],"version":"current","sidebarPosition":393,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/utf-8-validation/","tags":["Array","Bit Manipulation"]},"sidebar":"tutorialSidebar","previous":{"title":"0392 - Is Subsequence (Easy)","permalink":"/solutions/0300-0399/is-subsequence-easy"},"next":{"title":"0400 - 0499","permalink":"/solutions/category/0400---0499"}}');var s=n(86070),o=n(32790);const r={description:"Author: @wkw | https://leetcode.com/problems/utf-8-validation/",tags:["Array","Bit Manipulation"]},a="0393 - UTF-8 Validation (Medium)",x={},l=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Bit Manipulation",id:"approach-1-bit-manipulation",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{SolutionAuthor:n,TabItem:i,Tabs:r}=t;return n||d("SolutionAuthor",!0),i||d("TabItem",!0),r||d("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"0393---utf-8-validation-medium",children:"0393 - UTF-8 Validation (Medium)"})}),"\n",(0,s.jsx)(t.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,s.jsxs)(t.p,{children:["Given an integer array ",(0,s.jsx)(t.code,{children:"data"})," representing the data, return whether it is a valid ",(0,s.jsx)(t.strong,{children:"UTF-8"})," encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters)."]}),"\n",(0,s.jsxs)(t.p,{children:["A character in ",(0,s.jsx)(t.strong,{children:"UTF8"})," can be from ",(0,s.jsx)(t.strong,{children:"1 to 4 bytes"})," long, subjected to the following rules:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["For a ",(0,s.jsx)(t.strong,{children:"1-byte"})," character, the first bit is a ",(0,s.jsx)(t.code,{children:"0"}),", followed by its Unicode code."]}),"\n",(0,s.jsxs)(t.li,{children:["For an ",(0,s.jsx)(t.strong,{children:"n-bytes"})," character, the first ",(0,s.jsx)(t.code,{children:"n"})," bits are all one's, the ",(0,s.jsx)(t.code,{children:"n + 1"})," bit is ",(0,s.jsx)(t.code,{children:"0"}),", followed by ",(0,s.jsx)(t.code,{children:"n - 1"})," bytes with the most significant ",(0,s.jsx)(t.code,{children:"2"})," bits being ",(0,s.jsx)(t.code,{children:"10"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This is how the UTF-8 encoding would work:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"Number of Bytes   |        UTF-8 Octet Sequence\n                       |              (binary)\n   --------------------+-----------------------------------------\n            1          |   0xxxxxxx\n            2          |   110xxxxx 10xxxxxx\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"x"})," denotes a bit in the binary form of a byte that may be either ",(0,s.jsx)(t.code,{children:"0"})," or ",(0,s.jsx)(t.code,{children:"1"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["**Note:**The input is an array of integers. Only the ",(0,s.jsx)(t.strong,{children:"least significant 8 bits"})," of each integer is used to store the data. This means each integer represents only 1 byte of data."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example 1:"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"Input: data = [197,130,1]\nOutput: true\nExplanation: data represents the octet sequence: 11000101 10000010 00000001.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example 2:"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"Input: data = [235,140,4]\nOutput: false\nExplanation: data represented the octet sequence: 11101011 10001100 00000100.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid.\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Constraints:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"1 <= data.length <= 2 * 10^4"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"0 <= data[i] <= 255"})}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"approach-1-bit-manipulation",children:"Approach 1: Bit Manipulation"}),"\n",(0,s.jsx)(r,{children:(0,s.jsxs)(i,{value:"cpp",label:"C++",children:[(0,s.jsx)(n,{name:"@wkw"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"// Time Complexity : O(N) where N is the number of elements in data\n// Space Complexity: O(1)\nclass Solution {\npublic:\n    // the idea is to keep track the number of segments of utf-8 octet sequence left\n    // we increase / decrease the count based on some cases\n    // first you need to know that `x >> n` means shift the number `x` `n` bits to the right\n    // e.g. shift 110xxxxx 5 bits to the right becomes 110 (in binary format)\n    // e.g. shift 11110xxx 4 bits to the right becomes 1111 (in binary format)\n    // second, 0bxxxx is a binary literal which means xxxx is a binary number\n    // alternatively, you can use decimal format but it's not that convenient in this problem\n    // e.g. 0b1110 -> 14\n    // e.g. 0b11000000 -> 192\n    bool validUtf8(vector<int>& data) {\n        // used to track the remaining number of segments\n        int remaining = 0;\n        // iterate each data and perform the following logic\n        for (auto& x : data) {\n            // case 1: there is no remaining segement left,\n            // then it means we should check the first segement of UTF-8 octet sequence\n            // i.e. 0xxxxxxx (for no of. bytes = 1)\n            // i.e. 110xxxxx (for no of. bytes = 2)\n            // i.e. 1110xxxx (for no of. bytes = 3)\n            // i.e. 11110xxx (for no of. bytes = 4)\n            if (remaining == 0) {\n                if ((x >> 5) == 0b110) {\n                    // case 1.1 - shift `x` 5 bits to the right\n                    // i.e making the first (8 - 5) = 3 bits left\n                    // e.g (110xxxxx >> 5) becomes 110 (in binary format)\n                    // if it is 0b110,\n                    // then it is only possible to form `110xxxxx 10xxxxxx`\n                    // so we set remaining to 1 to look for `10xxxxxx` later\n                    remaining = 1;\n                } else if ((x >> 4) == 0b1110) {\n                    // case 1.2 -  shift `x` 4 bits to the right\n                    // i.e making the first (8 - 4) = 4 bits left\n                    // e.g (1110xxxx >> 4) becomes 1110 (in binary format)\n                    // if it is 0b1110,\n                    // then it is only possible to form `1110xxxx 10xxxxxx 10xxxxxx`\n                    // so we set remaining to 2 to look for `10xxxxxx 10xxxxxx` later\n                     remaining = 2;\n                } else if ((x >> 3) == 0b11110) {\n                    // case 1.3 -  shift `x` 3 bits to the right\n                    // i.e making the first (8 - 3) = 5 bits left\n                    // e.g (11110xxx >> 5) becomes 11110 (in binary format)\n                    // if it is 0b11110,\n                    // then it is only possible to form `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`\n                    // so we set remaining to 3 to look for `10xxxxxx 10xxxxxx 10xxxxxx` later\n                    remaining = 3;\n                } else if ((x >> 7) != 0) {\n                     // case 1.4 -  shift `x` 7 bits to the right\n                    // i.e making the first (8 - 7) = 1 bit left\n                    // e.g (0xxxxxxx >> 7) becomes 0 (in binary format)\n                    // here we cover the last case which is when Number of Bytes = 1\n                    // we need to make sure the first bit is 0\n                    // otherwise, it is not valid\n                    return false;\n                }\n            } else {\n                // case 2: check 10xxxxxx\n                // if we enter this part, that means it may be number of bytes 2, 3, or 4.\n                // based on the table in problem statement, we know what's left is just `10xxxxxx`\n                // therefore, we shift `x` 6 bits to the right\n                // i.e making the first (8 - 6) = 2 bits left\n                // e.g (10xxxxxx >> 6) becomes 10 (in binary format)\n                // if the first 2 bits are not 10 (in binary format), then it is not valid\n                if ((x >> 6) != 0b10) return false;\n                // otherwise, this segement is ok so we decrease `remaining` by 1\n                else remaining--;\n            }\n        }\n        // at the end, remaining will be 0 if data can represent the octet sequence\n        return remaining == 0;\n    }\n};\n"})})]})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}function d(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},32790:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(30758);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);