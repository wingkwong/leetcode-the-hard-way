"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[77061],{72396:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var o=t(85893),i=t(11151);const r={description:"Author: @wingkwong | https://leetcode.com/problems/count-good-nodes-in-binary-tree/",tags:["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},a="1448 - Count Good Nodes in Binary Tree (Medium)",s={id:"1400-1499/count-good-nodes-in-binary-tree-medium",title:"1448 - Count Good Nodes in Binary Tree (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/count-good-nodes-in-binary-tree/",source:"@site/solutions/1400-1499/1448-count-good-nodes-in-binary-tree-medium.md",sourceDirName:"1400-1499",slug:"/1400-1499/count-good-nodes-in-binary-tree-medium",permalink:"/solutions/1400-1499/count-good-nodes-in-binary-tree-medium",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1400-1499/1448-count-good-nodes-in-binary-tree-medium.md",tags:[{inline:!0,label:"Tree",permalink:"/solutions/tags/tree"},{inline:!0,label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{inline:!0,label:"Breadth-First Search",permalink:"/solutions/tags/breadth-first-search"},{inline:!0,label:"Binary Tree",permalink:"/solutions/tags/binary-tree"}],version:"current",sidebarPosition:1448,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/count-good-nodes-in-binary-tree/",tags:["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},sidebar:"tutorialSidebar",previous:{title:"1443 - Minimum Time to Collect All Apples in a Tree (Medium)",permalink:"/solutions/1400-1499/minimum-time-to-collect-all-apples-in-a-tree"},next:{title:"1457 - Pseudo-Palindromic Paths in a Binary Tree (Medium)",permalink:"/solutions/1400-1499/pseudo-palindromic-paths-in-a-binary-tree-medium"}},l={},d=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS",id:"approach-1-dfs",level:2}];function h(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components},{SolutionAuthor:t,TabItem:r,Tabs:a}=n;return t||u("SolutionAuthor",!0),r||u("TabItem",!0),a||u("Tabs",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"1448---count-good-nodes-in-binary-tree-medium",children:"1448 - Count Good Nodes in Binary Tree (Medium)"})}),"\n",(0,o.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,o.jsxs)(n.p,{children:["Given a binary tree ",(0,o.jsx)(n.code,{children:"root"}),", a node ",(0,o.jsx)(n.em,{children:"X"})," in the tree is named\xa0",(0,o.jsx)(n.strong,{children:"good"})," if in the path from root to ",(0,o.jsx)(n.em,{children:"X"})," there are no nodes with a value ",(0,o.jsx)(n.em,{children:"greater than"})," X."]}),"\n",(0,o.jsxs)(n.p,{children:["Return the number of ",(0,o.jsx)(n.strong,{children:"good"})," nodes in the binary tree."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Input: root = [3,1,4,3,null,1,5]\nOutput: 4\nExplanation: Nodes in blue are good.\nRoot Node (3) is always a good node.\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\nNode 5 -> (3,4,5) is the maximum value in the path\nNode 3 -> (3,1,3) is the maximum value in the path.\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'Input: root = [3,3,null,4,2]\nOutput: 3\nExplanation: Node 2 -> (3, 3, 2) is not good, because "3" is higher than it.\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Input: root = [1]\nOutput: 1\nExplanation: Root is considered as good.\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The number of nodes in the binary tree is in the range\xa0",(0,o.jsx)(n.code,{children:"[1, 10^5]"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Each node's value is between ",(0,o.jsx)(n.code,{children:"[-10^4, 10^4]"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"approach-1-dfs",children:"Approach 1: DFS"}),"\n",(0,o.jsxs)(a,{children:[(0,o.jsxs)(r,{value:"cpp",label:"C++",children:[(0,o.jsx)(t,{name:"@wingkwong"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Time complexity: O(N) as we visit every node only once.\n// Space complexity: O(H) where H is the height of the tree.\n// In the worst case, H would be N given that the tree only has one path.\nclass Solution {\npublic:\n    // the idea is to record the max value from the root to the node\n    // we can first initialise mx as INT_MIN \n    int goodNodes(TreeNode* root, int mx = INT_MIN) {\n        // if the root is null, we return 0\n        if (!root) return 0;\n        // then we can break it into 3 parts\n        // the first part is the current node\n        // if the current node value is greater than the maximum value so far\n        // that means the current node is a good node\n        // hence we add 1, else add 0\n        return (mx <= root->val ? 1 : 0) + \n                // the second part is the result of the left sub-tree\n                // we traverse it with the updated maximum value at the current point\n                // we don't need to check if root->left is null or not here\n                // as we cover the null case in the first line\n                goodNodes(root->left, max(root->val, mx)) + \n                // the last part is the result of the right sub-tree\n                // we traverse it with the updated maximum value at the current point\n                // we don't need to check if root->right is null or not here\n                // as we cover the null case in the first line\n                goodNodes(root->right, max(root->val, mx));\n    }\n};\n"})})]}),(0,o.jsxs)(r,{value:"python",label:"Python",children:[(0,o.jsx)(t,{name:"@ColeB2"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-py",children:"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # Iterative Depth-First Search\n    # We can simply solve this problem by running a DFS, and passing down a max\n    # value to each node. A node is only good of it is >= to this max value.\n    # Time Complexity: O(n). We are going to have to precess each node.\n    # Space Complexity: O(h). Using a stack, we only ever have the current path\n    # inside our stack.\n    def goodNodes(self, root: TreeNode) -> int:\n        # Early termination\n        if not root:\n            return 0\n        # initialize return integer\n        num_good_nodes = 0\n        # initialize our stack, each item will be a tuple (node, max_value)\n        # where the max value is the max value we have seen thus far going down\n        # the path to the node.\n        stack = [(root, root.val)]\n        # while our stack still has nodes inside.\n        while stack:\n            # pop off the node and the highest value we have seen thus far.\n            node, high = stack.pop()\n            # Increment our num_good_nodes integer iff our current nodes value\n            # is greater than or equal to the highest node we have seen.\n            if node.val >= high:\n                num_good_nodes += 1\n            # if node has a left child\n            if node.left:\n                # add left child to the stack with the highest value.\n                # highest value will be larger of the current nodes value and\n                # the highest value that was passed to this iteration.\n                stack.append((node.left, max(node.val,high)))\n            # if the node has a right child\n            if node.right:\n                # add right child, make sure to update the high value.\n                stack.append((node.right, max(node.val, high)))\n        # return the number of good nodse that we calculated above.\n        return num_good_nodes\n"})})]})]})]})}function c(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>a});var o=t(67294);const i={},r=o.createContext(i);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);