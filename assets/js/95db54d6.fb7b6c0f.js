"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[42686],{19972:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"0200-0299/implement-stack-using-queues-easy","title":"0225 - Implement Stack using Queues (Easy)","description":"Author: @wkw | https://leetcode.com/problems/implement-stack-using-queues","source":"@site/solutions/0200-0299/0225-implement-stack-using-queues-easy.md","sourceDirName":"0200-0299","slug":"/0200-0299/implement-stack-using-queues-easy","permalink":"/solutions/0200-0299/implement-stack-using-queues-easy","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0200-0299/0225-implement-stack-using-queues-easy.md","tags":[],"version":"current","sidebarPosition":225,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/implement-stack-using-queues"},"sidebar":"tutorialSidebar","previous":{"title":"0219 - Contains Duplicate II (Easy)","permalink":"/solutions/0200-0299/contains-duplicate-ii-easy"},"next":{"title":"0226 - Invert Binary Tree (Easy)","permalink":"/solutions/0200-0299/invert-binary-tree-easy"}}');var o=s(86070),a=s(40629);const i={description:"Author: @wkw | https://leetcode.com/problems/implement-stack-using-queues"},l="0225 - Implement Stack using Queues (Easy)",r={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: 2 Queues",id:"approach-1-2-queues",level:2},{value:"Approach 2: 1 Queue",id:"approach-2-1-queue",level:2}];function p(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{SolutionAuthor:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("SolutionAuthor",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"0225---implement-stack-using-queues-easy",children:"0225 - Implement Stack using Queues (Easy)"})}),"\n",(0,o.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://leetcode.com/problems/implement-stack-using-queues",children:"https://leetcode.com/problems/implement-stack-using-queues"})}),"\n",(0,o.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,o.jsxs)(n.p,{children:["Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (",(0,o.jsx)(n.code,{children:"push"}),", ",(0,o.jsx)(n.code,{children:"top"}),", ",(0,o.jsx)(n.code,{children:"pop"}),", and ",(0,o.jsx)(n.code,{children:"empty"}),")."]}),"\n",(0,o.jsxs)(n.p,{children:["Implement the ",(0,o.jsx)(n.code,{children:"MyStack"})," class:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"void push(int x)"})," Pushes element x to the top of the stack."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"int pop()"})," Removes the element on the top of the stack and returns it."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"int top()"})," Returns the element on the top of the stack."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"boolean empty()"})," Returns ",(0,o.jsx)(n.code,{children:"true"})," if the stack is empty, ",(0,o.jsx)(n.code,{children:"false"})," otherwise."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["You must use ",(0,o.jsx)(n.strong,{children:"only"})," standard operations of a queue, which means that only ",(0,o.jsx)(n.code,{children:"push to back"}),", ",(0,o.jsx)(n.code,{children:"peek/pop from front"}),", ",(0,o.jsx)(n.code,{children:"size"})," and ",(0,o.jsx)(n.code,{children:"is empty"})," operations are valid."]}),"\n",(0,o.jsx)(n.li,{children:"Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'Input\n["MyStack", "push", "push", "top", "pop", "empty"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 2, 2, false]\n\nExplanation\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"1 <= x <= 9"})}),"\n",(0,o.jsxs)(n.li,{children:["At most ",(0,o.jsx)(n.code,{children:"100"})," calls will be made to ",(0,o.jsx)(n.code,{children:"push"}),", ",(0,o.jsx)(n.code,{children:"pop"}),", ",(0,o.jsx)(n.code,{children:"top"}),", and ",(0,o.jsx)(n.code,{children:"empty"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["All the calls to ",(0,o.jsx)(n.code,{children:"pop"})," and ",(0,o.jsx)(n.code,{children:"top"})," are valid."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"approach-1-2-queues",children:"Approach 1: 2 Queues"}),"\n",(0,o.jsxs)(n.p,{children:["We can push all elements to one queue. For ",(0,o.jsx)(n.code,{children:"pop"})," and ",(0,o.jsx)(n.code,{children:"top"})," function, we move first ",(0,o.jsxs)(n.span,{className:"katex",children:[(0,o.jsx)(n.span,{className:"katex-mathml",children:(0,o.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,o.jsxs)(n.semantics,{children:[(0,o.jsxs)(n.mrow,{children:[(0,o.jsx)(n.mi,{children:"n"}),(0,o.jsx)(n.mo,{children:"\u2212"}),(0,o.jsx)(n.mn,{children:"1"})]}),(0,o.jsx)(n.annotation,{encoding:"application/x-tex",children:"n - 1"})]})})}),(0,o.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,o.jsxs)(n.span,{className:"base",children:[(0,o.jsx)(n.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,o.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,o.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,o.jsx)(n.span,{className:"mbin",children:"\u2212"}),(0,o.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,o.jsxs)(n.span,{className:"base",children:[(0,o.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,o.jsx)(n.span,{className:"mord",children:"1"})]})]})]})," elements to another queue. What's left would be the top element. For ",(0,o.jsx)(n.code,{children:"pop"})," function, we pop the top element as well and swap the queue."]}),"\n",(0,o.jsx)(s,{name:"@wkw"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"class MyStack {\npublic:\n    queue<int> q1, q2;\n    MyStack() { }\n\n    void push(int x) {\n        q1.push(x);\n    }\n\n    int pop() {\n        while (q1.size() > 1) {\n            int x = q1.front();\n            q1.pop();\n            q2.push(x);\n        }\n        int res = q1.front();\n        q1.pop();\n        swap(q1, q2);\n        return res;\n    }\n\n    int top() {\n        while (q1.size() > 1) {\n            int x = q1.front();\n            q1.pop();\n            q2.push(x);\n        }\n        return q1.front();\n    }\n\n    bool empty() {\n        return q1.empty();\n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * bool param_4 = obj->empty();\n */\n"})}),"\n",(0,o.jsx)(n.h2,{id:"approach-2-1-queue",children:"Approach 2: 1 Queue"}),"\n",(0,o.jsxs)(n.p,{children:["For every push, we simply make the order backwards for ",(0,o.jsx)(n.code,{children:"push"})," function. For ",(0,o.jsx)(n.code,{children:"pop"}),"() and ",(0,o.jsx)(n.code,{children:"top()"}),", we can use ",(0,o.jsx)(n.code,{children:"front()"})," to get the top element and return it."]}),"\n",(0,o.jsx)(s,{name:"@wkw"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"class MyStack {\npublic:\n    queue<int> q1;\n    MyStack() { }\n\n    void push(int x) {\n        q1.push(x);\n        for (int i = 1; i < q1.size(); i++) {\n            q1.push(q1.front());\n            q1.pop();\n        }\n    }\n\n    int pop() {\n        int x = q1.front(); q1.pop();\n        return x;\n    }\n\n    int top() {\n        return q1.front();\n    }\n\n    bool empty() {\n        return q1.empty();\n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * bool param_4 = obj->empty();\n */\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},40629:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var t=s(30758);const o={},a=t.createContext(o);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);