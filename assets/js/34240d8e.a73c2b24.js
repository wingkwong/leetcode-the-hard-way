"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[4661],{52834:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"1500-1599/count-all-possible-routes-hard","title":"1575 - Count All Possible Routes (Hard)","description":"Author: @wingkwong | https://leetcode.com/problems/count-all-possible-routes/","source":"@site/solutions/1500-1599/1575-count-all-possible-routes-hard.md","sourceDirName":"1500-1599","slug":"/1500-1599/count-all-possible-routes-hard","permalink":"/solutions/1500-1599/count-all-possible-routes-hard","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1500-1599/1575-count-all-possible-routes-hard.md","tags":[],"version":"current","sidebarPosition":1575,"frontMatter":{"description":"Author: @wingkwong | https://leetcode.com/problems/count-all-possible-routes/"},"sidebar":"tutorialSidebar","previous":{"title":"1572 - Matrix Diagonal Sum (Easy)","permalink":"/solutions/1500-1599/matrix-diagonal-sum-easy"},"next":{"title":"1578 - Minimum Time to Make Rope Colorful (Medium)","permalink":"/solutions/1500-1599/minimum-time-to-make-rope-colorful-medium"}}');var i=t(74848),s=t(28453);const r={description:"Author: @wingkwong | https://leetcode.com/problems/count-all-possible-routes/"},l="1575 - Count All Possible Routes (Hard)",c={},a=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement:",id:"problem-statement",level:2},{value:"Approach 1:  Dynamic Programming",id:"approach-1--dynamic-programming",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{SolutionAuthor:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("SolutionAuthor",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"1575---count-all-possible-routes-hard",children:"1575 - Count All Possible Routes (Hard)"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/count-all-possible-routes/",children:"https://leetcode.com/problems/count-all-possible-routes/"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement:"}),"\n",(0,i.jsxs)(n.p,{children:["You are given an array of ",(0,i.jsx)(n.strong,{children:"distinct"})," positive integers locations where ",(0,i.jsx)(n.code,{children:"locations[i]"})," represents the position of city ",(0,i.jsx)(n.code,{children:"i"}),". You are also given integers ",(0,i.jsx)(n.code,{children:"start"}),", ",(0,i.jsx)(n.code,{children:"finish"})," and ",(0,i.jsx)(n.code,{children:"fuel"})," representing the starting city, ending city, and the initial amount of fuel you have, respectively."]}),"\n",(0,i.jsxs)(n.p,{children:["At each step, if you are at city ",(0,i.jsx)(n.code,{children:"i"}),", you can pick any city ",(0,i.jsx)(n.code,{children:"j"})," such that ",(0,i.jsx)(n.code,{children:"j != i"})," and ",(0,i.jsx)(n.code,{children:"0 <= j < locations.length"})," and move to city ",(0,i.jsx)(n.code,{children:"j"}),". Moving from city ",(0,i.jsx)(n.code,{children:"i"})," to city ",(0,i.jsx)(n.code,{children:"j"})," reduces the amount of fuel you have by ",(0,i.jsx)(n.code,{children:"|locations[i] - locations[j]|"}),". Please notice that ",(0,i.jsx)(n.code,{children:"|x|"})," denotes the absolute value of ",(0,i.jsx)(n.code,{children:"x"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Notice that ",(0,i.jsx)(n.code,{children:"fuel"})," ",(0,i.jsx)(n.strong,{children:"cannot"})," become negative at any point in time, and that you are ",(0,i.jsx)(n.strong,{children:"allowed"})," to visit any city more than once (including ",(0,i.jsx)(n.code,{children:"start"})," and ",(0,i.jsx)(n.code,{children:"finish"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["Return ",(0,i.jsx)(n.em,{children:"the count of all possible routes from"})," ",(0,i.jsx)(n.code,{children:"start"})," ",(0,i.jsx)(n.em,{children:"to"})," ",(0,i.jsx)(n.code,{children:"finish"}),". Since the answer may be too large, return it modulo ",(0,i.jsx)(n.code,{children:"109 + 7"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\nOutput: 4\nExplanation: The following are all possible routes, each uses 5 units of fuel:\n1 -> 3\n1 -> 2 -> 3\n1 -> 4 -> 3\n1 -> 4 -> 2 -> 3\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6\nOutput: 5\nExplanation: The following are all possible routes:\n1 -> 0, used fuel = 1\n1 -> 2 -> 0, used fuel = 5\n1 -> 2 -> 1 -> 0, used fuel = 5\n1 -> 0 -> 1 -> 0, used fuel = 3\n1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3\nOutput: 0\nExplanation: It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"2 <= locations.length <= 100"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= locations[i] <= 10^9"})}),"\n",(0,i.jsxs)(n.li,{children:["All integers in ",(0,i.jsx)(n.code,{children:"locations"})," are ",(0,i.jsx)(n.strong,{children:"distinct"}),"."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"0 <= start, finish < locations.length"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= fuel <= 200"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"approach-1--dynamic-programming",children:"Approach 1:  Dynamic Programming"}),"\n",(0,i.jsx)(t,{name:"@wingkwong"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {\n        int M = 1e9 + 7, ans = 0, n = locations.size();\n        // dp[i][j]: how many routes to reach finish from `i` using at most `j` fuel\n        vector<vector<int>> dp(n, vector<int>(fuel + 1, -1));\n        function<int(int,int)> dfs = [&](int from, int f) {\n            // fuel < 0 - not possible -> return 0\n            if (f < 0) return 0;\n            // calculated before -> return it directly\n            if (dp[from][f] != -1) return dp[from][f];\n            // if the starting point is the finishing point, \n            // then there is one way\n            int res = from == finish;\n            // try all locations\n            for (int to = 0; to < n; to++) {\n                // skip the same point\n                if (from == to) continue;\n                // move to next position and \n                // substract the fuel\n                (res += dfs(to, f - abs(locations[from] - locations[to]))) %= M;\n            }\n            // memoize the result\n            return dp[from][f] = res;\n        };\n        return dfs(start, fuel);\n    }\n};\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var o=t(96540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);