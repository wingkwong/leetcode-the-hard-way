"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[2974],{3905:function(e,t,a){a.d(t,{Zo:function(){return l},kt:function(){return d}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),c=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},l=function(e){var t=c(e.components);return n.createElement(i.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),u=c(a),d=r,h=u["".concat(i,".").concat(d)]||u[d]||m[d]||s;return a?n.createElement(h,o(o({ref:t},l),{},{components:a})):n.createElement(h,o({ref:t},l))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,o=new Array(s);o[0]=u;var p={};for(var i in t)hasOwnProperty.call(t,i)&&(p[i]=t[i]);p.originalType=e,p.mdxType="string"==typeof e?e:r,o[1]=p;for(var c=2;c<s;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},3467:function(e,t,a){a.r(t),a.d(t,{assets:function(){return l},contentTitle:function(){return i},default:function(){return d},frontMatter:function(){return p},metadata:function(){return c},toc:function(){return m}});var n=a(7462),r=a(3366),s=(a(7294),a(3905)),o=["components"],p={description:"Author: @wingkwong | https://leetcode.com/problems/backspace-string-compare/"},i="0844 - Backspace String Compare (Easy)",c={unversionedId:"0800-0899/backspace-string-compare-easy",id:"0800-0899/backspace-string-compare-easy",title:"0844 - Backspace String Compare (Easy)",description:"Author: @wingkwong | https://leetcode.com/problems/backspace-string-compare/",source:"@site/solutions/0800-0899/0844-backspace-string-compare-easy.md",sourceDirName:"0800-0899",slug:"/0800-0899/backspace-string-compare-easy",permalink:"/leetcode-the-hard-way/solutions/0800-0899/backspace-string-compare-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/solutions/0800-0899/0844-backspace-string-compare-easy.md",tags:[],version:"current",lastUpdatedBy:"Wing-Kam Wong",lastUpdatedAt:1652607870,formattedLastUpdatedAt:"5/15/2022",sidebarPosition:844,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/backspace-string-compare/"},sidebar:"tutorialSidebar",previous:{title:"0829 - Consecutive Numbers Sum (Hard)",permalink:"/leetcode-the-hard-way/solutions/0800-0899/consecutive-numbers-sum-hard"},next:{title:"0847 - Shortest Path Visiting All Nodes (Hard)",permalink:"/leetcode-the-hard-way/solutions/0800-0899/shortest-path-visiting-all-nodes-hard"}},l={},m=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Simulation",id:"approach-1-simulation",level:2}],u={toc:m};function d(e){var t=e.components,a=(0,r.Z)(e,o);return(0,s.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"0844---backspace-string-compare-easy"},"0844 - Backspace String Compare (Easy)"),(0,s.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,s.kt)("p",null,"Given two strings ",(0,s.kt)("inlineCode",{parentName:"p"},"s")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"t"),", return ",(0,s.kt)("inlineCode",{parentName:"p"},"true")," ",(0,s.kt)("em",{parentName:"p"},"if they are equal when both are typed into empty text editors"),". ",(0,s.kt)("inlineCode",{parentName:"p"},"'#'")," means a backspace character."),(0,s.kt)("p",null,"Note that after backspacing an empty text, the text will continue empty."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 1:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'Input: s = "ab#c", t = "ad#c"\nOutput: true\nExplanation: Both s and t become "ac".\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 2:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'Input: s = "ab##", t = "c#d#"\nOutput: true\nExplanation: Both s and t become "".\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 3:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'Input: s = "a#c", t = "b"\nOutput: false\nExplanation: s becomes "c" while t becomes "b".\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Constraints:")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"1 <= s.length, t.length <= 200")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"s")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"t")," only contain lowercase letters and ",(0,s.kt)("inlineCode",{parentName:"li"},"'#'")," characters.")),(0,s.kt)("h2",{id:"approach-1-simulation"},"Approach 1: Simulation"),(0,s.kt)("p",null,"We build the final string for ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"s")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"s")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"s")))))," and ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"t")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6151em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"))))),". If we see #, then we can only backspace if the final string is not empty. Otherwise, we add the character to the final string. Since we need to do the same thing on both string, it's better to write a function to build the string."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    string process(string s) {\n        string res;\n        for (auto x : s) {\n            // include this character to final string\n            if (x != '#') res.push_back(x);\n            // pop the previous character if possible\n            else if (res.size()) res.pop_back();\n        }\n        return res;\n    }\n    bool backspaceCompare(string s, string t) {\n        // check if both are same after processed\n        return process(s) == process(t);\n    }\n};\n")))}d.isMDXComponent=!0}}]);