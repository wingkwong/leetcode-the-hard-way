"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[27344],{38773(e,r,n){n.r(r),n.d(r,{assets:()=>p,contentTitle:()=>l,default:()=>g,frontMatter:()=>i,metadata:()=>o,toc:()=>s});var a=n(9346),t=(n(37953),n(58860));const i={description:"Author: @wkw, @radojicic23 | https://leetcode.com/problems/valid-mountain-array/"},l="0941 - Valid Mountain Array (Easy)",o={unversionedId:"0900-0999/valid-mountain-array-easy",id:"0900-0999/valid-mountain-array-easy",title:"0941 - Valid Mountain Array (Easy)",description:"Author: @wkw, @radojicic23 | https://leetcode.com/problems/valid-mountain-array/",source:"@site/solutions/0900-0999/0941-valid-mountain-array-easy.md",sourceDirName:"0900-0999",slug:"/0900-0999/valid-mountain-array-easy",permalink:"/solutions/0900-0999/valid-mountain-array-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0941-valid-mountain-array-easy.md",tags:[],version:"current",sidebarPosition:941,frontMatter:{description:"Author: @wkw, @radojicic23 | https://leetcode.com/problems/valid-mountain-array/"},sidebar:"tutorialSidebar",previous:{title:"0936 - Stamping The Sequence (Hard)",permalink:"/solutions/0900-0999/stamping-the-sequence-hard"},next:{title:"0944 - Delete Columns to Make Sorted (Easy)",permalink:"/solutions/0900-0999/delete-columns-to-make-sorted-easy"}},p={},s=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Prefix and Suffix",id:"approach-1-prefix-and-suffix",level:2},{value:"Approach 2: One Pass",id:"approach-2-one-pass",level:2}],u=e=>function(r){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,t.yg)("div",r)},y=u("Tabs"),m=u("TabItem"),c=u("SolutionAuthor"),d={toc:s};function g({components:e,...r}){return(0,t.yg)("wrapper",(0,a.A)({},d,r,{components:e,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"0941---valid-mountain-array-easy"},"0941 - Valid Mountain Array (Easy)"),(0,t.yg)("h2",{id:"problem-link"},"Problem Link"),(0,t.yg)("p",null,(0,t.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/valid-mountain-array/"},"https://leetcode.com/problems/valid-mountain-array/")),(0,t.yg)("h2",{id:"problem-statement"},"Problem Statement"),(0,t.yg)("p",null,"Given an array of integers ",(0,t.yg)("inlineCode",{parentName:"p"},"arr"),", return ",(0,t.yg)("em",{parentName:"p"},(0,t.yg)("inlineCode",{parentName:"em"},"true")," if and only if it is a valid mountain array"),"."),(0,t.yg)("p",null,"Recall that arr is a mountain array if and only if:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"arr.length >= 3")),(0,t.yg)("li",{parentName:"ul"},"There exists some ",(0,t.yg)("inlineCode",{parentName:"li"},"i")," with ",(0,t.yg)("inlineCode",{parentName:"li"},"0 < i < arr.length - 1")," such that:",(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"arr[0] < arr[1] < ... < arr[i - 1] < arr[i]")),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"arr[i] > arr[i + 1] > ... > arr[arr.length - 1]"))))),(0,t.yg)("p",null,(0,t.yg)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png",alt:null})),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Example 1:")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre"},"Input: arr = [2,1]\nOutput: false\n")),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Example 2:")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre"},"Input: arr = [3,5,5]\nOutput: false\n")),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Example 3:")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre"},"Input: arr = [0,3,2,1]\nOutput: true\n")),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Constraints:")),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"1 <= arr.length <= 10^4")),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"0 <= arr[i] <= 10^4"))),(0,t.yg)("h2",{id:"approach-1-prefix-and-suffix"},"Approach 1: Prefix and Suffix"),(0,t.yg)("p",null,"If the array length is less than 3, then it must be false. Otherwise, we can calculate the prefix and suffix. ",(0,t.yg)("inlineCode",{parentName:"p"},"prefix[i]")," means it is a strictly increasing array from the first mountain till mountain ",(0,t.yg)("inlineCode",{parentName:"p"},"i"),". Similarly, ",(0,t.yg)("inlineCode",{parentName:"p"},"suffix[j]")," means it is a strictly decreasing array from the last mountain till mountain ",(0,t.yg)("inlineCode",{parentName:"p"},"j"),". If there is a certain point ",(0,t.yg)("inlineCode",{parentName:"p"},"k")," where ",(0,t.yg)("inlineCode",{parentName:"p"},"prefix[k]")," and ",(0,t.yg)("inlineCode",{parentName:"p"},"suffix[k]")," both true, then that would be the peak of a valid mountain."),(0,t.yg)(y,{mdxType:"Tabs"},(0,t.yg)(m,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,t.yg)(c,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool validMountainArray(vector<int>& arr) {\n        int n = arr.size();\n        if(n < 3) return false;\n        vector<int> p(n, 0), s(n, 0); // prefix & suffix\n        p[0] = s[n - 1] = 1;\n        for(int i = 1; i < n - 1; i++) p[i] = arr[i] > arr[i - 1] && p[i - 1];\n        for(int i = n - 2; i >= 1; i--) s[i] = arr[i] > arr[i + 1] && s[i + 1];\n        for(int i = 1; i < n - 1; i++) if(p[i] && s[i]) return true;\n        return false;\n    }\n};\n")))),(0,t.yg)("h2",{id:"approach-2-one-pass"},"Approach 2: One Pass"),(0,t.yg)("p",null,"From approach 1, we can see that both prefix and suffix array only record if it is a strictly increasing or decreasing array till certain point. We can optimise it using two pointers ",(0,t.yg)("inlineCode",{parentName:"p"},"i")," and ",(0,t.yg)("inlineCode",{parentName:"p"},"j"),", where pointer ",(0,t.yg)("inlineCode",{parentName:"p"},"i")," is to check the strictly increasing array and pointer ",(0,t.yg)("inlineCode",{parentName:"p"},"j")," is to check the strictly decreasing array. If they stop at the same point, then that would be the peak of the same mountain."),(0,t.yg)(y,{mdxType:"Tabs"},(0,t.yg)(m,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,t.yg)(c,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool validMountainArray(vector<int>& arr) {\n        int n = arr.size(), i = 0, j = n - 1;\n        while (i + 1 < n && arr[i] < arr[i + 1]) i++;\n        while (j - 1 > 0 && arr[j - 1] > arr[j]) j--;\n        return i == j && i > 0 && j < n - 1;\n    }\n};\n"))),(0,t.yg)(m,{value:"py",label:"Python",mdxType:"TabItem"},(0,t.yg)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def validMountainArray(self, arr: List[int]) -> bool:\n        l, r = 0, len(arr) - 1\n        if len(arr) < 3: return False\n        while l + 1 < len(arr) - 1 and arr[l] < arr[l + 1]:\n            l += 1\n        while r - 1 > 0 and arr[r] < arr[r - 1]:\n            r -= 1\n        return l == r\n\n"))),(0,t.yg)(m,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,t.yg)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"/**\n * @param {number[]} arr\n * @return {boolean}\n */\nvar validMountainArray = function (arr) {\n  let left = 0;\n  let right = arr.length - 1;\n  if (arr.length < 3) return false;\n  while (left + 1 < arr.length - 1 && arr[left] < arr[left + 1]) left++;\n  while (right - 1 > 0 && arr[right] < arr[right - 1]) right--;\n  return left == right;\n};\n")))))}g.isMDXComponent=!0},58860(e,r,n){n.d(r,{xA:()=>u,yg:()=>c});var a=n(37953);function t(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function i(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r&&(a=a.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),n.push.apply(n,a)}return n}function l(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?i(Object(n),!0).forEach(function(r){t(e,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))})}return e}function o(e,r){if(null==e)return{};var n,a,t=function(e,r){if(null==e)return{};var n,a,t={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],r.indexOf(n)>=0||(t[n]=e[n]);return t}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(t[n]=e[n])}return t}var p=a.createContext({}),s=function(e){var r=a.useContext(p),n=r;return e&&(n="function"==typeof e?e(r):l(l({},r),e)),n},u=function(e){var r=s(e.components);return a.createElement(p.Provider,{value:r},e.children)},y={inlineCode:"code",wrapper:function(e){var r=e.children;return a.createElement(a.Fragment,{},r)}},m=a.forwardRef(function(e,r){var n=e.components,t=e.mdxType,i=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=s(n),c=t,d=m["".concat(p,".").concat(c)]||m[c]||y[c]||i;return n?a.createElement(d,l(l({ref:r},u),{},{components:n})):a.createElement(d,l({ref:r},u))});function c(e,r){var n=arguments,t=r&&r.mdxType;if("string"==typeof e||t){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var p in r)hasOwnProperty.call(r,p)&&(o[p]=r[p]);o.originalType=e,o.mdxType="string"==typeof e?e:t,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);