"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[93269],{22210:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"0600-0699/average-of-levels-in-binary-tree-medium","title":"0637 - Average of Levels in Binary Tree (Easy)","description":"Author: @wkw | https://leetcode.com/problems/average-of-levels-in-binary-tree/","source":"@site/solutions/0600-0699/0637-average-of-levels-in-binary-tree-medium.md","sourceDirName":"0600-0699","slug":"/0600-0699/average-of-levels-in-binary-tree-medium","permalink":"/solutions/0600-0699/average-of-levels-in-binary-tree-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0600-0699/0637-average-of-levels-in-binary-tree-medium.md","tags":[{"inline":true,"label":"Tree","permalink":"/solutions/tags/tree"},{"inline":true,"label":"Depth-First Search","permalink":"/solutions/tags/depth-first-search"},{"inline":true,"label":"Breadth-First Search","permalink":"/solutions/tags/breadth-first-search"},{"inline":true,"label":"Binary Tree","permalink":"/solutions/tags/binary-tree"}],"version":"current","sidebarPosition":637,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/average-of-levels-in-binary-tree/","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},"sidebar":"tutorialSidebar","previous":{"title":"0633 - Sum of Square Numbers (Medium)","permalink":"/solutions/0600-0699/sum-of-square-numbers-medium"},"next":{"title":"0645 - Set Mismatch (Easy)","permalink":"/solutions/0600-0699/set-mismatch-easy"}}');var o=t(86070),i=t(32790);const s={description:"Author: @wkw | https://leetcode.com/problems/average-of-levels-in-binary-tree/",tags:["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},a="0637 - Average of Levels in Binary Tree (Easy)",l={},h=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: BFS",id:"approach-1-bfs",level:2}];function u(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{SolutionAuthor:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("SolutionAuthor",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"0637---average-of-levels-in-binary-tree-easy",children:"0637 - Average of Levels in Binary Tree (Easy)"})}),"\n",(0,o.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,o.jsxs)(n.p,{children:["Given the ",(0,o.jsx)(n.code,{children:"root"})," of a binary tree, return ",(0,o.jsx)(n.em,{children:"the average value of the nodes on each level in the form of an array"}),". Answers within ",(0,o.jsx)(n.code,{children:"10-5"})," of the actual answer will be accepted."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Input: root = [3,9,20,null,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Input: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The number of nodes in the tree is in the range ",(0,o.jsx)(n.code,{children:"[1, 10^4]"}),"."]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"-231 <= Node.val <= 2^31 - 1"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"approach-1-bfs",children:"Approach 1: BFS"}),"\n",(0,o.jsx)(t,{name:"@wkw"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n// Time Complexity: O(N) where N is the number of nodes in the tree\n// Space Complexity: O(M): where N is the maximum number in the tree at any level\nclass Solution {\npublic:\n    // The idea is to use BFS, which is a common way to traverse the tree level by level\n    // For a standard BFS, we can use queue to push the first root node into a queue\n    // Then remove the front of the queue, add its children to back of the queue\n    // Do the above steps until the queue is empty\n    // In this question, we need to extra thing which is calculate the average value of the nodes on each level\n    // We can simply use `sum` to store the current sum of the nodes,\n    // and calculate the average after processing all the nodes on each level\n    vector<double> averageOfLevels(TreeNode* root) {\n        // Use a queue for perform BFS\n        queue<TreeNode*> q;\n        // Push the root node.\n        // Unlike some other questions, the number of nodes is guaranteed to be [1, 10 ^ 4]\n        // Hence, we don't need to check if it is null or not here\n        q.push(root);\n        // ans[i] is used to store the average values for each level i\n        vector<double> ans;\n        // Do the following logic until the queue is empty\n        while(!q.empty()) {\n            // n is the number of nodes in the current queue\n            int n = q.size();\n            // init the sum to store the total sum of the nodes on this level\n            double sum = 0;\n            // iterate each node on the current level\n            for(int i = 0; i < n; i++) {\n                // get the first node from the queue\n                TreeNode* node = q.front();\n                // then pop it\n                q.pop();\n                // add the value to sum\n                sum += node->val;\n                // add its children to back of the queue here\n                // add the left tree if possible\n                if(node->left) q.push(node->left);\n                // add the right tree if possible\n                if(node->right) q.push(node->right);\n            }\n            // the current level has been processed, calculate the average value for this level\n            ans.push_back(sum / n);\n        }\n        // return the final answer\n        return ans;\n    }\n};\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},32790:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(30758);const o={},i=r.createContext(o);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);