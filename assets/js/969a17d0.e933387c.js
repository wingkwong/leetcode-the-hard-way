"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[43844],{87513:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"0800-0899/orderly-queue-hard","title":"0899 - Orderly Queue (Hard)","description":"Author: @wkw | https://leetcode.com/problems/orderly-queue/","source":"@site/solutions/0800-0899/0899-orderly-queue-hard.md","sourceDirName":"0800-0899","slug":"/0800-0899/orderly-queue-hard","permalink":"/solutions/0800-0899/orderly-queue-hard","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0800-0899/0899-orderly-queue-hard.md","tags":[{"inline":true,"label":"Math","permalink":"/solutions/tags/math"},{"inline":true,"label":"String","permalink":"/solutions/tags/string"},{"inline":true,"label":"Sorting","permalink":"/solutions/tags/sorting"}],"version":"current","sidebarPosition":899,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/orderly-queue/","tags":["Math","String","Sorting"]},"sidebar":"tutorialSidebar","previous":{"title":"0896 - Monotonic Array (Easy)","permalink":"/solutions/0800-0899/monotonic-array-easy"},"next":{"title":"0900 - 0999","permalink":"/solutions/category/0900---0999"}}');var a=s(86070),r=s(68906);const i={description:"Author: @wkw | https://leetcode.com/problems/orderly-queue/",tags:["Math","String","Sorting"]},o="0899 - Orderly Queue (Hard)",l={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Rotate or Sort",id:"approach-1-rotate-or-sort",level:2},{value:"Approach 2: Booth&#39;s Algorithm",id:"approach-2-booths-algorithm",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{SolutionAuthor:s,TabItem:t,Tabs:i}=n;return s||p("SolutionAuthor",!0),t||p("TabItem",!0),i||p("Tabs",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"0899---orderly-queue-hard",children:"0899 - Orderly Queue (Hard)"})}),"\n",(0,a.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/orderly-queue/",children:"https://leetcode.com/problems/orderly-queue/"})}),"\n",(0,a.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,a.jsxs)(n.p,{children:["You are given a string ",(0,a.jsx)(n.code,{children:"s"})," and an integer ",(0,a.jsx)(n.code,{children:"k"}),". You can choose one of the first ",(0,a.jsx)(n.code,{children:"k"})," letters of ",(0,a.jsx)(n.code,{children:"s"})," and append it at the end of the string.."]}),"\n",(0,a.jsxs)(n.p,{children:["Return ",(0,a.jsx)(n.em,{children:"the lexicographically smallest string you could have after applying the mentioned step any number of moves"}),"."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'Input: s = "cba", k = 1\nOutput: "acb"\nExplanation:\nIn the first move, we move the 1st character \'c\' to the end, obtaining the string "bac".\nIn the second move, we move the 1st character \'b\' to the end, obtaining the final result "acb".\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'Input: s = "baaca", k = 3\nOutput: "aaabc"\nExplanation:\nIn the first move, we move the 1st character \'b\' to the end, obtaining the string "aacab".\nIn the second move, we move the 3rd character \'c\' to the end, obtaining the final result "aaabc".\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"1 <= k <= s.length <= 1000"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"s"})," consist of lowercase English letters."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"approach-1-rotate-or-sort",children:"Approach 1: Rotate or Sort"}),"\n",(0,a.jsxs)(i,{children:[(0,a.jsxs)(t,{value:"cpp",label:"C++",children:[(0,a.jsx)(s,{name:"@wkw"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'// Time Complexity: O(N ^ 2)\n// Space Complexity: O(N)\nclass Solution {\npublic:\n    // just a refresher ...\n    void bubbleSort(string& s) {\n        int n = s.size();\n        bool swapped;\n        for (int i = 0; i < n; i++) {\n            swapped = false;\n            for (int j = 0; j < n - 1; j++) {\n                if (s[j] > s[j + 1]) {\n                    swap(s[j], s[j + 1]);\n                    swapped = true;\n                }\n            }\n            if (!swapped) break;\n        }\n    }\n\n    string orderlyQueue(string s, int k) {\n        string ans = s;\n        if (k == 1) {\n            // "cba" -> "bac" -> "acb" -> "cba" -> ...\n            // we only have N swaps here\n            // as it will become the original string after N swaps\n            // hence, we can try all N possible swaps and find the lexicographically smallest one\n            for (int i = 1; i < s.size(); i++) {\n                ans = min(ans, s.substr(i) + s.substr(0, i));\n            }\n        } else {\n            // if k > 1, we can move any character to any position by swapping two adjacent characters\n            // By swapping a number of times,\n            // e.g. "cab"\n            // eventually we could have "abc", "acb", "bca", "bac", "cba", "cab" (3 * 2 * 1 = 6 possible arrangements)\n            // so the lexicographically smallest string would be the sorted string using bubble sort\n            bubbleSort(ans);\n            // alternatively, you can use `sort(ans.begin(), ans.end());`\n        }\n        return ans;\n    }\n};\n'})})]}),(0,a.jsxs)(t,{value:"java",label:"Java",children:[(0,a.jsx)(s,{name:"@wkw"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Time Complexity: O(N ^ 2)\n// Space Complexity: O(N)\nclass Solution {\n    public String orderlyQueue(String s, int k) {\n        String ans = s;\n        if (k == 1) {\n            // "cba" -> "bac" -> "acb" -> "cba" -> ...\n            // we only have N swaps here\n            // as it will become the original string after N swaps\n            // hence, we can try all N possible swaps and find the lexicographically smallest one\n            for (int i = 0; i < s.length(); i++) {\n                String t = s.substring(i) + s.substring(0, i);\n                if (ans.compareTo(t) > 0) {\n                    ans = t;\n                }\n            }\n        } else {\n            // if k > 1, we can move any character to any position by swapping two adjacent characters\n            // By swapping a number of times,\n            // e.g. "cab"\n            // eventually we could have "abc", "acb", "bca", "bac", "cba", "cab" (3 * 2 * 1 = 6 possible arrangements)\n            // so the lexicographically smallest string would be the sorted string\n            char[] ca = ans.toCharArray();\n            Arrays.sort(ca);\n            ans = new String(ca);\n        }\n        return ans;\n    }\n}\n'})})]}),(0,a.jsxs)(t,{value:"go",label:"Go",children:[(0,a.jsx)(s,{name:"@wkw"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'// Time Complexity: O(N ^ 2)\n// Space Complexity: O(N)\nfunc orderlyQueue(s string, k int) string {\n    ans := s\n    if k == 1 {\n        // "cba" -> "bac" -> "acb" -> "cba" -> ...\n        // we only have N swaps here\n        // as it will become the original string after N swaps\n        // hence, we can try all N possible swaps and find the lexicographically smallest one\n        for i := 0; i < len(s); i++ {\n            t := s[i:] + s[:i]\n            if t < ans {\n                ans = t\n            }\n        }\n    } else {\n        // if k > 1, we can move any character to any position by swapping two adjacent characters\n        // By swapping a number of times,\n        // e.g. "cab"\n        // eventually we could have "abc", "acb", "bca", "bac", "cba", "cab" (3 * 2 * 1 = 6 possible arrangements)\n        // so the lexicographically smallest string would be the sorted string\n        r := []rune(ans)\n        sort.Slice(r, func(i int, j int) bool { return r[i] < r[j] })\n        ans = string(r)\n    }\n    return ans\n}\n'})})]}),(0,a.jsxs)(t,{value:"py",label:"Python3",children:[(0,a.jsx)(s,{name:"@wkw"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:'# Time Complexity: O(N ^ 2)\n# Space Complexity: O(N)\nclass Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n        # "cba" -> "bac" -> "acb" -> "cba" -> ...\n        # we only have N swaps here\n        # as it will become the original string after N swaps\n        # hence, we can try all N possible swaps and find the lexicographically smallest one\n        if k == 1: return min(s[i:] + s[:i] for i in range(len(s)))\n        # if k > 1, we can move any character to any position by swapping two adjacent characters\n        # By swapping a number of times,\n        # e.g. "cab"\n        # eventually we could have "abc", "acb", "bca", "bac", "cba", "cab" (3 * 2 * 1 = 6 possible arrangements)\n        # so the lexicographically smallest string would be the sorted string\n        return "".join(sorted(s))\n'})})]})]}),"\n",(0,a.jsx)(n.h2,{id:"approach-2-booths-algorithm",children:"Approach 2: Booth's Algorithm"}),"\n",(0,a.jsx)(i,{children:(0,a.jsxs)(t,{value:"cpp",label:"C++",children:[(0,a.jsx)(s,{name:"@wkw"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    string orderlyQueue(string s, int k) {\n        if (k > 1) {\n            sort(s.begin(), s.end());\n            return s;\n        }\n        // case: k == 1\n        // Booth's algorithm uses a modified preprocessing function from KMP\n        // and it runs in O(N) time\n        // ref: https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation\n        int n = s.size();\n        s += s;\n        vector<int> f(s.size(), -1);\n        k = 0;\n        for (int j = 1; j < s.size(); j++) {\n            char sj = s[j];\n            int i = f[j - k - 1];\n            while (i != -1 && sj != s[k + i + 1]) {\n                if (sj < s[k + i + 1]) k = j - i - 1;\n                i = f[i];\n            }\n            if (sj != s[k + i + 1]) {\n                if (sj < s[k]) {\n                    k = j;\n                }\n                f[j - k] = -1;\n            } else {\n                f[j - k] = i + 1;\n            }\n        }\n        return s.substr(k, s.size() / 2);\n    }\n};\n"})})]})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}function p(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},68906:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(30758);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);