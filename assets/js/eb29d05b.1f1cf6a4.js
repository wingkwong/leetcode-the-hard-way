"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[52688],{57271:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"1600-1699/concatenation-of-consecutive-binary-numbers-medium","title":"1680 - Concatenation of Consecutive Binary Numbers (Medium)","description":"Author: @wkw | https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/","source":"@site/solutions/1600-1699/1680-concatenation-of-consecutive-binary-numbers-medium.md","sourceDirName":"1600-1699","slug":"/1600-1699/concatenation-of-consecutive-binary-numbers-medium","permalink":"/solutions/1600-1699/concatenation-of-consecutive-binary-numbers-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1600-1699/1680-concatenation-of-consecutive-binary-numbers-medium.md","tags":[{"inline":true,"label":"Math","permalink":"/solutions/tags/math"},{"inline":true,"label":"Bit Manipulation","permalink":"/solutions/tags/bit-manipulation"},{"inline":true,"label":"Simulation","permalink":"/solutions/tags/simulation"}],"version":"current","sidebarPosition":1680,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/","tags":["Math","Bit Manipulation","Simulation"]},"sidebar":"tutorialSidebar","previous":{"title":"1679 - Max Number of K-Sum Pairs (Medium)","permalink":"/solutions/1600-1699/max-number-of-k-sum-pairs-medium"},"next":{"title":"1685 - Sum of Absolute Differences in a Sorted Array (Medium)","permalink":"/solutions/1600-1699/sum-of-absolute-differences-in-a-sorted-array-medium"}}');var o=t(86070),s=t(32790);const a={description:"Author: @wkw | https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/",tags:["Math","Bit Manipulation","Simulation"]},r="1680 - Concatenation of Consecutive Binary Numbers (Medium)",l={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Bit Manipulation",id:"approach-1-bit-manipulation",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{SolutionAuthor:t,TabItem:i,Tabs:a}=n;return t||u("SolutionAuthor",!0),i||u("TabItem",!0),a||u("Tabs",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"1680---concatenation-of-consecutive-binary-numbers-medium",children:"1680 - Concatenation of Consecutive Binary Numbers (Medium)"})}),"\n",(0,o.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/",children:"https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/"})}),"\n",(0,o.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,o.jsxs)(n.p,{children:["Given an integer ",(0,o.jsx)(n.code,{children:"n"}),", return ",(0,o.jsxs)(n.em,{children:["the ",(0,o.jsx)(n.strong,{children:"decimal value"})," of the binary string formed by concatenating the binary representations of"]}),(0,o.jsx)(n.code,{children:"1"}),(0,o.jsx)(n.em,{children:"to"}),(0,o.jsx)(n.code,{children:"n"}),"*in order, ",(0,o.jsx)(n.strong,{children:"modulo*"}),(0,o.jsx)(n.code,{children:"1e9 + 7"}),"."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'Input: n = 1\nOutput: 1\nExplanation: "1" in binary corresponds to the decimal value 1.\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'Input: n = 3\nOutput: 27\nExplanation: In binary, 1, 2, and 3 corresponds to "1", "10", and "11".\nAfter concatenating them, we have "11011", which corresponds to the decimal value 27.\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'Input: n = 12\nOutput: 505379714\nExplanation: The concatenation results in "1101110010111011110001001101010111100".\nThe decimal value of that is 118505380540.\nAfter modulo 1e9 + 7, the result is 505379714.\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"1 <= n <= 10^5"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"approach-1-bit-manipulation",children:"Approach 1: Bit Manipulation"}),"\n",(0,o.jsxs)(a,{children:[(0,o.jsxs)(i,{value:"cpp",label:"C++",children:[(0,o.jsx)(t,{name:"@wkw"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Time Complexity: O(N)\n// Space Complexity: O(1)\nclass Solution {\npublic:\n    // the idea is to use bit manipulation to set the current number based on the previous number\n    // for example,\n    // n = 1, ans = 0b1\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n`\n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\n    // so now we can see a pattern here\n    // we need to shift `l` bits of the previous ans to the left and add the current `i`\n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\n    int concatenatedBinary(int n) {\n        // `l` is the bit length to be shifted\n        int M = 1e9 + 7, l = 0;\n        // use long here as it potentially could overflow for int\n        long ans = 0;\n        for (int i = 1; i <= n; i++) {\n            // i & (i - 1) means removing the rightmost set bit\n            // e.g. 100100 -> 100000\n            //      000001 -> 000000\n            //      000000 -> 000000\n            // after removal, if it is 0, then it means it is power of 2\n            // as all power of 2 only contains 1 set bit\n            // if it is power of 2, we increase the bit length `l`\n            if ((i & (i - 1)) == 0) l += 1;\n            // (ans << l) means shifting the orginal answer `l` bits to th left\n            // (x | i) means  using OR operation to set the bit\n            // e.g. 0001 << 3 = 0001000\n            // e.g. 0001000 | 0001111 = 0001111\n            ans = ((ans << l) | i) % M;\n        }\n        return ans;\n    }\n};\n"})})]}),(0,o.jsxs)(i,{value:"py",label:"Python",children:[(0,o.jsx)(t,{name:"@wkw"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-py",children:"# Time Complexity: O(N)\n# Space Complexity: O(1)\nclass Solution:\n    # the idea is to use bit manipulation to set the current number based on the previous number\n    # for example,\n    # n = 1, ans = 0b1\n    # n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\n    # i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\n    # n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n`\n    # i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\n    # n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\n    # i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\n    # so now we can see a pattern here\n    # we need to shift `l` bits of the previous ans to the left and add the current `i`\n    # how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\n    def concatenatedBinary(self, n: int) -> int:\n        M = 10 ** 9 + 7\n        # `l` is the bit length to be shifted\n        l, ans = 0, 0\n        for i in range(1, n + 1):\n            # i & (i - 1) means removing the rightmost set bit\n            # e.g. 100100 -> 100000\n            #      000001 -> 000000\n            #      000000 -> 000000\n            # after removal, if it is 0, then it means it is power of 2\n            # as all power of 2 only contains 1 set bit\n            # if it is power of 2, we increase the bit length `l`\n            if i & (i - 1) == 0:\n                l += 1\n            # (ans << l) means shifting the orginal answer `l` bits to th left\n            # (x | i) means  using OR operation to set the bit\n            # e.g. 0001 << 3 = 0001000\n            # e.g. 0001000 | 0001111 = 0001111\n            ans = ((ans << l) | i) % M\n        return ans\n"})})]}),(0,o.jsxs)(i,{value:"java",label:"Java",children:[(0,o.jsx)(t,{name:"@wkw"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"// Time Complexity: O(N)\n// Space Complexity: O(1)\nclass Solution {\n    // the idea is to use bit manipulation to set the current number based on the previous number\n    // for example,\n    // n = 1, ans = 0b1\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n`\n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\n    // so now we can see a pattern here\n    // we need to shift `l` bits of the previous ans to the left and add the current `i`\n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\n    public int concatenatedBinary(int n) {\n        // `l` is the bit length to be shifted\n        int M = 1000000007, l = 0;\n        // use long here as it potentially could overflow for int\n        long ans = 0;\n        for (int i = 1; i <= n; i++) {\n            // i & (i - 1) means removing the rightmost set bit\n            // e.g. 100100 -> 100000\n            //      000001 -> 000000\n            //      000000 -> 000000\n            // after removal, if it is 0, then it means it is power of 2\n            // as all power of 2 only contains 1 set bit\n            // if it is power of 2, we increase the bit length `l`\n            if ((i & (i - 1)) == 0) l += 1;\n            // (ans << l) means shifting the orginal answer `l` bits to th left\n            // (x | i) means  using OR operation to set the bit\n            // e.g. 0001 << 3 = 0001000\n            // e.g. 0001000 | 0001111 = 0001111\n            ans = ((ans << l) | i) % M;\n        }\n        return (int) ans;\n    }\n}\n"})})]}),(0,o.jsxs)(i,{value:"go",label:"Go",children:[(0,o.jsx)(t,{name:"@wkw"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"// Time Complexity: O(N)\n// Space Complexity: O(1)\n\n// the idea is to use bit manipulation to set the current number based on the previous number\n// for example,\n// n = 1, ans = 0b1\n// n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\n// i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\n// n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n`\n// i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\n// n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\n// i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\n// so now we can see a pattern here\n// we need to shift `l` bits of the previous ans to the left and add the current `i`\n// how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\nfunc concatenatedBinary(n int) int {\n    // `l` is the bit length to be shifted\n    ans, l, M := 0, 0, 1_000_000_007\n    for i := 1; i <= n; i++ {\n        // i & (i - 1) means removing the rightmost set bit\n        // e.g. 100100 -> 100000\n        //      000001 -> 000000\n        //      000000 -> 000000\n        // after removal, if it is 0, then it means it is power of 2\n        // as all power of 2 only contains 1 set bit\n        // if it is power of 2, we increase the bit length `l`\n        if (i & (i - 1) == 0) {\n            l += 1\n        }\n        // (ans << l) means shifting the orginal answer `l` bits to th left\n        // (x | i) means  using OR operation to set the bit\n        // e.g. 0001 << 3 = 0001000\n        // e.g. 0001000 | 0001111 = 0001111\n        ans = ((ans << l) | i) % M\n    }\n    return ans\n}\n\n"})})]})]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},32790:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(30758);const o={},s=i.createContext(o);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);