"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[36558],{3905:function(e,t,o){o.d(t,{Zo:function(){return u},kt:function(){return m}});var n=o(67294);function i(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function r(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){i(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,n,i=function(e,t){if(null==e)return{};var o,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(i[o]=e[o]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):r(r({},t),e)),o},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var o=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(o),m=i,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||a;return o?n.createElement(h,r(r({ref:t},u),{},{components:o})):n.createElement(h,r({ref:t},u))}));function m(e,t){var o=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=o.length,r=new Array(a);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var c=2;c<a;c++)r[c]=o[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,o)}d.displayName="MDXCreateElement"},37577:function(e,t,o){o.r(t),o.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return k},frontMatter:function(){return l},metadata:function(){return c},suggestedProblems:function(){return d},toc:function(){return p}});var n=o(87462),i=o(63366),a=(o(67294),o(3905)),r=["components"],l={title:"Greedy",description:"Designing greedy algorithms to find a greedy strategy that produces an optimal solution to the problem",hide_table_of_contents:!1,keywords:["leetcode","tutorial","greedy","algorithm"]},s=void 0,c={unversionedId:"basic-topics/greedy",id:"basic-topics/greedy",title:"Greedy",description:"Designing greedy algorithms to find a greedy strategy that produces an optimal solution to the problem",source:"@site/tutorials/basic-topics/greedy.md",sourceDirName:"basic-topics",slug:"/basic-topics/greedy",permalink:"/tutorials/basic-topics/greedy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/basic-topics/greedy.md",tags:[],version:"current",frontMatter:{title:"Greedy",description:"Designing greedy algorithms to find a greedy strategy that produces an optimal solution to the problem",hide_table_of_contents:!1,keywords:["leetcode","tutorial","greedy","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Brute Force",permalink:"/tutorials/basic-topics/brute-force"},next:{title:"Hash Map",permalink:"/tutorials/basic-topics/hash-map"}},u={},p=[{value:"Overview",id:"overview",level:2},{value:"Example 1: 0605 - Can Place Flowers",id:"example-1-0605---can-place-flowers",level:2},{value:"Example 2: 455 - Assign Cookies",id:"example-2-455---assign-cookies",level:2}],d=[{problemName:"0561 - Array Partition",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/array-partition/",solutionLink:""},{problemName:"0860 - Lemonade Change",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/lemonade-change/",solutionLink:""},{problemName:"1005 - Maximize Sum Of Array After K Negations",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/",solutionLink:""},{problemName:"0045 - Jump Game II",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/jump-game-ii/",solutionLink:""},{problemName:"0402 - Remove K Digits",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/remove-k-digits/",solutionLink:""}],m=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)}},h=m("TutorialAuthors"),f=m("Tabs"),g=m("TabItem"),b=m("SolutionAuthor"),y=m("Table"),w={toc:p,suggestedProblems:d};function k(e){var t=e.components,o=(0,i.Z)(e,r);return(0,a.kt)("wrapper",(0,n.Z)({},w,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)(h,{names:"@abhishek-sultaniya, @wingkwong",mdxType:"TutorialAuthors"}),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"A greedy algorithm is a type of algorithmic approach that follows the problem-solving heuristic of making the locally optimal choice at each stage with the hope of finding a global optimum. In other words, at each step, it chooses the option that looks the best at that moment without considering the potential impact of the decision on future steps."),(0,a.kt)("p",null,"This algorithm is mainly used for optimization problems where the goal is to find the best solution among a set of possibilities. The solutions are constructed incrementally, with the algorithm making the locally optimal choice at each stage."),(0,a.kt)("p",null,"A Greedy algorithm is simple and easy to implement, but it doesn't always give an optimal solution. It can be used to solve problems such as scheduling, Huffman coding, and finding the shortest path in a graph."),(0,a.kt)("p",null,"Overall, the Greedy algorithm is a useful approach for solving optimization problems, but it should be used with caution, as it may not always lead to the best global solution."),(0,a.kt)("h2",{id:"example-1-0605---can-place-flowers"},"Example 1: ",(0,a.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/can-place-flowers/"},"0605 - Can Place Flowers")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots."),(0,a.kt)("p",{parentName:"blockquote"},"Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.")),(0,a.kt)("p",null,"For a greedy solution, we would solve in such a way that we will always have the best choice at every max. Our task is to calculate maximum flowers we can plant. Its simple that if there are three consecutive zeroes then the middle one will be planted. But if we have to calculate maximum then we will miss 2 side case this way."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Case 1: 001....")),(0,a.kt)("p",null,"Here intially we have just 2 consecutive zeroes but we can plant at first place. So we will consider this case too."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Case 2: ...100")),(0,a.kt)("p",null,"Here at the end we have just 2 consecutive zeroes but we can plant at last place. So we will consider this case too."),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(b,{name:"@abhishek-sultaniya",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int p) {\n      int n = flowerbed.size();\n      // count variable will calculate max flowers we can plant\n      int count = 0;\n      if (flowerbed[0] == 0 && n == 1) {\n        count++;\n      }\n      // The following will cover case 1\n      if (n > 1 && flowerbed[0] == 0 && flowerbed[1] == 0) {\n        count++;\n        flowerbed[0] = 1;\n      }\n      // Mid approach to check 3 consecutive zeroes\n      for (int i = 1; i < n - 1; i++) {\n        if (flowerbed[i] == 0 && flowerbed[i - 1] == 0 && flowerbed[i + 1] == 0) {\n          flowerbed[i] = 1;\n          count++;\n        }\n      }\n      // The following will cover case 2\n      if (n > 2 && flowerbed[n - 2] == 0 && flowerbed[n - 1] == 0) {\n        count++;\n      }\n      return count >= p;\n    }\n};\n")))),(0,a.kt)("h2",{id:"example-2-455---assign-cookies"},"Example 2: ",(0,a.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/assign-cookies/"},"455 - Assign Cookies")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie."),(0,a.kt)("p",{parentName:"blockquote"},"Each child i has a greed factor g","[i]",", which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s","[j]",". If s","[j]"," >= g","[i]",", we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number")),(0,a.kt)("p",null,"This problem uses the concept of greedy. Our aim is to just assign the cookies starting from the child with less greediness to maximize the number of happy children. So we will sort greediness of child and size of cookies too. Then as soon as a child gets the cookie, we move to next child. We are using greedy in such a way that if child will less greediness cannot get a cookie, then all children with higher greediness will also not get that cookie."),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(b,{name:"@abhishek-sultaniya",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(s.begin(), s.end());\n        sort(g.begin(), g.end());\n        int ans = 0;\n        for (int j = 0; j < s.size() && ans < g.size(); ++j) {\n            if (g[ans] <= s[j]) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n};\n")))),(0,a.kt)(y,{title:"Suggested Problems",data:d,mdxType:"Table"}))}k.isMDXComponent=!0}}]);