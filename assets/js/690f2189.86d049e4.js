"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[19976],{94596:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"0100-0199/path-sum-ii-medium","title":"0113 - Path Sum II (Medium)","description":"Author: @wkw, @lonyehan, @radojicic23 | https://leetcode.com/problems/path-sum-ii/","source":"@site/solutions/0100-0199/0113-path-sum-ii-medium.md","sourceDirName":"0100-0199","slug":"/0100-0199/path-sum-ii-medium","permalink":"/solutions/0100-0199/path-sum-ii-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0100-0199/0113-path-sum-ii-medium.md","tags":[{"inline":true,"label":"Backtracking","permalink":"/solutions/tags/backtracking"},{"inline":true,"label":"Tree","permalink":"/solutions/tags/tree"},{"inline":true,"label":"Depth-First Search","permalink":"/solutions/tags/depth-first-search"},{"inline":true,"label":"Binary Tree","permalink":"/solutions/tags/binary-tree"}],"version":"current","sidebarPosition":113,"frontMatter":{"description":"Author: @wkw, @lonyehan, @radojicic23 | https://leetcode.com/problems/path-sum-ii/","tags":["Backtracking","Tree","Depth-First Search","Binary Tree"]},"sidebar":"tutorialSidebar","previous":{"title":"0112 - Path Sum (Easy)","permalink":"/solutions/0100-0199/path-sum-easy"},"next":{"title":"0115 - Distinct Subsequences (Hard)","permalink":"/solutions/0100-0199/distinct-subsequences-hard"}}');var i=t(86070),a=t(32790);const o={description:"Author: @wkw, @lonyehan, @radojicic23 | https://leetcode.com/problems/path-sum-ii/",tags:["Backtracking","Tree","Depth-First Search","Binary Tree"]},s="0113 - Path Sum II (Medium)",l={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS + Backtracking",id:"approach-1-dfs--backtracking",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{SolutionAuthor:t,TabItem:r,Tabs:o}=n;return t||c("SolutionAuthor",!0),r||c("TabItem",!0),o||c("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"0113---path-sum-ii-medium",children:"0113 - Path Sum II (Medium)"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/path-sum-ii/",children:"https://leetcode.com/problems/path-sum-ii/"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(n.p,{children:["Given the ",(0,i.jsx)(n.code,{children:"root"})," of a binary tree and an integer ",(0,i.jsx)(n.code,{children:"targetSum"}),", return ",(0,i.jsxs)(n.em,{children:["all ",(0,i.jsx)(n.strong,{children:"root-to-leaf"})," paths where the sum of the node values in the path equals"]}),(0,i.jsx)(n.code,{children:"targetSum"}),(0,i.jsxs)(n.em,{children:[". Each path should be returned as a list of the node ",(0,i.jsx)(n.strong,{children:"values"}),", not node references"]}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"root-to-leaf"})," path is a path starting from the root and ending at any leaf node. A ",(0,i.jsx)(n.strong,{children:"leaf"})," is a node with no children."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: [[5,4,11,2],[5,8,4,5]]\nExplanation: There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: root = [1,2,3], targetSum = 5\nOutput: []\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: root = [1,2], targetSum = 0\nOutput: []\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The number of nodes in the tree is in the range ",(0,i.jsx)(n.code,{children:"[0, 5000]"}),"."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"-1000 <= Node.val <= 1000"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"-1000 <= targetSum <= 1000"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"approach-1-dfs--backtracking",children:"Approach 1: DFS + Backtracking"}),"\n",(0,i.jsxs)(o,{children:[(0,i.jsxs)(r,{value:"cpp",label:"C++",children:[(0,i.jsx)(t,{name:"@wkw"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    vector<vector<int>> ans;\n\n    // the idea is to use dfs to traverse the tree from all root to leaf paths\n    // `path` is used to store the current route\n    // `remainingSum` is used to store thre remaining sum that we need with the initial value `targetSum`.\n    //  we substract it from the node value when we traverse down the tree\n    // if we arrive the leaf and the the remaining sum is eqaul to leaf node value\n    // then we can add `path` to ans\n    // e.g. path = [5,4,11,2] and remainingSum = targetSum = 22\n    // traverse node 5, remainingSum = 22 - 5 = 17\n    // traverse node 4, remainingSum = 17 - 4 = 13\n    // traverse node 11, remainingSum = 13 - 11 = 2\n    // traverse node 2, remainingSum = 2 - 2 = 0\n    // remainingSum is 0 which means the sum of current path is eqaul to targetSum\n    // so how to find another path?\n    // we can backtrack here\n    // we can pop back a node and try another\n    // e.g. path = [5, 4, 11, 7]\n    // pop 7 out = [5, 4, 11]\n    // push 2 = [5, 4, 11, 2]\n    // ... etc\n    void dfs(TreeNode* node, vector<int>& path, int remainingSum) {\n        // if it is nullptr, then return\n        if (!node) return;\n        // add the current node val to path\n        path.push_back(node-> val);\n        // !node->left && !node->right : check if it is a leaf node\n        // remainingSum == node->val: check if the remaining sum - node->val == 0\n        // if both condition is true, then we find one of the paths\n        if (!node->left && !node->right && remainingSum == node->val) ans.push_back(path);\n        // traverse left sub tree with updated remaining sum\n        // we don't need to check if left sub tree is nullptr or not\n        // as we handle it in the first line of this function\n        dfs(node-> left, path, remainingSum - node-> val);\n        // traverse right sub tree with updated remaining sum\n        // we don't need to check if right sub tree is nullptr or not\n        // as we handle it in the first line of this function\n        dfs(node-> right, path, remainingSum - node-> val);\n        // backtrack\n        path.pop_back();\n    }\n\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        // used to store current route\n        vector<int> path;\n        // dfs from the root\n        dfs(root, path, targetSum);\n        return ans;\n    }\n};\n"})})]}),(0,i.jsxs)(r,{value:"py",label:"Python",children:[(0,i.jsx)(t,{name:"@wkw"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # the idea is to use dfs to traverse the tree from all root to leaf paths\n    # `path` is used to store the current route\n    # `remainingSum` is used to store thre remaining sum that we need with the initial value `targetSum`.\n    #  we substract it from the node value when we traverse down the tree\n    # if we arrive the leaf and the the remaining sum is eqaul to leaf node value\n    # then we can add `path` to ans\n    # e.g. path = [5,4,11,2] and remainingSum = targetSum = 22\n    # traverse node 5, remainingSum = 22 - 5 = 17\n    # traverse node 4, remainingSum = 17 - 4 = 13\n    # traverse node 11, remainingSum = 13 - 11 = 2\n    # traverse node 2, remainingSum = 2 - 2 = 0\n    # remainingSum is 0 which means the sum of current path is eqaul to targetSum\n    # so how to find another path?\n    # we can backtrack here\n    # we can pop back a node and try another\n    # e.g. path = [5, 4, 11, 7]\n    # pop 7 out = [5, 4, 11]\n    # push 2 = [5, 4, 11, 2]\n    # ... etc\n    def dfs(self, root, path, ans, remainingSum):\n        # if it is None, then return\n        if not root:\n            return\n        # add the current node val to path\n        path.append(root.val)\n        # !node.left && !node.right : check if it is a leaf node\n        # remainingSum == node.val: check if the remaining sum - node.val == 0\n        # if both condition is true, then we find one of the paths\n        if not root.left and not root.right and remainingSum == root.val:\n            # lists passed a function are just references (i.e. Pass By Reference)\n            # and path.pop() would pop them all eventually\n            # therefore you need to create a new list there\n            # or your can use ans.append(path[:]) / ans.append(path.copy())\n            ans.append(list(path))\n        # traverse left sub tree with updated remaining sum\n        # we don't need to check if left sub tree is nullptr or not\n        # as we handle it in the first line of this function\n        self.dfs(root.left, path, ans, remainingSum - root.val)\n        # traverse right sub tree with updated remaining sum\n        # we don't need to check if right sub tree is nullptr or not\n        # as we handle it in the first line of this function\n        self.dfs(root.right, path, ans, remainingSum - root.val)\n        # backtrack\n        path.pop()\n\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        ans = []\n        self.dfs(root, [], ans, targetSum)\n        return ans\n"})})]}),(0,i.jsxs)(r,{value:"java",label:"Java",children:[(0,i.jsx)(t,{name:"@wkw"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    List<List<Integer>> ans = new ArrayList<List<Integer>>();\n    // the idea is to use dfs to traverse the tree from all root to leaf paths\n    // `path` is used to store the current route\n    // `remainingSum` is used to store thre remaining sum that we need with the initial value `targetSum`.\n    //  we substract it from the node value when we traverse down the tree\n    // if we arrive the leaf and the the remaining sum is eqaul to leaf node value\n    // then we can add `path` to ans\n    // e.g. path = [5,4,11,2] and remainingSum = targetSum = 22\n    // traverse node 5, remainingSum = 22 - 5 = 17\n    // traverse node 4, remainingSum = 17 - 4 = 13\n    // traverse node 11, remainingSum = 13 - 11 = 2\n    // traverse node 2, remainingSum = 2 - 2 = 0\n    // remainingSum is 0 which means the sum of current path is eqaul to targetSum\n    // so how to find another path?\n    // we can backtrack here\n    // we can pop back a node and try another\n    // e.g. path = [5, 4, 11, 7]\n    // pop 7 out = [5, 4, 11]\n    // push 2 = [5, 4, 11, 2]\n    // ... etc\n    private void dfs(TreeNode node, List<Integer> path, int remainingSum) {\n        // if it is null, then return\n        if (node == null) return;\n        // add the current node val to path\n        path.add(node.val);\n        // !node.left && !node.right : check if it is a leaf node\n        // remainingSum == node.val: check if the remaining sum - node.val == 0\n        // if both condition is true, then we find one of the paths\n        if (node.left == null && node.right == null && remainingSum == node.val) ans.add(new ArrayList<>(path));\n        // traverse left sub tree with updated remaining sum\n        // we don't need to check if left sub tree is nullptr or not\n        // as we handle it in the first line of this function\n        this.dfs(node.left, path, remainingSum - node.val);\n        // traverse right sub tree with updated remaining sum\n        // we don't need to check if right sub tree is nullptr or not\n        // as we handle it in the first line of this function\n        this.dfs(node.right, path, remainingSum - node.val);\n        // backtrack\n        path.remove(path.size() - 1);\n    }\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        List<Integer> path = new ArrayList<Integer>();\n        dfs(root, path, targetSum);\n        return ans;\n    }\n}\n\n"})})]}),(0,i.jsxs)(r,{value:"cs",label:"C#",children:[(0,i.jsx)(t,{name:"@lonyehan"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public List<IList<int>> result;\n\n    public void PreOrder(TreeNode root, int targetSum, List<int> list, int sum = 0) {\n        if(root == null) return;\n\n        sum += root.val;\n        list.Add(root.val);\n\n        // Is this node is leaf and sum equal to target?\n        if(sum == targetSum && root.left == null && root.right == null) {\n            result.Add(list);\n        }\n        PreOrder(root.left, targetSum, new List<int>(list), sum);\n        PreOrder(root.right, targetSum, new List<int>(list), sum);\n    }\n\n    public IList<IList<int>> PathSum(TreeNode root, int targetSum) {\n        result = new List<IList<int>>();\n        PreOrder(root, targetSum, new List<int>());\n        return result;\n    }\n}\n"})})]}),(0,i.jsxs)(r,{value:"js",label:"JavaScript",children:[(0,i.jsx)(t,{name:"@radojicic23"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {number[][]}\n */\nvar pathSum = function (root, targetSum) {\n  function dfs(root, remainingSum, path, ans) {\n    if (!root) return ans;\n    path.push(root.val);\n    if (!root.left && !root.right && root.val === remainingSum) {\n      ans.push(path.slice());\n    }\n    dfs(root.left, remainingSum - root.val, path, ans);\n    dfs(root.right, remainingSum - root.val, path, ans);\n    path.pop();\n    return ans;\n  }\n  return dfs(root, targetSum, [], []);\n};\n"})})]})]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function c(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},32790:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var r=t(30758);const i={},a=r.createContext(i);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);