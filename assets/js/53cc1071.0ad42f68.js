"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[63448],{85484:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>d,toc:()=>a});var t=r(85893),i=r(11151);const c={description:"Author: @wingkwong | https://leetcode.com/problems/encrypt-and-decrypt-strings"},s="2227 - Encrypt and Decrypt Strings (Hard)",d={id:"2200-2299/encrypt-and-decrypt-strings-hard",title:"2227 - Encrypt and Decrypt Strings (Hard)",description:"Author: @wingkwong | https://leetcode.com/problems/encrypt-and-decrypt-strings",source:"@site/solutions/2200-2299/2227-encrypt-and-decrypt-strings-hard.md",sourceDirName:"2200-2299",slug:"/2200-2299/encrypt-and-decrypt-strings-hard",permalink:"/solutions/2200-2299/encrypt-and-decrypt-strings-hard",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2200-2299/2227-encrypt-and-decrypt-strings-hard.md",tags:[],version:"current",sidebarPosition:2227,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/encrypt-and-decrypt-strings"},sidebar:"tutorialSidebar",previous:{title:"2226 - Maximum Candies Allocated to K Children (Medium)",permalink:"/solutions/2200-2299/maximum-candies-allocated-to-k-children-medium"},next:{title:"2229 - Check if an Array is Consecutive (Easy)",permalink:"/solutions/2200-2299/check-if-an-array-is-consecutive-easy"}},o={},a=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Hash Map",id:"approach-1-hash-map",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components},{SolutionAuthor:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("SolutionAuthor",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"2227---encrypt-and-decrypt-strings-hard",children:"2227 - Encrypt and Decrypt Strings (Hard)"})}),"\n",(0,t.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/encrypt-and-decrypt-strings",children:"https://leetcode.com/problems/encrypt-and-decrypt-strings"})}),"\n",(0,t.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,t.jsxs)(n.p,{children:["You are given a character array ",(0,t.jsx)(n.code,{children:"keys"})," containing ",(0,t.jsx)(n.strong,{children:"unique"})," characters and a string array ",(0,t.jsx)(n.code,{children:"values"})," containing strings of length 2. You are also given another string array ",(0,t.jsx)(n.code,{children:"dictionary"})," that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a ",(0,t.jsx)(n.strong,{children:"0-indexed"})," string."]}),"\n",(0,t.jsxs)(n.p,{children:["A string is ",(0,t.jsx)(n.strong,{children:"encrypted"})," with the following process:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["For each character ",(0,t.jsx)(n.code,{children:"c"})," in the string, we find the index ",(0,t.jsx)(n.code,{children:"i"})," satisfying ",(0,t.jsx)(n.code,{children:"keys[i] == c"})," in ",(0,t.jsx)(n.code,{children:"keys"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Replace ",(0,t.jsx)(n.code,{children:"c"})," with ",(0,t.jsx)(n.code,{children:"values[i]"})," in the string."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["A string is ",(0,t.jsx)(n.strong,{children:"decrypted"})," with the following process:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["For each substring ",(0,t.jsx)(n.code,{children:"s"})," of length 2 occurring at an even index in the string, we find an ",(0,t.jsx)(n.code,{children:"i"})," such that ",(0,t.jsx)(n.code,{children:"values[i] == s"}),". If there are multiple valid ",(0,t.jsx)(n.code,{children:"i"}),", we choose ",(0,t.jsx)(n.strong,{children:"any"})," one of them. This means a string could have multiple possible strings it can decrypt to."]}),"\n",(0,t.jsxs)(n.li,{children:["Replace ",(0,t.jsx)(n.code,{children:"s"})," with ",(0,t.jsx)(n.code,{children:"keys[i]"})," in the string."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Implement the ",(0,t.jsx)(n.code,{children:"Encrypter"})," class:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Encrypter(char[] keys, String[] values, String[] dictionary)"})," Initializes the ",(0,t.jsx)(n.code,{children:"Encrypter"})," class with ",(0,t.jsx)(n.code,{children:"keys, values"}),", and ",(0,t.jsx)(n.code,{children:"dictionary"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"String encrypt(String word1)"})," Encrypts ",(0,t.jsx)(n.code,{children:"word1"})," with the encryption process described above and returns the encrypted string."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"int decrypt(String word2)"})," Returns the number of possible strings ",(0,t.jsx)(n.code,{children:"word2"})," could decrypt to that also appear in ",(0,t.jsx)(n.code,{children:"dictionary"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'Input\n["Encrypter", "encrypt", "decrypt"]\n[[[\'a\', \'b\', \'c\', \'d\'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]], ["abcd"], ["eizfeiam"]]\nOutput\n[null, "eizfeiam", 2]\n\nExplanation\nEncrypter encrypter = new Encrypter([[\'a\', \'b\', \'c\', \'d\'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]);\nencrypter.encrypt("abcd"); // return "eizfeiam". \n                           // \'a\' maps to "ei", \'b\' maps to "zf", \'c\' maps to "ei", and \'d\' maps to "am".\nencrypter.decrypt("eizfeiam"); // return 2. \n                              // "ei" can map to \'a\' or \'c\', "zf" maps to \'b\', and "am" maps to \'d\'. \n                              // Thus, the possible strings after decryption are "abad", "cbad", "abcd", and "cbcd". \n                              // 2 of those strings, "abad" and "abcd", appear in dictionary, so the answer is 2.\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"1 <= keys.length == values.length <= 26"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"values[i].length == 2"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"1 <= dictionary.length <= 100"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"1 <= dictionary[i].length <= 100"})}),"\n",(0,t.jsxs)(n.li,{children:["All ",(0,t.jsx)(n.code,{children:"keys[i]"})," and ",(0,t.jsx)(n.code,{children:"dictionary[i]"})," are ",(0,t.jsx)(n.strong,{children:"unique"}),"."]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"1 <= word1.length <= 2000"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"1 <= word2.length <= 200"})}),"\n",(0,t.jsxs)(n.li,{children:["All ",(0,t.jsx)(n.code,{children:"word1[i]"})," appear in ",(0,t.jsx)(n.code,{children:"keys"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"word2.length"})," is even."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"keys"}),", ",(0,t.jsx)(n.code,{children:"values[i]"}),", ",(0,t.jsx)(n.code,{children:"dictionary[i]"}),", ",(0,t.jsx)(n.code,{children:"word1"}),", and ",(0,t.jsx)(n.code,{children:"word2"})," only contain lowercase English letters."]}),"\n",(0,t.jsxs)(n.li,{children:["At most ",(0,t.jsx)(n.code,{children:"200"})," calls will be made to ",(0,t.jsx)(n.code,{children:"encrypt"})," and ",(0,t.jsx)(n.code,{children:"decrypt"})," ",(0,t.jsx)(n.strong,{children:"in total"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"approach-1-hash-map",children:"Approach 1: Hash Map"}),"\n",(0,t.jsx)(n.p,{children:"No Tries is required. We can use hash map to store the frequency of the encrypted string. To decrypt, we simply return the count of the target word. To encrypt, we find the corresponding keys to map to the returned string."}),"\n",(0,t.jsx)(r,{name:"@wingkwong"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class Encrypter {\npublic:\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\n        k = keys, v = values;\n        for (auto x : dictionary) m[encrypt(x)]++;\n    }\n    \n    string encrypt(string word1) {\n        string res;\n        for (auto x : word1) {\n            for(int i = 0; i < k.size(); i++) {\n                if (k[i] == x) {\n                    res += v[i];\n                }\n            }\n        }\n        return res;\n    }\n    \n    int decrypt(string word2) {\n        return m[word2];\n    }\nprivate:\n    vector<char> k;\n    vector<string> v;\n    map<string, int> m;\n};\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\n * string param_1 = obj->encrypt(word1);\n * int param_2 = obj->decrypt(word2);\n */\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>d,a:()=>s});var t=r(67294);const i={},c=t.createContext(i);function s(e){const n=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);