"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[75403],{86174:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>c,frontMatter:()=>l,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"1300-1399/longest-zigzag-path-in-a-binary-tree-medium","title":"1372 - Longest ZigZag Path in a Binary Tree (Medium)","description":"Author: @wkw | https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/","source":"@site/solutions/1300-1399/1372-longest-zigzag-path-in-a-binary-tree-medium.md","sourceDirName":"1300-1399","slug":"/1300-1399/longest-zigzag-path-in-a-binary-tree-medium","permalink":"/solutions/1300-1399/longest-zigzag-path-in-a-binary-tree-medium","draft":false,"unlisted":false,"editUrl":"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1300-1399/1372-longest-zigzag-path-in-a-binary-tree-medium.md","tags":[{"inline":true,"label":"Dynamic Programming","permalink":"/solutions/tags/dynamic-programming"},{"inline":true,"label":"Tree","permalink":"/solutions/tags/tree"},{"inline":true,"label":"Depth-First Search","permalink":"/solutions/tags/depth-first-search"},{"inline":true,"label":"Binary Tree","permalink":"/solutions/tags/binary-tree"}],"version":"current","sidebarPosition":1372,"frontMatter":{"description":"Author: @wkw | https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/","tags":["Dynamic Programming","Tree","Depth-First Search","Binary Tree"]},"sidebar":"tutorialSidebar","previous":{"title":"1371 - Find the Longest Substring Containing Vowels in Even Counts (Medium)","permalink":"/solutions/1300-1399/find-the-longest-substring-containing-vowels-in-even-counts-medium"},"next":{"title":"1383 - Maximum Performance of a Team (Hard)","permalink":"/solutions/1300-1399/maximum-performance-of-a-team-hard"}}');var i=t(86070),o=t(32790);const l={description:"Author: @wkw | https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/",tags:["Dynamic Programming","Tree","Depth-First Search","Binary Tree"]},s="1372 - Longest ZigZag Path in a Binary Tree (Medium)",a={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS",id:"approach-1-dfs",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{SolutionAuthor:t,TabItem:r,Tabs:l}=n;return t||g("SolutionAuthor",!0),r||g("TabItem",!0),l||g("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"1372---longest-zigzag-path-in-a-binary-tree-medium",children:"1372 - Longest ZigZag Path in a Binary Tree (Medium)"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/",children:"https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(n.p,{children:["You are given the ",(0,i.jsx)(n.code,{children:"root"})," of a binary tree."]}),"\n",(0,i.jsx)(n.p,{children:"A ZigZag path for a binary tree is defined as follow:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Choose ",(0,i.jsx)(n.strong,{children:"any"}),"node in the binary tree and a direction (right or left)."]}),"\n",(0,i.jsx)(n.li,{children:"If the current direction is right, move to the right child of the current node; otherwise, move to the left child."}),"\n",(0,i.jsx)(n.li,{children:"Change the direction from right to left or from left to right."}),"\n",(0,i.jsx)(n.li,{children:"Repeat the second and third steps until you can't move in the tree."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0)."}),"\n",(0,i.jsxs)(n.p,{children:["Return ",(0,i.jsxs)(n.em,{children:["the longest ",(0,i.jsx)(n.strong,{children:"ZigZag"})," path contained in that tree"]}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]\nOutput: 3\nExplanation: Longest ZigZag path in blue nodes (right -> left -> right).\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: root = [1,1,1,null,1,null,null,1,1,null,1]\nOutput: 4\nExplanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 3:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: root = [1]\nOutput: 0\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The number of nodes in the tree is in the range ",(0,i.jsx)(n.code,{children:"[1, 5 * 10^4]"}),"."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= Node.val <= 100"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"approach-1-dfs",children:"Approach 1: DFS"}),"\n",(0,i.jsxs)(l,{children:[(0,i.jsxs)(r,{value:"cpp",label:"C++",children:[(0,i.jsx)(t,{name:"@wkw"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int dfs(TreeNode* root, int isLeft, int cnt) {\n        // root is nullptr, we can return `cnt`\n        if (!root) return cnt;\n        // if `isLeft` is true, we have two choices\n        // 1. go to right making a zipzag path - increase the cnt by 1\n        // 2. still go to left - starting a new zigzag path - hence cnt is set to 0\n        if (isLeft) return max(dfs(root->right, 0, cnt + 1), dfs(root->left, 1, 0));\n        // similarly, we apply the same logic for the opposite direction\n        return max(dfs(root->left, 1, cnt + 1), dfs(root->right, 0, 0));\n    }\n    int longestZigZag(TreeNode* root) {\n        // go through left-subtree and right-subtree\n        // get the max result\n        return max(dfs(root->left, 1, 0), dfs(root->right, 0, 0));\n    }\n};\n"})})]}),(0,i.jsxs)(r,{value:"py",label:"Python",children:[(0,i.jsx)(t,{name:"@wkw"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\n        def dfs(node, isLeft, cnt):\n            # root is None, we can return `cnt`\n            if node is None: return cnt\n            # if `isLeft` is true, we have two choices\n            # 1. go to right making a zipzag path - increase the cnt by 1\n            # 2. still go to left - starting a new zigzag path - hence cnt is set to 0\n            if isLeft:  return max(dfs(node.right, 0, cnt + 1), dfs(node.left, 1, 0))\n            # similarly, we apply the same logic for the opposite direction\n            return max(dfs(node.left, 1, cnt + 1), dfs(node.right, 0, 0))\n        # go through left-subtree and right-subtree and get the max result\n        return max(dfs(root.left, 1, 0), dfs(root.right, 0, 0))\n\n"})})]})]})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function g(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},32790:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var r=t(30758);const i={},o=r.createContext(i);function l(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);