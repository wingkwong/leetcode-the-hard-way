"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[41218],{35877(e,a,t){t.r(a),t.d(a,{assets:()=>p,contentTitle:()=>m,default:()=>N,frontMatter:()=>s,metadata:()=>o,toc:()=>i});var n=t(9346),r=(t(37953),t(58860));const s={title:"Bellman Ford Algorithm",description:"Bellman Ford Algorithm computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph",keywords:["leetcode","tutorial","bellman ford","algorithm"]},m=void 0,o={unversionedId:"graph-theory/bellman-ford-algorithm",id:"graph-theory/bellman-ford-algorithm",title:"Bellman Ford Algorithm",description:"Bellman Ford Algorithm computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph",source:"@site/tutorials/graph-theory/bellman-ford-algorithm.md",sourceDirName:"graph-theory",slug:"/graph-theory/bellman-ford-algorithm",permalink:"/tutorials/graph-theory/bellman-ford-algorithm",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/graph-theory/bellman-ford-algorithm.md",tags:[],version:"current",frontMatter:{title:"Bellman Ford Algorithm",description:"Bellman Ford Algorithm computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph",keywords:["leetcode","tutorial","bellman ford","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/tutorials/graph-theory/introduction"},next:{title:"Binary Search Tree",permalink:"/tutorials/graph-theory/binary-search-tree"}},p={},i=[{value:"Overview",id:"overview",level:2},{value:"Implementation",id:"implementation",level:2}],l=e=>function(a){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.yg)("div",a)},g=l("TutorialCredits"),c=l("Tabs"),h=l("TabItem"),y=l("SolutionAuthor"),d={toc:i};function N({components:e,...a}){return(0,r.yg)("wrapper",(0,n.A)({},d,a,{components:e,mdxType:"MDXLayout"}),(0,r.yg)(g,{authors:"@wkw",mdxType:"TutorialCredits"}),(0,r.yg)("h2",{id:"overview"},"Overview"),(0,r.yg)("p",null,"Bellman Ford Algorithm computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph. Similar to Dijkstra's algorithm, it proceeds by relaxation. However, Dijkstra's algorithm uses a priority queue to greedily select the closest vertex that has not been processed, which all of its outgoing edges will be processed. On the other hand, Bellman Ford Algorithm relaxes all the edges and does the relaxation only ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.yg)("mi",{parentName:"mrow"},"V"),(0,r.yg)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.yg)("mo",{parentName:"mrow"},"\u2212"),(0,r.yg)("mn",{parentName:"mrow"},"1")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"|V| - 1")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.yg)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V"),(0,r.yg)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.yg)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,r.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.yg)("span",{parentName:"span",className:"mord"},"1")))))," times where ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.yg)("mi",{parentName:"mrow"},"V"),(0,r.yg)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"|V|")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.yg)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V"),(0,r.yg)("span",{parentName:"span",className:"mord"},"\u2223")))))," is the number of vertices in the graph. This is because given a graph with no negative weight cycles with ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"V")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"V")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V")))))," vertices, the shortest path between any two vertices has at most ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.yg)("mi",{parentName:"mrow"},"V"),(0,r.yg)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,r.yg)("mo",{parentName:"mrow"},"\u2212"),(0,r.yg)("mn",{parentName:"mrow"},"1")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"|V| - 1")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.yg)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V"),(0,r.yg)("span",{parentName:"span",className:"mord"},"\u2223"),(0,r.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.yg)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,r.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.yg)("span",{parentName:"span",className:"mord"},"1")))))," edges."),(0,r.yg)("h2",{id:"implementation"},"Implementation"),(0,r.yg)(c,{mdxType:"Tabs"},(0,r.yg)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.yg)(y,{name:"@wkw",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-cpp"},"template<typename T_a3, typename T_vector>\nvoid bellman_ford(T_a3 &g, T_vector &dist, int src, int mx_edges) {\n    dist[src] = 0;\n    for (int i = 0; i <= mx_edges; i++) {\n        T_vector ndist = dist;\n        for (auto x : g) {\n            auto [from, to, cost] = x;\n            ndist[to] = min(ndist[to], dist[from] + cost);\n        }\n        dist = ndist;\n    }\n}\n"))),(0,r.yg)(h,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.yg)(y,{name:"@Odion-Sonny",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-py"},"def bellman_ford(g, dist, src, mx_edges):\n    dist[src] = 0\n    for i in range(mx_edges + 1):\n        ndist = dist[:]\n        for x in g:\n            _from, to, cost = x\n            ndist[to] = min(ndist[to], dist[_from] + cost)\n        dist = ndist\n    return dist\n")))))}N.isMDXComponent=!0},58860(e,a,t){t.d(a,{xA:()=>l,yg:()=>h});var n=t(37953);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),t.push.apply(t,n)}return t}function m(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach(function(a){r(e,a,t[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))})}return e}function o(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=n.createContext({}),i=function(e){var a=n.useContext(p),t=a;return e&&(t="function"==typeof e?e(a):m(m({},a),e)),t},l=function(e){var a=i(e.components);return n.createElement(p.Provider,{value:a},e.children)},g={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},c=n.forwardRef(function(e,a){var t=e.components,r=e.mdxType,s=e.originalType,p=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),c=i(t),h=r,y=c["".concat(p,".").concat(h)]||c[h]||g[h]||s;return t?n.createElement(y,m(m({ref:a},l),{},{components:t})):n.createElement(y,m({ref:a},l))});function h(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var s=t.length,m=new Array(s);m[0]=c;var o={};for(var p in a)hasOwnProperty.call(a,p)&&(o[p]=a[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,m[1]=o;for(var i=2;i<s;i++)m[i]=t[i];return n.createElement.apply(null,m)}return n.createElement.apply(null,t)}c.displayName="MDXCreateElement"}}]);