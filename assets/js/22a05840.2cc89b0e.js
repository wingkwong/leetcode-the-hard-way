"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[94673],{96509:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=n(85893),s=n(11151);const r={description:"Author: @wingkwong | https://leetcode.com/problems/best-team-with-no-conflicts/",tags:["Array","Dynamic Programming","Sorting"]},o="1626 - Best Team With No Conflicts (Medium)",a={id:"1600-1699/best-team-with-no-conflicts-medium",title:"1626 - Best Team With No Conflicts (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/best-team-with-no-conflicts/",source:"@site/solutions/1600-1699/1626-best-team-with-no-conflicts-medium.md",sourceDirName:"1600-1699",slug:"/1600-1699/best-team-with-no-conflicts-medium",permalink:"/solutions/1600-1699/best-team-with-no-conflicts-medium",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1600-1699/1626-best-team-with-no-conflicts-medium.md",tags:[{inline:!0,label:"Array",permalink:"/solutions/tags/array"},{inline:!0,label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{inline:!0,label:"Sorting",permalink:"/solutions/tags/sorting"}],version:"current",sidebarPosition:1626,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/best-team-with-no-conflicts/",tags:["Array","Dynamic Programming","Sorting"]},sidebar:"tutorialSidebar",previous:{title:"1624 - Largest Substring Between Two Equal Characters (Easy)",permalink:"/solutions/1600-1699/largest-substring-between-two-equal-characters-easy"},next:{title:"1630 - Arithmetic Subarrays (Medium)",permalink:"/solutions/1600-1699/arithmetic-subarrays-medium"}},l={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dynamic Programming",id:"approach-1-dynamic-programming",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components},{SolutionAuthor:n,TabItem:r,Tabs:o}=t;return n||m("SolutionAuthor",!0),r||m("TabItem",!0),o||m("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"1626---best-team-with-no-conflicts-medium",children:"1626 - Best Team With No Conflicts (Medium)"})}),"\n",(0,i.jsx)(t.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://leetcode.com/problems/best-team-with-no-conflicts/",children:"https://leetcode.com/problems/best-team-with-no-conflicts/"})}),"\n",(0,i.jsx)(t.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(t.p,{children:["You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the ",(0,i.jsx)(t.strong,{children:"sum"})," of scores of all the players in the team."]}),"\n",(0,i.jsxs)(t.p,{children:["However, the basketball team is not allowed to have ",(0,i.jsx)(t.strong,{children:"conflicts"}),". A ",(0,i.jsx)(t.strong,{children:"conflict"})," exists if a younger player has a ",(0,i.jsx)(t.strong,{children:"strictly higher"})," score than an older player. A conflict does ",(0,i.jsx)(t.strong,{children:"not"})," occur between players of the same age."]}),"\n",(0,i.jsxs)(t.p,{children:["Given two lists, ",(0,i.jsx)(t.code,{children:"scores"})," and ",(0,i.jsx)(t.code,{children:"ages"}),", where each ",(0,i.jsx)(t.code,{children:"scores[i]"})," and ",(0,i.jsx)(t.code,{children:"ages[i]"})," represents the score and age of the ",(0,i.jsx)(t.code,{children:"ith"})," player, respectively, return ",(0,i.jsx)(t.em,{children:"the highest overall score of all possible basketball teams"}),"."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Input: scores = [1,3,5,10,15], ages = [1,2,3,4,5]\nOutput: 34\nExplanation:\xa0You can choose all the players.\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Input: scores = [4,5,6,5], ages = [2,1,2,1]\nOutput: 16\nExplanation:\xa0It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Example 3:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Input: scores = [1,2,3,5], ages = [8,9,10,1]\nOutput: 6\nExplanation:\xa0It is best to choose the first 3 players.\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"1 <= scores.length, ages.length <= 1000"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"scores.length == ages.length"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"1 <= scores[i] <= 106"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"1 <= ages[i] <= 1000"})}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"approach-1-dynamic-programming",children:"Approach 1: Dynamic Programming"}),"\n",(0,i.jsx)(t.p,{children:"For this kind of DP questions, remember the following"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"calculate the result if you skip this candidate"}),"\n",(0,i.jsx)(t.li,{children:"calculate the result if you pick this candidate"}),"\n",(0,i.jsx)(t.li,{children:"take the max result of them then memorise it"}),"\n"]}),"\n",(0,i.jsx)(o,{children:(0,i.jsxs)(r,{value:"cpp",label:"C++",children:[(0,i.jsx)(n,{name:"@wingkwong"}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"class Solution {\npublic:\n    int dp[1005][1005];\n    // i is the index of g\n    // age is the max age so far\n    int dfs(vector<pair<int, int>>& g, int i, int age) {\n        // if i reaches the end, then return 0\n        if (i == g.size()) return 0;\n        // if dp[i][age] is calculated before, return it directly\n        if (dp[i][age] != -1) return dp[i][age];\n        // we have two choices - either take this player or skip it\n        // we first calculate the score if we skip this player\n        int res = dfs(g, i + 1, age);\n        // if we want to take this player, we need to check if there is a conflict\n        // since the score is sorted, we just need to check the age\n        // if we take this player, the score will be increased by g[i].first\n        // then we add the result from `dfs(g, i + 1, g[i].second)`\n        // since we take this player, we need ti mark the age as g[i].second\n        if (g[i].second >= age) res = max(res, g[i].first + dfs(g, i + 1, g[i].second));\n        // memo it\n        return dp[i][age] = res;\n    }\n    int bestTeamScore(vector<int>& scores, vector<int>& ages) {\n        // init dp with initial value -1\n        memset(dp, -1, sizeof(dp));\n        // we sort by score, then age\n        vector<pair<int, int>> g;\n        for (int i = 0; i < scores.size(); i++) {\n            g.push_back({scores[i], ages[i]});\n        }\n        sort(g.begin(), g.end());\n        return dfs(g, 0, 0);\n    }\n};\n"})})]})})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}function m(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>o});var i=n(67294);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);