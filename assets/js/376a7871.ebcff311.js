"use strict";(globalThis.webpackChunkleetcode_the_hard_way=globalThis.webpackChunkleetcode_the_hard_way||[]).push([[46211],{53138(e,a,t){t.r(a),t.d(a,{assets:()=>i,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var n=t(9346),r=(t(37953),t(58860));const l={description:"Author: @SkollRyu, @ColeB2 | https://leetcode.com/problems/balanced-binary-tree/"},s="0110 - Balanced Binary Tree (Easy)",o={unversionedId:"0100-0199/balanced-binary-tree-easy",id:"0100-0199/balanced-binary-tree-easy",title:"0110 - Balanced Binary Tree (Easy)",description:"Author: @SkollRyu, @ColeB2 | https://leetcode.com/problems/balanced-binary-tree/",source:"@site/solutions/0100-0199/0110-balanced-binary-tree-easy.md",sourceDirName:"0100-0199",slug:"/0100-0199/balanced-binary-tree-easy",permalink:"/solutions/0100-0199/balanced-binary-tree-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0100-0199/0110-balanced-binary-tree-easy.md",tags:[],version:"current",sidebarPosition:110,frontMatter:{description:"Author: @SkollRyu, @ColeB2 | https://leetcode.com/problems/balanced-binary-tree/"},sidebar:"tutorialSidebar",previous:{title:"0105 - Construct Binary Tree from Preorder and Inorder Traversal (Medium)",permalink:"/solutions/0100-0199/construct-binary-tree-from-preorder-and-inorder-traversal-medium"},next:{title:"0112 - Path Sum (Easy)",permalink:"/solutions/0100-0199/path-sum-easy"}},i={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Visualization",id:"visualization",level:2},{value:"Approach 1: Straight forward - Recursion",id:"approach-1-straight-forward---recursion",level:2}],m=e=>function(a){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.yg)("div",a)},c=m("Tabs"),u=m("TabItem"),g=m("SolutionAuthor"),y={toc:p};function h({components:e,...a}){return(0,r.yg)("wrapper",(0,n.A)({},y,a,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"0110---balanced-binary-tree-easy"},"0110 - Balanced Binary Tree (Easy)"),(0,r.yg)("h2",{id:"problem-link"},"Problem Link"),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/balanced-binary-tree/"},"https://leetcode.com/problems/balanced-binary-tree/")),(0,r.yg)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.yg)("p",null,"Given a binary tree, determine if it is height-balanced."),(0,r.yg)("p",null,"For this problem, a height-balanced binary tree is defined as:"),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},"a binary tree in which the left and right subtrees of ",(0,r.yg)("em",{parentName:"p"},"every")," node differ in height by no more than 1.")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 1:")),(0,r.yg)("p",null,(0,r.yg)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg",alt:null})),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: root = [3,9,20,null,null,15,7]\nOutput: true\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 2:")),(0,r.yg)("p",null,(0,r.yg)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg",alt:null})),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example 3:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Input: root = []\nOutput: true\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Constraints:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The number of nodes in the tree is in the range ",(0,r.yg)("inlineCode",{parentName:"li"},"[0, 5000]"),"."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"-10^4 <= Node.val <= 10^4"))),(0,r.yg)("h2",{id:"visualization"},"Visualization"),(0,r.yg)("p",null,(0,r.yg)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/63882653/152684367-0ea099bd-623c-4d5a-8862-0ec035620c13.jpg",alt:"height-balanced"})," ",(0,r.yg)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/63882653/152684944-1e774af3-8303-42be-9d7b-20af26221f74.jpg",alt:"Height-unbalanced"})),(0,r.yg)("h2",{id:"approach-1-straight-forward---recursion"},"Approach 1: Straight forward - Recursion"),(0,r.yg)("p",null,"This solution is strictly following the definition of a balanced binary tree."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"(1) ABS(left sub-tree's height - right sub-tree's height) ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mo",{parentName:"mrow"},"<"),(0,r.yg)("mo",{parentName:"mrow"},"="),(0,r.yg)("mn",{parentName:"mrow"},"1")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"<= 1")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.5782em",verticalAlign:"-0.0391em"}}),(0,r.yg)("span",{parentName:"span",className:"mrel"},"<="),(0,r.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.yg)("span",{parentName:"span",className:"mord"},"1"))))),".")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"(2) Every left sub-trees and right sub-trees are also balanced."))),(0,r.yg)("p",null,"First, we need to set up the base case for the recursion solution. Then we check if the whole left subtree and right subtree are balanced. If so, then we check if every subtrees are balanced."),(0,r.yg)("p",null,"Time Complexity: ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"O"),(0,r.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.yg)("mi",{parentName:"mrow"},"n"),(0,r.yg)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.yg)("span",{parentName:"span",className:"mopen"},"("),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.yg)("span",{parentName:"span",className:"mclose"},")")))))," as recursively we are going to have to process each node inside the tree at least once using a depth-first approach."),(0,r.yg)("p",null,"Space Complexity: ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow"},"O"),(0,r.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.yg)("mi",{parentName:"mrow"},"h"),(0,r.yg)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(h)")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.yg)("span",{parentName:"span",className:"mopen"},"("),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,r.yg)("span",{parentName:"span",className:"mclose"},")")))))," as using a recursive DFS solution will only ever hold the current path inside our call stack, which will scale with the height of the tree."),(0,r.yg)(c,{mdxType:"Tabs"},(0,r.yg)(u,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.yg)(g,{name:"@SkollRyu",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public boolean isBalanced(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        if(Math.abs(height(root.left) - height(root.right)) <= 1){\n            return isBalanced(root.left) && isBalanced(root.right);\n        } else {\n            return false;\n        }\n    }\n\n    public int height(TreeNode root){\n        if (root == null) return -1;\n        int ld = height(root.left);\n        int rd = height(root.right);\n        return 1 + Math.max(ld,rd);\n    }\n}\n"))),(0,r.yg)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,r.yg)(g,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-py"},"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # We will use Truthy values for our return here. Meaning if we return any\n    # number that isn't 0, the judge will consider is similar as returning True.\n    # And if we return 0/False, the judge will consider it as a False value.\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        # Base case null node:\n        # We will use 1 as height of null node here as it accomplishes 2 things:\n        # 1. it passes up a height value for child nodes,\n        #    Ex. For a child node. If we calculate the left/right height\n        #    difference, it will come out to 0 regardless if we use 0-0 or 1-1.\n        # 2. it acts as a 'Truthy' value for the 'null tree'\n        #    Ex. if our initial input is null, ie an empty tree. It is considered\n        #    balanced, and the 1 value acts as a 'Truthy' value to return True.\n        if not root:\n            return 1\n        # Find the height of the left sub-tree - recursively.\n        left = self.isBalanced(root.left)\n        # if left sub-tree is ever False, stop. No need to continue.\n        if not left:\n            return False\n        # Find the height of the right sub-tree - recursively.\n        right = self.isBalanced(root.right)\n        # if right sub-tree is ever False, stop. No need to continue\n        if not right:\n            return False\n        # Calculate the height differences. If they are ever > 1: not balanced.\n        if abs(left - right) > 1:\n            return False\n        # Return height of longest subtree up for further calculations.\n        return max(left, right) + 1\n")))))}h.isMDXComponent=!0},58860(e,a,t){t.d(a,{xA:()=>m,yg:()=>g});var n=t(37953);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach(function(a){r(e,a,t[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))})}return e}function o(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=n.createContext({}),p=function(e){var a=n.useContext(i),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},m=function(e){var a=p(e.components);return n.createElement(i.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef(function(e,a){var t=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(t),g=r,y=u["".concat(i,".").concat(g)]||u[g]||c[g]||l;return t?n.createElement(y,s(s({ref:a},m),{},{components:t})):n.createElement(y,s({ref:a},m))});function g(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var l=t.length,s=new Array(l);s[0]=u;var o={};for(var i in a)hasOwnProperty.call(a,i)&&(o[i]=a[i]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var p=2;p<l;p++)s[p]=t[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);